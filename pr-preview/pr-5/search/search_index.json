{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>The documentation for <code>particula</code> is organized into Jupyter notebooks that can be executed in the browser. To learn more about Jupyter notebooks, visit jupyter.org and jupyterbook.org.</p>"},{"location":"#installing-particula","title":"Installing <code>particula</code>","text":"<p>You can install <code>particula</code> from PyPI using the following command:</p> <pre><code>python -m pip install particula\n</code></pre> <p>Or from conda-forge using the following command:</p> <pre><code>conda install -c conda-forge particula\n</code></pre> <p>Alternative, you could fork the repository (or copy it locally) and install it using the following command:</p> <pre><code>git clone https://github.com/uncscode/particula.git\ncd particula\npython -m pip install particula\n</code></pre>"},{"location":"#contributing-to-particula","title":"Contributing to <code>particula</code>","text":"<p>We are open to and we welcome contributions from anyone who wants to contribute to this project. We have a short contributing document in the root of the repository, which you can read here. However, feel free to reach out with any questions or comments!</p>"},{"location":"#quick-links","title":"Quick links","text":""},{"location":"Source-Code/particula/","title":"Particula","text":"<p>Particula Index / Particula</p> <p>Auto-generated documentation for particula module.</p>"},{"location":"Source-Code/particula/#attributes","title":"Attributes","text":"<ul> <li> <p><code>u</code> - u is the unit registry name.: UnitRegistry(force_ndarray=True)</p> </li> <li> <p><code>logger</code> - setup the logger: setup()</p> </li> </ul>"},{"location":"Source-Code/particula/#modules","title":"Modules","text":"<ul> <li>Activity</li> <li>Constants</li> <li>Data</li> <li>Dynamics</li> <li>Environment</li> <li>Equilibria</li> <li>Lagrangian</li> <li>Logger Setup</li> <li>Next</li> <li>Particle</li> <li>Rates</li> <li>Util</li> <li>Vapor</li> </ul>"},{"location":"Source-Code/particula/constants/","title":"Constants","text":"<p>Particula Index / Particula / Constants</p> <p>Auto-generated documentation for particula.constants module.</p>"},{"location":"Source-Code/particula/constants/#attributes","title":"Attributes","text":"<ul> <li> <p><code>GAS_CONSTANT</code> - Gas constant in J mol^-1 K^-1 = m^2 kg mol^-1 s^-2 K^-1   J = kg m^2 s^-2   or (1*u.molar_gas_constant).to_base_units(): BOLTZMANN_CONSTANT * AVOGADRO_NUMBER</p> </li> <li> <p><code>RELATIVE_PERMITTIVITY_AIR_ROOM</code> - Relative permittivity of air at approx.   296.15 K and 101325 Pa and 40% RH   See https://www.osti.gov/servlets/purl/1504063   Previously known as the \"dielectric constant\"   Often denoted as epsilon: 1.000530569</p> </li> <li> <p><code>RELATIVE_PERMITTIVITY_AIR_STP</code> - At STP (273.15 K, 1 atm):   see: https://en.wikipedia.org/wiki/Relative_permittivity: 1.00058986</p> </li> <li> <p><code>RELATIVE_PERMITTIVITY_AIR</code> - select one of the two:: RELATIVE_PERMITTIVITY_AIR_ROOM</p> </li> <li> <p><code>VACUUM_PERMITTIVITY</code> - Permittivity of free space in F/m   Also known as the electric constant, permittivity of free space   Often denoted by epsilon_0: 1 * u.vacuum_permittivity.to_base_units()</p> </li> <li> <p><code>REF_VISCOSITY_AIR_STP</code> - These values are used to calculate the dynamic viscosity of air   Here, REF temperature and viscosity are at STP:   Standard temperature and pressure (273.15 K and 101325 Pa): 1.716e-05 * u.Pa * u.s</p> </li> </ul>"},{"location":"Source-Code/particula/dynamics/","title":"Dynamics","text":"<p>Particula Index / Particula / Dynamics</p> <p>Auto-generated documentation for particula.dynamics module.</p>"},{"location":"Source-Code/particula/dynamics/#solver","title":"Solver","text":"<p>Show source in dynamics.py:8</p> <p>dynamic solver</p>"},{"location":"Source-Code/particula/dynamics/#signature","title":"Signature","text":"<pre><code>class Solver(Rates):\n    def __init__(\n        self,\n        time_span=None,\n        do_coagulation=True,\n        do_condensation=True,\n        do_nucleation=True,\n        do_dilution=False,\n        do_wall_loss=False,\n        **kwargs\n    ): ...\n</code></pre>"},{"location":"Source-Code/particula/dynamics/#see-also","title":"See also","text":"<ul> <li>Rates</li> </ul>"},{"location":"Source-Code/particula/dynamics/#solver_ode_func","title":"Solver()._ode_func","text":"<p>Show source in dynamics.py:36</p> <p>ode_func</p>"},{"location":"Source-Code/particula/dynamics/#signature_1","title":"Signature","text":"<pre><code>def _ode_func(self, _nums, _): ...\n</code></pre>"},{"location":"Source-Code/particula/dynamics/#solversolution","title":"Solver().solution","text":"<p>Show source in dynamics.py:53</p> <p>solve the equation</p>"},{"location":"Source-Code/particula/dynamics/#signature_2","title":"Signature","text":"<pre><code>def solution(self, method=\"odeint\", **kwargs_ode): ...\n</code></pre>"},{"location":"Source-Code/particula/environment/","title":"Environment","text":"<p>Particula Index / Particula / Environment</p> <p>Auto-generated documentation for particula.environment module.</p>"},{"location":"Source-Code/particula/environment/#environment_1","title":"Environment","text":"<p>Show source in environment.py:67</p> <p>creating the environment class</p> <p>For now, the environment class takes properties such as temperature and pressure to calculate derived properties such as viscosity and mean free path.</p>"},{"location":"Source-Code/particula/environment/#signature","title":"Signature","text":"<pre><code>class Environment(SharedProperties):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/environment/#see-also","title":"See also","text":"<ul> <li>SharedProperties</li> </ul>"},{"location":"Source-Code/particula/environment/#environmentdynamic_viscosity","title":"Environment().dynamic_viscosity","text":"<p>Show source in environment.py:110</p> <p>Returns the dynamic viscosity in Pa*s.</p>"},{"location":"Source-Code/particula/environment/#signature_1","title":"Signature","text":"<pre><code>def dynamic_viscosity(self): ...\n</code></pre>"},{"location":"Source-Code/particula/environment/#environmentmean_free_path","title":"Environment().mean_free_path","text":"<p>Show source in environment.py:120</p> <p>Returns the mean free path in m.</p>"},{"location":"Source-Code/particula/environment/#signature_2","title":"Signature","text":"<pre><code>def mean_free_path(self): ...\n</code></pre>"},{"location":"Source-Code/particula/environment/#environmentwater_vapor_concentration","title":"Environment().water_vapor_concentration","text":"<p>Show source in environment.py:131</p> <p>Returns the water vapor concentration in kg/m^3.</p>"},{"location":"Source-Code/particula/environment/#signature_3","title":"Signature","text":"<pre><code>def water_vapor_concentration(self): ...\n</code></pre>"},{"location":"Source-Code/particula/environment/#sharedproperties","title":"SharedProperties","text":"<p>Show source in environment.py:41</p> <p>a hidden class for sharing properties like coagulation_approximation</p>"},{"location":"Source-Code/particula/environment/#signature_4","title":"Signature","text":"<pre><code>class SharedProperties:\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/environment/#sharedpropertiesdilution_rate_coefficient","title":"SharedProperties().dilution_rate_coefficient","text":"<p>Show source in environment.py:58</p> <p>get the dilution rate coefficient</p>"},{"location":"Source-Code/particula/environment/#signature_5","title":"Signature","text":"<pre><code>def dilution_rate_coefficient(self): ...\n</code></pre>"},{"location":"Source-Code/particula/logger_setup/","title":"Logger Setup","text":"<p>Particula Index / Particula / Logger Setup</p> <p>Auto-generated documentation for particula.logger_setup module.</p>"},{"location":"Source-Code/particula/logger_setup/#attributes","title":"Attributes","text":"<ul> <li> <p><code>current_dir</code> - get path of the current directory: os.path.dirname(os.path.abspath(file))</p> </li> <li> <p><code>log_dir</code> - add the logging directory to the path: os.path.join(current_dir, 'logging')</p> </li> </ul>"},{"location":"Source-Code/particula/logger_setup/#setup","title":"setup","text":"<p>Show source in logger_setup.py:65</p> <p>Setup for logging in the particula package.</p>"},{"location":"Source-Code/particula/logger_setup/#signature","title":"Signature","text":"<pre><code>def setup(): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/","title":"Particle","text":"<p>Particula Index / Particula / Particle</p> <p>Auto-generated documentation for particula.particle module.</p>"},{"location":"Source-Code/particula/particle/#particle_1","title":"Particle","text":"<p>Show source in particle.py:386</p> <p>the Particle class!</p>"},{"location":"Source-Code/particula/particle/#signature","title":"Signature","text":"<pre><code>class Particle(ParticleWallLoss):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#see-also","title":"See also","text":"<ul> <li>ParticleWallLoss</li> </ul>"},{"location":"Source-Code/particula/particle/#particle_coag_prep","title":"Particle()._coag_prep","text":"<p>Show source in particle.py:410</p> <p>get all related quantities to coulomb enhancement</p>"},{"location":"Source-Code/particula/particle/#signature_1","title":"Signature","text":"<pre><code>def _coag_prep(self, other: \"Particle\"): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlecoagulation","title":"Particle().coagulation","text":"<p>Show source in particle.py:464</p> <p>Dimensioned particle--particle coagulation kernel</p>"},{"location":"Source-Code/particula/particle/#signature_2","title":"Signature","text":"<pre><code>def coagulation(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlecoulomb_enhancement_continuum_limit","title":"Particle().coulomb_enhancement_continuum_limit","text":"<p>Show source in particle.py:448</p> <p>Continuum limit of Coulomb enhancement for particle--particle coagulation.</p>"},{"location":"Source-Code/particula/particle/#signature_3","title":"Signature","text":"<pre><code>def coulomb_enhancement_continuum_limit(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlecoulomb_enhancement_kinetic_limit","title":"Particle().coulomb_enhancement_kinetic_limit","text":"<p>Show source in particle.py:442</p> <p>Kinetic limit of Coulomb enhancement for particle--particle cooagulation.</p>"},{"location":"Source-Code/particula/particle/#signature_4","title":"Signature","text":"<pre><code>def coulomb_enhancement_kinetic_limit(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlecoulomb_potential_ratio","title":"Particle().coulomb_potential_ratio","text":"<p>Show source in particle.py:437</p> <p>Calculates the Coulomb potential ratio.</p>"},{"location":"Source-Code/particula/particle/#signature_5","title":"Signature","text":"<pre><code>def coulomb_potential_ratio(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlediffusive_knudsen_number","title":"Particle().diffusive_knudsen_number","text":"<p>Show source in particle.py:454</p> <p>Diffusive Knudsen number.</p>"},{"location":"Source-Code/particula/particle/#signature_6","title":"Signature","text":"<pre><code>def diffusive_knudsen_number(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particledimensionless_coagulation","title":"Particle().dimensionless_coagulation","text":"<p>Show source in particle.py:459</p> <p>Dimensionless particle--particle coagulation kernel.</p>"},{"location":"Source-Code/particula/particle/#signature_7","title":"Signature","text":"<pre><code>def dimensionless_coagulation(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlereduced_friction_factor","title":"Particle().reduced_friction_factor","text":"<p>Show source in particle.py:432</p> <p>Returns the reduced friction factor between two particles.</p>"},{"location":"Source-Code/particula/particle/#signature_8","title":"Signature","text":"<pre><code>def reduced_friction_factor(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlereduced_mass","title":"Particle().reduced_mass","text":"<p>Show source in particle.py:427</p> <p>Returns the reduced mass.</p>"},{"location":"Source-Code/particula/particle/#signature_9","title":"Signature","text":"<pre><code>def reduced_mass(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlecondensation","title":"ParticleCondensation","text":"<p>Show source in particle.py:255</p> <p>calculate some condensation stuff</p>"},{"location":"Source-Code/particula/particle/#signature_10","title":"Signature","text":"<pre><code>class ParticleCondensation(ParticleInstances):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#see-also_1","title":"See also","text":"<ul> <li>ParticleInstances</li> </ul>"},{"location":"Source-Code/particula/particle/#particlecondensationcondensation_redmass","title":"ParticleCondensation().condensation_redmass","text":"<p>Show source in particle.py:280</p> <p>red mass</p>"},{"location":"Source-Code/particula/particle/#signature_11","title":"Signature","text":"<pre><code>def condensation_redmass(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlecondensationfuchs_sutugin","title":"ParticleCondensation().fuchs_sutugin","text":"<p>Show source in particle.py:298</p> <p>the fuchs-sutugin correction</p>"},{"location":"Source-Code/particula/particle/#signature_12","title":"Signature","text":"<pre><code>def fuchs_sutugin(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlecondensationmolecular_enhancement","title":"ParticleCondensation().molecular_enhancement","text":"<p>Show source in particle.py:272</p> <p>molecular enhancement</p>"},{"location":"Source-Code/particula/particle/#signature_13","title":"Signature","text":"<pre><code>def molecular_enhancement(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlecondensationparticle_growth","title":"ParticleCondensation().particle_growth","text":"<p>Show source in particle.py:317</p> <p>particle growth in m/s</p>"},{"location":"Source-Code/particula/particle/#signature_14","title":"Signature","text":"<pre><code>def particle_growth(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlecondensationparticle_saturation_ratio","title":"ParticleCondensation().particle_saturation_ratio","text":"<p>Show source in particle.py:331</p> <p>Calculates the saturation ratio of the particle at its surface, accounting for the Kelvin effect.</p>"},{"location":"Source-Code/particula/particle/#returns","title":"Returns","text":"<p>float     The saturation ratio of the particle at its surface.</p>"},{"location":"Source-Code/particula/particle/#signature_15","title":"Signature","text":"<pre><code>def particle_saturation_ratio(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlecondensationvapor_flux","title":"ParticleCondensation().vapor_flux","text":"<p>Show source in particle.py:305</p> <p>vapor flux</p>"},{"location":"Source-Code/particula/particle/#signature_16","title":"Signature","text":"<pre><code>def vapor_flux(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlecondensationvapor_speed","title":"ParticleCondensation().vapor_speed","text":"<p>Show source in particle.py:289</p> <p>vapor speed</p>"},{"location":"Source-Code/particula/particle/#signature_17","title":"Signature","text":"<pre><code>def vapor_speed(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particledistribution","title":"ParticleDistribution","text":"<p>Show source in particle.py:34</p> <p>starting a particle distribution from continuous pdf</p>"},{"location":"Source-Code/particula/particle/#signature_18","title":"Signature","text":"<pre><code>class ParticleDistribution(Vapor):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#see-also_2","title":"See also","text":"<ul> <li>Vapor</li> </ul>"},{"location":"Source-Code/particula/particle/#particledistributionpre_discretize","title":"ParticleDistribution().pre_discretize","text":"<p>Show source in particle.py:106</p> <p>Returns a distribution pdf of the particles</p> <p>Utilizing the utility discretize to get make a lognorm distribution via scipy.stats.lognorm.pdf:     interval: the size interval of the distribution     gsigma  : geometric standard deviation of distribution     mode    : geometric mean radius of the particles</p>"},{"location":"Source-Code/particula/particle/#signature_19","title":"Signature","text":"<pre><code>def pre_discretize(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particledistributionpre_distribution","title":"ParticleDistribution().pre_distribution","text":"<p>Show source in particle.py:124</p> <p>Returns a distribution pdf of the particles</p> <p>Utilizing the utility discretize to get make a lognorm distribution via scipy.stats.lognorm.pdf:     interval: the size interval of the distribution     gsigma  : geometric standard deviation of distribution     mode    : geometric mean radius of the particles</p>"},{"location":"Source-Code/particula/particle/#signature_20","title":"Signature","text":"<pre><code>def pre_distribution(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particledistributionpre_radius","title":"ParticleDistribution().pre_radius","text":"<p>Show source in particle.py:60</p> <p>Returns the radius space of the particles</p> <p>Utilizing the utility cut_rad to get 99.99% of the distribution. From this interval, radius is made on a linspace with nbins points. Note: linspace is used here to practical purposes --- often, the logspace treatment will return errors in the discretization due to the asymmetry across the interval (finer resolution for smaller particles, but much coarser resolution for larger particles).</p>"},{"location":"Source-Code/particula/particle/#signature_21","title":"Signature","text":"<pre><code>def pre_radius(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particleinstances","title":"ParticleInstances","text":"<p>Show source in particle.py:137</p> <p>starting a particle distribution from single particles</p>"},{"location":"Source-Code/particula/particle/#signature_22","title":"Signature","text":"<pre><code>class ParticleInstances(ParticleDistribution):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#see-also_3","title":"See also","text":"<ul> <li>ParticleDistribution</li> </ul>"},{"location":"Source-Code/particula/particle/#particleinstancesaerodynamic_mobility","title":"ParticleInstances().aerodynamic_mobility","text":"<p>Show source in particle.py:237</p> <p>Returns a particle's aerodynamic mobility.</p>"},{"location":"Source-Code/particula/particle/#signature_23","title":"Signature","text":"<pre><code>def aerodynamic_mobility(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particleinstancesdiffusion_coefficient","title":"ParticleInstances().diffusion_coefficient","text":"<p>Show source in particle.py:246</p> <p>Returns a particle's diffusion coefficient.</p>"},{"location":"Source-Code/particula/particle/#signature_24","title":"Signature","text":"<pre><code>def diffusion_coefficient(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particleinstancesfriction_factor","title":"ParticleInstances().friction_factor","text":"<p>Show source in particle.py:218</p> <p>Returns a particle's friction factor.</p>"},{"location":"Source-Code/particula/particle/#signature_25","title":"Signature","text":"<pre><code>def friction_factor(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particleinstancesknudsen_number","title":"ParticleInstances().knudsen_number","text":"<p>Show source in particle.py:202</p> <p>Returns particle's Knudsen number.</p>"},{"location":"Source-Code/particula/particle/#signature_26","title":"Signature","text":"<pre><code>def knudsen_number(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particleinstancesparticle_area","title":"ParticleInstances().particle_area","text":"<p>Show source in particle.py:194</p> <p>Returns particle's surface area</p>"},{"location":"Source-Code/particula/particle/#signature_27","title":"Signature","text":"<pre><code>def particle_area(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particleinstancesparticle_distribution","title":"ParticleInstances().particle_distribution","text":"<p>Show source in particle.py:175</p> <p>distribution</p>"},{"location":"Source-Code/particula/particle/#signature_28","title":"Signature","text":"<pre><code>def particle_distribution(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particleinstancesparticle_mass","title":"ParticleInstances().particle_mass","text":"<p>Show source in particle.py:184</p> <p>Returns mass of particle.</p>"},{"location":"Source-Code/particula/particle/#signature_29","title":"Signature","text":"<pre><code>def particle_mass(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particleinstancessettling_velocity","title":"ParticleInstances().settling_velocity","text":"<p>Show source in particle.py:227</p> <p>Returns a particle's settling velocity.</p>"},{"location":"Source-Code/particula/particle/#signature_30","title":"Signature","text":"<pre><code>def settling_velocity(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particleinstancesslip_correction_factor","title":"ParticleInstances().slip_correction_factor","text":"<p>Show source in particle.py:210</p> <p>Returns particle's Cunningham slip correction factor.</p>"},{"location":"Source-Code/particula/particle/#signature_31","title":"Signature","text":"<pre><code>def slip_correction_factor(self): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#particlewallloss","title":"ParticleWallLoss","text":"<p>Show source in particle.py:354</p> <p>continuing...</p>"},{"location":"Source-Code/particula/particle/#signature_32","title":"Signature","text":"<pre><code>class ParticleWallLoss(ParticleCondensation):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/particle/#see-also_4","title":"See also","text":"<ul> <li>ParticleCondensation</li> </ul>"},{"location":"Source-Code/particula/particle/#particlewalllosswall_loss_coefficient","title":"ParticleWallLoss().wall_loss_coefficient","text":"<p>Show source in particle.py:374</p> <p>Returns a particle's wall loss coefficient.</p>"},{"location":"Source-Code/particula/particle/#signature_33","title":"Signature","text":"<pre><code>def wall_loss_coefficient(self): ...\n</code></pre>"},{"location":"Source-Code/particula/rates/","title":"Rates","text":"<p>Particula Index / Particula / Rates</p> <p>Auto-generated documentation for particula.rates module.</p>"},{"location":"Source-Code/particula/rates/#rates_1","title":"Rates","text":"<p>Show source in rates.py:12</p> <p>The class to calculate the rates</p>"},{"location":"Source-Code/particula/rates/#signature","title":"Signature","text":"<pre><code>class Rates:\n    def __init__(self, particle=None, lazy=True): ...\n</code></pre>"},{"location":"Source-Code/particula/rates/#rates_coag_loss_gain","title":"Rates()._coag_loss_gain","text":"<p>Show source in rates.py:42</p> <p>get both loss and gain</p>"},{"location":"Source-Code/particula/rates/#signature_1","title":"Signature","text":"<pre><code>def _coag_loss_gain(self): ...\n</code></pre>"},{"location":"Source-Code/particula/rates/#ratescoagulation_gain","title":"Rates().coagulation_gain","text":"<p>Show source in rates.py:57</p> <p>get coagulation gain rate</p>"},{"location":"Source-Code/particula/rates/#signature_2","title":"Signature","text":"<pre><code>def coagulation_gain(self): ...\n</code></pre>"},{"location":"Source-Code/particula/rates/#ratescoagulation_loss","title":"Rates().coagulation_loss","text":"<p>Show source in rates.py:51</p> <p>get the coagulation loss rate</p>"},{"location":"Source-Code/particula/rates/#signature_3","title":"Signature","text":"<pre><code>def coagulation_loss(self): ...\n</code></pre>"},{"location":"Source-Code/particula/rates/#ratescoagulation_rate","title":"Rates().coagulation_rate","text":"<p>Show source in rates.py:63</p> <p>get the coagulation rate by summing the loss and gain rates</p>"},{"location":"Source-Code/particula/rates/#signature_4","title":"Signature","text":"<pre><code>def coagulation_rate(self): ...\n</code></pre>"},{"location":"Source-Code/particula/rates/#ratescondensation_growth_rate","title":"Rates().condensation_growth_rate","text":"<p>Show source in rates.py:75</p> <p>condensation rate</p>"},{"location":"Source-Code/particula/rates/#signature_5","title":"Signature","text":"<pre><code>def condensation_growth_rate(self): ...\n</code></pre>"},{"location":"Source-Code/particula/rates/#ratescondensation_growth_speed","title":"Rates().condensation_growth_speed","text":"<p>Show source in rates.py:69</p> <p>condensation speed</p>"},{"location":"Source-Code/particula/rates/#signature_6","title":"Signature","text":"<pre><code>def condensation_growth_speed(self): ...\n</code></pre>"},{"location":"Source-Code/particula/rates/#ratesdilution_rate","title":"Rates().dilution_rate","text":"<p>Show source in rates.py:95</p> <p>dilution rate</p>"},{"location":"Source-Code/particula/rates/#signature_7","title":"Signature","text":"<pre><code>def dilution_rate(self): ...\n</code></pre>"},{"location":"Source-Code/particula/rates/#ratesnucleation_rate","title":"Rates().nucleation_rate","text":"<p>Show source in rates.py:86</p> <p>nucleation rate</p>"},{"location":"Source-Code/particula/rates/#signature_8","title":"Signature","text":"<pre><code>def nucleation_rate(self): ...\n</code></pre>"},{"location":"Source-Code/particula/rates/#ratessum_rates","title":"Rates().sum_rates","text":"<p>Show source in rates.py:111</p> <p>Sum rates, with options to disable individual rate terms.</p>"},{"location":"Source-Code/particula/rates/#arguments","title":"Arguments","text":"<p>coagulation : bool, optional     does the coagulation calcuation, by default True condensation : bool, optional     does the condensation calculation, by default True nucleation : bool, optional     does the nucleation calculation, by default True dilution : bool, optional     does the dilution calculation, by default False wall_loss : bool, optional     does the wall loss calculation, by default False</p>"},{"location":"Source-Code/particula/rates/#signature_9","title":"Signature","text":"<pre><code>def sum_rates(\n    self,\n    coagulation=True,\n    condensation=True,\n    nucleation=True,\n    dilution=False,\n    wall_loss=False,\n): ...\n</code></pre>"},{"location":"Source-Code/particula/rates/#rateswall_loss_rate","title":"Rates().wall_loss_rate","text":"<p>Show source in rates.py:103</p> <p>wall loss rate</p>"},{"location":"Source-Code/particula/rates/#signature_10","title":"Signature","text":"<pre><code>def wall_loss_rate(self): ...\n</code></pre>"},{"location":"Source-Code/particula/vapor/","title":"Vapor","text":"<p>Particula Index / Particula / Vapor</p> <p>Auto-generated documentation for particula.vapor module.</p>"},{"location":"Source-Code/particula/vapor/#vapor_1","title":"Vapor","text":"<p>Show source in vapor.py:13</p> <p>based on the Environment class</p>"},{"location":"Source-Code/particula/vapor/#signature","title":"Signature","text":"<pre><code>class Vapor(Environment):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/vapor/#see-also","title":"See also","text":"<ul> <li>Environment</li> </ul>"},{"location":"Source-Code/particula/vapor/#vapordriving_force","title":"Vapor().driving_force","text":"<p>Show source in vapor.py:42</p> <p>condensation driving force</p>"},{"location":"Source-Code/particula/vapor/#signature_1","title":"Signature","text":"<pre><code>def driving_force(self, species=None, surface_saturation_ratio=1): ...\n</code></pre>"},{"location":"Source-Code/particula/activity/","title":"Activity","text":"<p>Particula Index / Particula / Activity</p> <p>Auto-generated documentation for particula.activity module.</p>"},{"location":"Source-Code/particula/activity/#modules","title":"Modules","text":"<ul> <li>Binary Activity</li> <li>Gibbs</li> <li>Phase Separation</li> <li>Ratio</li> <li>Species Density</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/","title":"Binary Activity","text":"<p>Particula Index / Particula / Activity / Binary Activity</p> <p>Auto-generated documentation for particula.activity.binary_activity module.</p>"},{"location":"Source-Code/particula/activity/binary_activity/#attributes","title":"Attributes","text":"<ul> <li> <p><code>FIT_LOW</code> - the fit values for the activity model: {'a1': [7.089476, -7.71186, -38.85941, -100.0], 'a2': [-0.6226781, -100.0, 3.081244e-09, 61.88812], 's': [-5.988895, 6.940689]}</p> </li> <li> <p><code>INTERPOLATE_WATER_FIT</code> - interpolation points, could be done smarter: 500</p> </li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#activity_coefficients","title":"activity_coefficients","text":"<p>Show source in binary_activity.py:34</p> <p>Calculate the activity coefficients for water and organic matter in organic-water mixtures.</p>"},{"location":"Source-Code/particula/activity/binary_activity/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - Ratio of the molecular weight of water to the     molecular weight of organic matter.</li> <li><code>-</code> organic_mole_fraction - Molar fraction of organic matter in the     mixture.</li> <li><code>-</code> oxygen2carbon - Oxygen to carbon ratio in the organic compound.</li> <li><code>-</code> density - Density of the mixture.</li> <li><code>-</code> functional_group - Optional functional group(s) of the organic     compound, if applicable.</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#returns","title":"Returns","text":"<p>A tuple containing the activity of water, activity of organic matter, mass fraction of water, and mass fraction of organic matter, gamma_water (activity coefficient), and gamma_organic (activity coefficient).</p>"},{"location":"Source-Code/particula/activity/binary_activity/#signature","title":"Signature","text":"<pre><code>def activity_coefficients(\n    molar_mass_ratio: ArrayLike,\n    organic_mole_fraction: ArrayLike,\n    oxygen2carbon: ArrayLike,\n    density: ArrayLike,\n    functional_group=None,\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/activity/binary_activity/#bat_blending_weights","title":"bat_blending_weights","text":"<p>Show source in binary_activity.py:335</p> <p>Function to estimate the blending weights for the BAT model.</p>"},{"location":"Source-Code/particula/activity/binary_activity/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - The molar mass ratio of water to organic     matter.</li> <li><code>-</code> oxygen2carbon - The oxygen to carbon ratio.</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#returns_1","title":"Returns","text":"<ul> <li>blending_weights : List of blending weights for the BAT model in the low, mid, and high oxygen2carbon regions.</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#signature_1","title":"Signature","text":"<pre><code>def bat_blending_weights(\n    molar_mass_ratio: ArrayLike, oxygen2carbon: ArrayLike\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/activity/binary_activity/#biphasic_water_activity_point","title":"biphasic_water_activity_point","text":"<p>Show source in binary_activity.py:240</p> <p>This function computes the biphasic to single phase water activity (RH*100).</p>"},{"location":"Source-Code/particula/activity/binary_activity/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> oxygen2carbon - The oxygen to carbon ratio.</li> <li><code>-</code> hydrogen2carbon - The hydrogen to carbon ratio.</li> <li><code>-</code> molar_mass_ratio - The molar mass ratio of water to organic     matter.</li> <li><code>-</code> functional_group - Optional functional group(s) of the organic     compound, if applicable.</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> np.array - The RH cross point array.</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#signature_2","title":"Signature","text":"<pre><code>def biphasic_water_activity_point(\n    oxygen2carbon: ArrayLike,\n    hydrogen2carbon: ArrayLike,\n    molar_mass_ratio: ArrayLike,\n    functional_group: Optional[Union[list[str], str]] = None,\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/activity/binary_activity/#coefficients_c","title":"coefficients_c","text":"<p>Show source in binary_activity.py:398</p> <p>Coefficients for activity model, see Gorkowski (2019). equation S1 S2.</p>"},{"location":"Source-Code/particula/activity/binary_activity/#arguments_3","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - The molar mass ratio of water to organic     matter.</li> <li><code>-</code> oxygen2carbon - The oxygen to carbon ratio.</li> <li><code>-</code> fit_values - The fit values for the activity model.</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#returns_3","title":"Returns","text":"<ul> <li><code>-</code> np.ndarray - The coefficients for the activity model.</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#signature_3","title":"Signature","text":"<pre><code>def coefficients_c(\n    molar_mass_ratio: ArrayLike, oxygen2carbon: ArrayLike, fit_values: ArrayLike\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/activity/binary_activity/#convert_to_oh_equivalent","title":"convert_to_oh_equivalent","text":"<p>Show source in binary_activity.py:314</p> <p>just a pass through now, but will add the oh equivalent conversion</p>"},{"location":"Source-Code/particula/activity/binary_activity/#signature_4","title":"Signature","text":"<pre><code>def convert_to_oh_equivalent(\n    oxygen2carbon: ArrayLike,\n    molar_mass_ratio: ArrayLike,\n    functional_group: Optional[Union[list[str], str]] = None,\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/activity/binary_activity/#fixed_water_activity","title":"fixed_water_activity","text":"<p>Show source in binary_activity.py:425</p> <p>Calculate the activity coefficients of water and organic matter in organic-water mixtures.</p> <p>This function assumes a fixed water activity value (e.g., RH = 75% corresponds to 0.75 water activity in equilibrium). It calculates the activity coefficients for different phases and determines phase separations if they occur.</p>"},{"location":"Source-Code/particula/activity/binary_activity/#arguments_4","title":"Arguments","text":"<ul> <li><code>water_activity</code> ArrayLike - An array of water activity values.</li> <li><code>molar_mass_ratio</code> ArrayLike - Array of molar mass ratios of the components.</li> <li><code>oxygen2carbon</code> ArrayLike - Array of oxygen-to-carbon ratios.</li> <li><code>density</code> ArrayLike - Array of densities of the mixture.</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#returns_4","title":"Returns","text":"<ul> <li><code>Tuple</code> - A tuple containing the activity coefficients for alpha and beta         phases, and the alpha phase mole fraction.        If no phase separation occurs, the beta phase values are None.</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#signature_5","title":"Signature","text":"<pre><code>def fixed_water_activity(\n    water_activity: ArrayLike,\n    molar_mass_ratio: ArrayLike,\n    oxygen2carbon: ArrayLike,\n    density: ArrayLike,\n) -&gt; Tuple: ...\n</code></pre>"},{"location":"Source-Code/particula/activity/binary_activity/#gibbs_mix_weight","title":"gibbs_mix_weight","text":"<p>Show source in binary_activity.py:158</p> <p>Gibbs free energy of mixing, see Gorkowski (2019), with weighted oxygen2carbon regions. Only can run one compound at a time.</p>"},{"location":"Source-Code/particula/activity/binary_activity/#arguments_5","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - The molar mass ratio of water to organic     matter.</li> <li><code>-</code> organic_mole_fraction - The fraction of organic matter.</li> <li><code>-</code> oxygen2carbon - The oxygen to carbon ratio.</li> <li><code>-</code> density - The density of the mixture.</li> <li><code>-</code> functional_group - Optional functional group(s) of the organic     compound, if applicable.</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#returns_5","title":"Returns","text":"<ul> <li>gibbs_mix : Gibbs energy of mixing (including 1/RT)</li> <li>derivative_gibbs : derivative of Gibbs energy with respect to</li> <li>mole fraction of organics (includes 1/RT)</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#signature_6","title":"Signature","text":"<pre><code>def gibbs_mix_weight(\n    molar_mass_ratio: ArrayLike,\n    organic_mole_fraction: ArrayLike,\n    oxygen2carbon: ArrayLike,\n    density: ArrayLike,\n    functional_group: Optional[str] = None,\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/activity/binary_activity/#gibbs_of_mixing","title":"gibbs_of_mixing","text":"<p>Show source in binary_activity.py:98</p> <p>Calculate the Gibbs free energy of mixing for a binary mixture.</p>"},{"location":"Source-Code/particula/activity/binary_activity/#arguments_6","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - The molar mass ratio of water to organic     matter.</li> <li><code>-</code> organic_mole_fraction - The fraction of organic matter.</li> <li><code>-</code> oxygen2carbon - The oxygen to carbon ratio.</li> <li><code>-</code> density - The density of the mixture.</li> <li><code>-</code> fit_dict - A dictionary of fit values for the low oxygen2carbon region</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#returns_6","title":"Returns","text":"<ul> <li><code>Tuple[np.ndarray,</code> np.ndarray] - A tuple containing the Gibbs free energy of mixing and its derivative.</li> </ul>"},{"location":"Source-Code/particula/activity/binary_activity/#signature_7","title":"Signature","text":"<pre><code>def gibbs_of_mixing(\n    molar_mass_ratio: ArrayLike,\n    organic_mole_fraction: ArrayLike,\n    oxygen2carbon: ArrayLike,\n    density: ArrayLike,\n    fit_dict: dict,\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/activity/gibbs/","title":"Gibbs","text":"<p>Particula Index / Particula / Activity / Gibbs</p> <p>Auto-generated documentation for particula.activity.gibbs module.</p>"},{"location":"Source-Code/particula/activity/gibbs/#gibbs_free_engery","title":"gibbs_free_engery","text":"<p>Show source in gibbs.py:6</p> <p>Calculate the gibbs free energy of the mixture. Ideal and non-ideal.</p>"},{"location":"Source-Code/particula/activity/gibbs/#arguments","title":"Arguments","text":"<ul> <li><code>organic_mole_fraction</code> np.array - A numpy array of organic mole fractions.</li> <li><code>gibbs_mix</code> np.array - A numpy array of gibbs free energy of mixing.</li> </ul>"},{"location":"Source-Code/particula/activity/gibbs/#returns","title":"Returns","text":"<ul> <li><code>gibbs_ideal</code> np.array - The ideal gibbs free energy of mixing.</li> <li><code>gibbs_real</code> np.array - The real gibbs free energy of mixing.</li> </ul>"},{"location":"Source-Code/particula/activity/gibbs/#signature","title":"Signature","text":"<pre><code>def gibbs_free_engery(organic_mole_fraction, gibbs_mix): ...\n</code></pre>"},{"location":"Source-Code/particula/activity/phase_separation/","title":"Phase Separation","text":"<p>Particula Index / Particula / Activity / Phase Separation</p> <p>Auto-generated documentation for particula.activity.phase_separation module.</p>"},{"location":"Source-Code/particula/activity/phase_separation/#find_phase_sep_index","title":"find_phase_sep_index","text":"<p>Show source in phase_separation.py:55</p> <p>This function finds phase separation using activity&gt;1 and inflections in the activity curve data. In physical systems activity can not be above one and curve should be monotonic. Or else there will be phase separation.</p>"},{"location":"Source-Code/particula/activity/phase_separation/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> activity_data - A array of activity data.</li> </ul>"},{"location":"Source-Code/particula/activity/phase_separation/#returns","title":"Returns","text":"<ul> <li><code>dict</code> - A dictionary containing the following keys:<ul> <li><code>-</code> 'phase_sep_activity' - Phase separation via activity     (1 if there is phase separation, 0 otherwise)</li> <li><code>-</code> 'phase_sep_curve' - Phase separation via activity curvature     (1 if there is phase separation, 0 otherwise)</li> <li><code>-</code> 'index_phase_sep_starts' - Index where phase separation starts</li> <li><code>-</code> 'index_phase_sep_end' - Index where phase separation ends</li> </ul> </li> </ul>"},{"location":"Source-Code/particula/activity/phase_separation/#signature","title":"Signature","text":"<pre><code>def find_phase_sep_index(activity_data: ArrayLike) -&gt; dict: ...\n</code></pre>"},{"location":"Source-Code/particula/activity/phase_separation/#find_phase_separation","title":"find_phase_separation","text":"<p>Show source in phase_separation.py:137</p> <p>This function checks for phase separation in each activity curve.</p>"},{"location":"Source-Code/particula/activity/phase_separation/#arguments_1","title":"Arguments","text":"<ul> <li>activity_water (np.array): A numpy array of water activity values.</li> <li>activity_org (np.array): A numpy array of organic activity values.</li> </ul>"},{"location":"Source-Code/particula/activity/phase_separation/#returns_1","title":"Returns","text":"<ul> <li><code>dict</code> - A dictionary containing the following keys:<ul> <li><code>-</code> 'phase_sep_check' - An integer indicating whether phase separation         is present (1) or not (0).</li> <li><code>-</code> 'lower_seperation_index' - The index of the lower separation point         in the activity curve.</li> <li><code>-</code> 'upper_seperation_index' - The index of the upper separation point in         the activity curve.</li> <li><code>-</code> 'matching_upper_seperation_index' - The index where the difference         between activity_water_beta and match_a_w is greater than 0.</li> <li><code>-</code> 'lower_seperation' - The value of water activity at the lower         separation point.</li> <li><code>-</code> 'upper_seperation' - The value of water activity at the upper         separation point.</li> <li><code>-</code> 'matching_upper_seperation' - The value of water activity at the         matching upper separation point.</li> </ul> </li> </ul>"},{"location":"Source-Code/particula/activity/phase_separation/#signature_1","title":"Signature","text":"<pre><code>def find_phase_separation(\n    activity_water: ArrayLike, activity_org: ArrayLike\n) -&gt; dict: ...\n</code></pre>"},{"location":"Source-Code/particula/activity/phase_separation/#organic_water_single_phase","title":"organic_water_single_phase","text":"<p>Show source in phase_separation.py:23</p> <p>Convert the given molar mass ratio (MW water / MW organic) to a and oxygen2carbon value were above is a single phase with water and below phase separation is possible.</p>"},{"location":"Source-Code/particula/activity/phase_separation/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - The molar mass ratio with respect to water.</li> </ul>"},{"location":"Source-Code/particula/activity/phase_separation/#returns_2","title":"Returns","text":"<ul> <li>The single phase cross point.</li> </ul>"},{"location":"Source-Code/particula/activity/phase_separation/#references","title":"References","text":"<ul> <li>Gorkowski, K., Preston, T. C., &amp; Zuend, A. (2019).   Relative-humidity-dependent organic aerosol thermodynamics   Via an efficient reduced-complexity model.   Atmospheric Chemistry and Physics   https://doi.org/10.5194/acp-19-13383-2019</li> </ul>"},{"location":"Source-Code/particula/activity/phase_separation/#signature_2","title":"Signature","text":"<pre><code>def organic_water_single_phase(\n    molar_mass_ratio: Union[int, float, list, np.ndarray],\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/activity/phase_separation/#q_alpha","title":"q_alpha","text":"<p>Show source in phase_separation.py:233</p> <p>This function calculates the q_alpha value using a squeezed logistic     function.</p>"},{"location":"Source-Code/particula/activity/phase_separation/#arguments_3","title":"Arguments","text":"<ul> <li>seperation_activity (np.array): A numpy array of values representing     the separation activity.</li> <li>activities (np.array): A numpy array of activity values.</li> </ul>"},{"location":"Source-Code/particula/activity/phase_separation/#returns_3","title":"Returns","text":"<ul> <li><code>np.array</code> - The q_alpha value.</li> </ul>"},{"location":"Source-Code/particula/activity/phase_separation/#notes","title":"Notes","text":"<ul> <li>The q_alpha value represents the transfer from     q_alpha ~0 to q_alpha ~1.</li> <li>The function uses a sigmoid curve parameter to calculate the     q_alpha value.</li> </ul>"},{"location":"Source-Code/particula/activity/phase_separation/#signature_3","title":"Signature","text":"<pre><code>def q_alpha(\n    seperation_activity: Union[int, float, np.ndarray], activities: ArrayLike\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/activity/ratio/","title":"Ratio","text":"<p>Particula Index / Particula / Activity / Ratio</p> <p>Auto-generated documentation for particula.activity.ratio module.</p>"},{"location":"Source-Code/particula/activity/ratio/#from_molar_mass_ratio","title":"from_molar_mass_ratio","text":"<p>Show source in ratio.py:22</p> <p>Convert the given molar mass ratio (MW water / MW organic) to a molar mass with respect to the other compound.</p>"},{"location":"Source-Code/particula/activity/ratio/#arguments","title":"Arguments","text":"<ul> <li><code>molar_mass_ratio</code> np.array - The molar mass ratio with respect to water.</li> <li><code>other_molar_mass</code> float, optional - The molar mass of the other compound.     Defaults to 18.01528.</li> </ul>"},{"location":"Source-Code/particula/activity/ratio/#returns","title":"Returns","text":"<ul> <li><code>np.array</code> - The molar mass of the organic compound.</li> </ul>"},{"location":"Source-Code/particula/activity/ratio/#signature","title":"Signature","text":"<pre><code>def from_molar_mass_ratio(molar_mass_ratio, other_molar_mass=18.01528): ...\n</code></pre>"},{"location":"Source-Code/particula/activity/ratio/#to_molar_mass_ratio","title":"to_molar_mass_ratio","text":"<p>Show source in ratio.py:4</p> <p>Convert the given molar mass to a molar mass ratio with respect to water. (MW water / MW organic)</p>"},{"location":"Source-Code/particula/activity/ratio/#arguments_1","title":"Arguments","text":"<ul> <li><code>molar_mass</code> np.array - The molar mass of the organic compound.</li> <li><code>other_molar_mass</code> float, optional - The molar mass of the other compound.     Defaults to 18.01528.</li> </ul>"},{"location":"Source-Code/particula/activity/ratio/#returns_1","title":"Returns","text":"<ul> <li><code>np.array</code> - The molar mass ratio with respect to water.</li> </ul>"},{"location":"Source-Code/particula/activity/ratio/#signature_1","title":"Signature","text":"<pre><code>def to_molar_mass_ratio(molar_mass, other_molar_mass=18.01528): ...\n</code></pre>"},{"location":"Source-Code/particula/activity/species_density/","title":"Species Density","text":"<p>Particula Index / Particula / Activity / Species Density</p> <p>Auto-generated documentation for particula.activity.species_density module.</p>"},{"location":"Source-Code/particula/activity/species_density/#organic_array","title":"organic_array","text":"<p>Show source in species_density.py:85</p> <p>Get densities for an array.</p>"},{"location":"Source-Code/particula/activity/species_density/#signature","title":"Signature","text":"<pre><code>def organic_array(\n    molar_mass,\n    oxygen2carbon,\n    hydrogen2carbon=None,\n    nitrogen2carbon=None,\n    mass_ratio_convert=False,\n): ...\n</code></pre>"},{"location":"Source-Code/particula/activity/species_density/#organic_density_estimate","title":"organic_density_estimate","text":"<p>Show source in species_density.py:12</p> <p>Function to estimate the density of organic compounds based on the simple model by Girolami (1994). The input parameters include molar mass, O:C and H:C ratios. If the H:C ratio is unknown at input, enter a negative value. The actual H:C will then be estimated based on an initial assumption of H:C = 2. The model also estimates the number of carbon atoms per molecular structure based on molar mass, O:C, and H:C. The density is then approximated by the formula of Girolami.</p> <p>Reference: Girolami, G. S.: A Simple 'Back of the Envelope' Method for Estimating the Densities and Molecular Volumes of Liquids and Solids, J. Chem. Educ., 71(11), 962, doi:10.1021/ed071p962, 1994.</p>"},{"location":"Source-Code/particula/activity/species_density/#arguments","title":"Arguments","text":"<ul> <li><code>molar_mass(float)</code> - Molar mass.</li> <li><code>oxygen2carbon</code> float - O:C ratio.</li> <li><code>hydrogen2carbon</code> float - H:C ratio. If unknown, provide a negative     value.</li> <li><code>nitrogen2carbon</code> float, optional - N:C ratio. Defaults to None.</li> </ul>"},{"location":"Source-Code/particula/activity/species_density/#returns","title":"Returns","text":"<ul> <li><code>densityEst</code> float - Estimated density in g/cm^3.</li> </ul>"},{"location":"Source-Code/particula/activity/species_density/#signature_1","title":"Signature","text":"<pre><code>def organic_density_estimate(\n    molar_mass,\n    oxygen2carbon,\n    hydrogen2carbon=None,\n    nitrogen2carbon=None,\n    mass_ratio_convert=False,\n): ...\n</code></pre>"},{"location":"Source-Code/particula/data/","title":"Data","text":"<p>Particula Index / Particula / Data</p> <p>Auto-generated documentation for particula.data module.</p>"},{"location":"Source-Code/particula/data/#modules","title":"Modules","text":"<ul> <li>Lake</li> <li>Lake Stats</li> <li>Loader</li> <li>Loader Interface</li> <li>Merger</li> <li>Process</li> <li>Settings Generator</li> <li>Stream</li> <li>Stream Stats</li> </ul>"},{"location":"Source-Code/particula/data/lake/","title":"Lake","text":"<p>Particula Index / Particula / Data / Lake</p> <p>Auto-generated documentation for particula.data.lake module.</p>"},{"location":"Source-Code/particula/data/lake/#lake_1","title":"Lake","text":"<p>Show source in lake.py:10</p> <p>A class representing a lake which is a collection of streams.</p>"},{"location":"Source-Code/particula/data/lake/#attributes","title":"Attributes","text":"<p>streams (Dict[str, Stream]): A dictionary to hold streams with their names as keys.</p>"},{"location":"Source-Code/particula/data/lake/#signature","title":"Signature","text":"<pre><code>class Lake: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#lakedelitem","title":"Lake().delitem","text":"<p>Show source in lake.py:91</p> <p>Remove a stream by name. Example: del lake['stream_name']</p>"},{"location":"Source-Code/particula/data/lake/#signature_1","title":"Signature","text":"<pre><code>def __delitem__(self, key: str) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#lakedir","title":"Lake().dir","text":"<p>Show source in lake.py:50</p> <p>List available streams. Example: dir(lake)</p>"},{"location":"Source-Code/particula/data/lake/#signature_2","title":"Signature","text":"<pre><code>def __dir__(self) -&gt; list: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#lakegetattr","title":"Lake().getattr","text":"<p>Show source in lake.py:39</p> <p>Allow accessing streams as an attributes.</p>"},{"location":"Source-Code/particula/data/lake/#raises","title":"Raises","text":"<pre><code>- `AttributeError` - If the stream name is not in the lake.\n</code></pre> <ul> <li><code>Example</code> - lake.stream_name</li> </ul>"},{"location":"Source-Code/particula/data/lake/#signature_3","title":"Signature","text":"<pre><code>def __getattr__(self, name: str) -&gt; Any: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#lakegetitem","title":"Lake().getitem","text":"<p>Show source in lake.py:78</p> <p>Get a stream by name. Example: lake['stream_name']</p>"},{"location":"Source-Code/particula/data/lake/#signature_4","title":"Signature","text":"<pre><code>def __getitem__(self, key: str) -&gt; Any: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#lakeiter","title":"Lake().iter","text":"<p>Show source in lake.py:55</p> <p>Iterate over the streams in the lake. Example: [stream.header for stream in lake]\"\"</p>"},{"location":"Source-Code/particula/data/lake/#signature_5","title":"Signature","text":"<pre><code>def __iter__(self) -&gt; Iterator[Any]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#lakelen","title":"Lake().len","text":"<p>Show source in lake.py:73</p> <p>Return the number of streams in the lake. Example: len(lake)</p>"},{"location":"Source-Code/particula/data/lake/#signature_6","title":"Signature","text":"<pre><code>def __len__(self) -&gt; int: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#lakerepr","title":"Lake().repr","text":"<p>Show source in lake.py:99</p> <p>Return a string representation of the lake. Example: print(lake)</p>"},{"location":"Source-Code/particula/data/lake/#signature_7","title":"Signature","text":"<pre><code>def __repr__(self) -&gt; str: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#lakesetitem","title":"Lake().setitem","text":"<p>Show source in lake.py:83</p> <p>Set a stream by name. Example: lake['stream_name'] = new_stream</p>"},{"location":"Source-Code/particula/data/lake/#signature_8","title":"Signature","text":"<pre><code>def __setitem__(self, key: str, value: Stream) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#see-also","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/lake/#lakeadd_stream","title":"Lake().add_stream","text":"<p>Show source in lake.py:19</p> <p>Add a stream to the lake.</p>"},{"location":"Source-Code/particula/data/lake/#arguments","title":"Arguments","text":"<pre><code>- `stream` *Stream* - The stream object to be added.\n- `name` *str* - The name of the stream.\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#raises_1","title":"Raises","text":"<pre><code>- `ValueError` - If the stream name is already in use or not a valid\nidentifier.\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#signature_9","title":"Signature","text":"<pre><code>def add_stream(self, stream: Stream, name: str) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#see-also_1","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/lake/#lakeitems","title":"Lake().items","text":"<p>Show source in lake.py:61</p> <p>Return an iterator over the key-value pairs.</p>"},{"location":"Source-Code/particula/data/lake/#signature_10","title":"Signature","text":"<pre><code>def items(self) -&gt; Iterator[Tuple[Any, Any]]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#lakekeys","title":"Lake().keys","text":"<p>Show source in lake.py:69</p> <p>Return an iterator over the keys.</p>"},{"location":"Source-Code/particula/data/lake/#signature_11","title":"Signature","text":"<pre><code>def keys(self) -&gt; Iterator[Any]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#lakesummary","title":"Lake().summary","text":"<p>Show source in lake.py:104</p> <pre><code>Return a string summary iterating over each stream\nand print Stream.header.\n</code></pre> <p>Example: lake.summary</p>"},{"location":"Source-Code/particula/data/lake/#signature_12","title":"Signature","text":"<pre><code>@property\ndef summary(self) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake/#lakevalues","title":"Lake().values","text":"<p>Show source in lake.py:65</p> <p>Return an iterator over the values.</p>"},{"location":"Source-Code/particula/data/lake/#signature_13","title":"Signature","text":"<pre><code>def values(self) -&gt; Iterator[Any]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake_stats/","title":"Lake Stats","text":"<p>Particula Index / Particula / Data / Lake Stats</p> <p>Auto-generated documentation for particula.data.lake_stats module.</p>"},{"location":"Source-Code/particula/data/lake_stats/#average_std","title":"average_std","text":"<p>Show source in lake_stats.py:10</p> <p>\" Averages the data in a lake over a specified time interval.</p>"},{"location":"Source-Code/particula/data/lake_stats/#signature","title":"Signature","text":"<pre><code>def average_std(\n    lake: Lake,\n    average_interval: Union[float, int] = 60,\n    new_time_array: Optional[np.ndarray] = None,\n    clone: bool = True,\n) -&gt; Lake: ...\n</code></pre>"},{"location":"Source-Code/particula/data/lake_stats/#see-also","title":"See also","text":"<ul> <li>Lake</li> </ul>"},{"location":"Source-Code/particula/data/loader/","title":"Loader","text":"<p>Particula Index / Particula / Data / Loader</p> <p>Auto-generated documentation for particula.data.loader module.</p>"},{"location":"Source-Code/particula/data/loader/#data_format_checks","title":"data_format_checks","text":"<p>Show source in loader.py:94</p> <p>Check if the data is in the correct format.</p>"},{"location":"Source-Code/particula/data/loader/#arguments","title":"Arguments","text":"<ul> <li><code>data</code> List[str] - A list of strings containing the raw data.</li> <li><code>data_checks</code> dict - Dictionary containing the format checks.</li> </ul>"},{"location":"Source-Code/particula/data/loader/#returns","title":"Returns","text":"<ul> <li><code>List[str]</code> - A list of strings containing the formatted data.</li> </ul>"},{"location":"Source-Code/particula/data/loader/#raises","title":"Raises","text":"<ul> <li><code>TypeError</code> - If data is not a list.</li> </ul>"},{"location":"Source-Code/particula/data/loader/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; data = ['row 1', 'row 2', 'row 3']\n&gt;&gt;&gt; data_checks = {\n...     \"characters\": [0, 10],\n...     \"char_counts\": {\",\": 2, \"/\": 0, \":\": 0},\n...     \"skip_rows\": 0,\n...     \"skip_end\": 0\n... }\n&gt;&gt;&gt; formatted_data = data_format_checks(data, data_checks)\n&gt;&gt;&gt; print(formatted_data)\n['row 2']\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#signature","title":"Signature","text":"<pre><code>def data_format_checks(data: List[str], data_checks: dict) -&gt; List[str]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#data_raw_loader","title":"data_raw_loader","text":"<p>Show source in loader.py:21</p> <p>Load raw data from a file at the specified file path and return it as a list of strings.</p>"},{"location":"Source-Code/particula/data/loader/#arguments_1","title":"Arguments","text":"<ul> <li><code>file_path</code> str - The file path of the file to read.</li> </ul>"},{"location":"Source-Code/particula/data/loader/#returns_1","title":"Returns","text":"<ul> <li><code>list</code> - The raw data read from the file as a list of strings.</li> </ul>"},{"location":"Source-Code/particula/data/loader/#examples_1","title":"Examples","text":"<pre><code>&gt;&gt;&gt; data = data_raw_loader('my_file.txt')\nLoading data from: my_file.txt\n&gt;&gt;&gt; print(data)\n['line 1', 'line 2', 'line 3']\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#signature_1","title":"Signature","text":"<pre><code>def data_raw_loader(file_path: str) -&gt; list: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#filter_list","title":"filter_list","text":"<p>Show source in loader.py:47</p> <p>A pass filter of rows from a list of strings. Each row must contain a specified number of characters to pass the filter. The number of characters to count is specified in the char_counts dictionary. The keys are the characters to count, and the values are the exact count required for each character in each row.</p>"},{"location":"Source-Code/particula/data/loader/#arguments_2","title":"Arguments","text":"<pre><code>- `data` *List[str]* - A list of strings to filter.\n    A list of strings to filter.\n- `char_counts` *dict* - A dictionary of character counts to select by.\n    The keys are the characters to count, and the values are the\n    count required for each character.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#returns_2","title":"Returns","text":"<pre><code>- `List[str]` - A new list of strings containing only the rows that meet the\ncharacter count requirements.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#raises_1","title":"Raises","text":"<pre><code>- `UserWarning` - If more than 90% of the rows are filtered out, and it\n    includes the character(s) used in the filter.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#examples_2","title":"Examples","text":"<pre><code>&gt;&gt;&gt; data = ['apple,banana,orange', 'pear,kiwi,plum',\n            'grapefruit,lemon']\n&gt;&gt;&gt; char_counts = {',': 2}\n&gt;&gt;&gt; filtered_data = filter_rows_by_count(data, char_counts)\n&gt;&gt;&gt; print(filtered_data)\n['apple,banana,orange', 'pear,kiwi,plum']\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#signature_2","title":"Signature","text":"<pre><code>def filter_list(data: List[str], char_counts: dict) -&gt; List[str]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#general_data_formatter","title":"general_data_formatter","text":"<p>Show source in loader.py:348</p> <p>Formats and samples the data to get the time and data streams.</p>"},{"location":"Source-Code/particula/data/loader/#arguments_3","title":"Arguments","text":"<p>data : list     The list of strings containing the data. data_checks : dict     A dictionary of data format checks to apply to the data. data_column : list     The list of indices of the columns containing the data. time_column : Union[int, List[int]]     The index or indices of the column(s) containing the time information. time_format : str     The format of the time information, e.g. '%Y-%m-%d %H:%M:%S'. delimiter : str, default=','     The delimiter used to separate columns in the data. date_offset : str, default=None     A fixed date offset to add to the timestamp in front. seconds_shift : int, default=0     A number of seconds to add to the timestamp.</p>"},{"location":"Source-Code/particula/data/loader/#returns_3","title":"Returns","text":"<p>Tuple[np.array, np.array]     A tuple containing two np.array objects: the first contains the     epoch times, and the second contains the data.</p>"},{"location":"Source-Code/particula/data/loader/#signature_3","title":"Signature","text":"<pre><code>def general_data_formatter(\n    data: list,\n    data_checks: dict,\n    data_column: list,\n    time_column: Union[int, List[int]],\n    time_format: str,\n    delimiter: str = \",\",\n    header_row: int = 0,\n    date_offset: Optional[str] = None,\n    seconds_shift: int = 0,\n    timezone_identifier: str = \"UTC\",\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#get_files_in_folder_with_size","title":"get_files_in_folder_with_size","text":"<p>Show source in loader.py:573</p> <p>Returns a list of files in the specified folder and subfolder that match the given filename pattern and have a size greater than the specified minimum size.</p>"},{"location":"Source-Code/particula/data/loader/#arguments_4","title":"Arguments","text":"<p>path : str     The path to the parent folder. subfolder : str     The name of the subfolder containing the files. filename_regex : str     A regular expression pattern for matching the filenames. min_size : int, optional     The minimum file size in bytes (default is 10).</p>"},{"location":"Source-Code/particula/data/loader/#returns_4","title":"Returns","text":"<p>Tuple[List[str], List[str], List[int]]     A tuple containing three lists:     - The filenames that match the pattern and size criteria     - The full paths to the files     - The file sizes in bytes</p>"},{"location":"Source-Code/particula/data/loader/#signature_4","title":"Signature","text":"<pre><code>def get_files_in_folder_with_size(\n    path: str, subfolder: str, filename_regex: str, min_size: int = 10\n) -&gt; Tuple[List[str], List[str], List[int]]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#keyword_to_index","title":"keyword_to_index","text":"<p>Show source in loader.py:414</p> <p>Convert a keyword indicating a position in the header to its index.</p> <p>This function takes a keyword which can be either an integer index or a string representing the column name. If the keyword is an integer, it's assumed to directly represent the index. If it's a string, the function searches for the keyword in the header list and returns its index.</p>"},{"location":"Source-Code/particula/data/loader/#arguments_5","title":"Arguments","text":"<p>keyword (Union[str, int]):     The keyword representing the column's position in the header.     It can be an integer index or a string for the column name. - <code>header</code> List[str] - The list of column names (header) of the data.</p>"},{"location":"Source-Code/particula/data/loader/#returns_5","title":"Returns","text":"<ul> <li><code>int</code> - The index of the column in the header.</li> </ul>"},{"location":"Source-Code/particula/data/loader/#raises_2","title":"Raises","text":"<p>ValueError:     If the keyword is a string and is not found in the header,     or if the keyword is an integer but out of range of the header.</p>"},{"location":"Source-Code/particula/data/loader/#signature_5","title":"Signature","text":"<pre><code>def keyword_to_index(keyword: Union[str, int], header: List[str]) -&gt; int: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#load_lake","title":"load_lake","text":"<p>Show source in loader.py:822</p> <p>Load datalake object from a pickle file.</p>"},{"location":"Source-Code/particula/data/loader/#args","title":"Args","text":"<p>path : str     Path to load pickle file.</p>"},{"location":"Source-Code/particula/data/loader/#returns_6","title":"Returns","text":"<p>data_lake : DataLake     Loaded DataLake object.</p>"},{"location":"Source-Code/particula/data/loader/#signature_6","title":"Signature","text":"<pre><code>def load_lake(path: str, sufix_name: Optional[str] = None) -&gt; Lake: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#see-also","title":"See also","text":"<ul> <li>Lake</li> </ul>"},{"location":"Source-Code/particula/data/loader/#load_stream","title":"load_stream","text":"<p>Show source in loader.py:736</p> <p>Load stream object from a pickle file.</p>"},{"location":"Source-Code/particula/data/loader/#args_1","title":"Args","text":"<p>path : str     Path to load pickle file. sufix_name : str, optional     Suffix to add to pickle file name. The default is None. folder : str, optional     Folder to load pickle file from. The default is 'output'.</p>"},{"location":"Source-Code/particula/data/loader/#returns_7","title":"Returns","text":"<p>Stream     Loaded Stream object.</p>"},{"location":"Source-Code/particula/data/loader/#signature_7","title":"Signature","text":"<pre><code>def load_stream(\n    path: str, sufix_name: Optional[str] = None, folder: Optional[str] = \"output\"\n) -&gt; Stream: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#see-also_1","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/loader/#netcdf_data_1d_load","title":"netcdf_data_1d_load","text":"<p>Show source in loader.py:882</p> <p>Given a netCDF file path and settings, returns a tuple containing the epoch time, header, and data as a numpy array. We do apply the mask to the data, and fill the masked values with nan.</p>"},{"location":"Source-Code/particula/data/loader/#arguments_6","title":"Arguments","text":"<pre><code>- `file_path` *str* - The path to the netCDF file.\n- `settings` *dict* - A dictionary containing settings for the instrument.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#returns_8","title":"Returns","text":"<pre><code>Tuple[np.ndarray, list, np.ndarray]: A tuple containing the epoch time,\nheader, and data as a numpy array.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#errors","title":"Errors:","text":"<pre><code>- `KeyError` - If the settings dictionary does not contain 'data_1d'.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#signature_8","title":"Signature","text":"<pre><code>def netcdf_data_1d_load(\n    file_path: str, settings: dict\n) -&gt; Tuple[np.ndarray, list, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#netcdf_data_2d_load","title":"netcdf_data_2d_load","text":"<p>Show source in loader.py:941</p> <p>Given a netCDF file path and settings, returns a tuple containing the epoch time, header, and data as a numpy array. We do apply the mask to the data, and fill the masked values with nan.</p>"},{"location":"Source-Code/particula/data/loader/#arguments_7","title":"Arguments","text":"<pre><code>- `file_path` *str* - The path to the netCDF file.\n- `settings` *dict* - A dictionary containing settings for the instrument.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#returns_9","title":"Returns","text":"<pre><code>Tuple[np.ndarray, list, np.ndarray]: A tuple containing the epoch time,\nheader, and data as a numpy array.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#errors_1","title":"Errors:","text":"<pre><code>- `KeyError` - If the settings dictionary does not contain 'data_2d'.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#signature_9","title":"Signature","text":"<pre><code>def netcdf_data_2d_load(\n    file_path: str, settings: dict\n) -&gt; Tuple[np.ndarray, list, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#netcdf_get_epoch_time","title":"netcdf_get_epoch_time","text":"<p>Show source in loader.py:851</p> <p>Given a netCDF file path and settings, returns an array of epoch times in seconds as a float.</p> <p>Currently only uses ARM 1.2 netCDF files (base_time + time_offset)</p>"},{"location":"Source-Code/particula/data/loader/#arguments_8","title":"Arguments","text":"<pre><code>- `file_path` *str* - The path to the netCDF file.\n- `settings` *dict* - A dictionary containing settings for the instrument.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#returns_10","title":"Returns","text":"<pre><code>- `np.ndarray` - An array of epoch times, in seconds as a float.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#signature_10","title":"Signature","text":"<pre><code>def netcdf_get_epoch_time(file_path: str, settings: dict) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#netcdf_info_print","title":"netcdf_info_print","text":"<p>Show source in loader.py:995</p> <p>Prints information about a netCDF file. Useful for generating settings dictionaries.</p>"},{"location":"Source-Code/particula/data/loader/#arguments_9","title":"Arguments","text":"<pre><code>- `file_path` *str* - The path to the netCDF file.\n- `file_return` *bool* - If True, returns the netCDF file object.\n    Defaults to False.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#returns_11","title":"Returns","text":"<pre><code>- `nc_file` *netCDF4.Dataset* - The netCDF file object.\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#signature_11","title":"Signature","text":"<pre><code>def netcdf_info_print(file_path, file_return=False): ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#non_standard_date_location","title":"non_standard_date_location","text":"<p>Show source in loader.py:535</p> <p>Extracts the date from a non-standard location in the data.</p>"},{"location":"Source-Code/particula/data/loader/#arguments_10","title":"Arguments","text":"<p>data : list     A list of strings representing the data. date_location : dict     A dictionary specifying the method for extracting the date from the     data.     Supported methods include:         - <code>-</code> 'file_header_block' - The date is located in the file header             block, and its position is specified by the 'row',             'delimiter', and 'index' keys.</p>"},{"location":"Source-Code/particula/data/loader/#returns_12","title":"Returns","text":"<p>str     The date extracted from the specified location in the data.</p>"},{"location":"Source-Code/particula/data/loader/#raises_3","title":"Raises","text":"<p>ValueError     If an unsupported or invalid method is specified in date_location.</p>"},{"location":"Source-Code/particula/data/loader/#signature_12","title":"Signature","text":"<pre><code>def non_standard_date_location(data: list, date_location: dict) -&gt; str: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#parse_time_column","title":"parse_time_column","text":"<p>Show source in loader.py:162</p> <p>Parses the time column of a data line and returns it as a timestamp.</p>"},{"location":"Source-Code/particula/data/loader/#arguments_11","title":"Arguments","text":"<p>time_column : Union[int, List[int]]     The index or indices of the column(s) containing the time information. time_format : str     The format of the time information, e.g. '%Y-%m-%d %H:%M:%S'. line : str     The data line to parse. date_offset : Optional[str], default=None     A fixed date offset to add to the timestamp in front. seconds_shift : int, default=0     A number of seconds to add to the timestamp.</p>"},{"location":"Source-Code/particula/data/loader/#returns_13","title":"Returns","text":"<p>float     The timestamp corresponding to the time information in the data line,     in seconds since the epoch.</p>"},{"location":"Source-Code/particula/data/loader/#raises_4","title":"Raises","text":"<p>ValueError     If an invalid time column or format is specified.</p>"},{"location":"Source-Code/particula/data/loader/#signature_13","title":"Signature","text":"<pre><code>def parse_time_column(\n    time_column: Union[int, List[int]],\n    time_format: str,\n    line: np.ndarray,\n    date_offset: Optional[str] = None,\n    seconds_shift: int = 0,\n    timezone_identifier: str = \"UTC\",\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#sample_data","title":"sample_data","text":"<p>Show source in loader.py:224</p> <p>Samples the data to get the time and data streams.</p>"},{"location":"Source-Code/particula/data/loader/#arguments_12","title":"Arguments","text":"<p>data : List[str]     The input data in the form of a list of strings. time_column : int     The index of the column that contains the time values. time_format : str     The format string that specifies the time format. data_columns : List[int]     The indices of the columns that contain the data values. delimiter : str     The delimiter character used to separate columns in the input data. date_offset : str, optional     A string that represents an offset in the date, in the format     'days:hours:minutes:seconds'. Defaults to None. seconds_shift : int, optional     An integer that represents a time shift in seconds. Defaults to 0. timezone_identifier : str, optional     What timezone the data is in. Defaults to 'UTC'.</p>"},{"location":"Source-Code/particula/data/loader/#returns_14","title":"Returns","text":"<p>Tuple[np.ndarray, np.ndarray]     A tuple of two numpy arrays - epoch_time and data_array:     - epoch_time : np.ndarray         A 1-D numpy array of epoch times.     - data_array : np.ndarray         A 2-D numpy array of data values.</p>"},{"location":"Source-Code/particula/data/loader/#raises_5","title":"Raises","text":"<p>ValueError:     - If the data value is not in the correct format.     - If no match for data value is found.</p>"},{"location":"Source-Code/particula/data/loader/#signature_14","title":"Signature","text":"<pre><code>def sample_data(\n    data: List[str],\n    time_column: Union[int, List[int]],\n    time_format: str,\n    data_columns: List[int],\n    delimiter: str,\n    date_offset: Optional[str] = None,\n    seconds_shift: int = 0,\n    timezone_identifier: str = \"UTC\",\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#save_lake","title":"save_lake","text":"<p>Show source in loader.py:774</p> <p>Save lake object as a pickle file.</p>"},{"location":"Source-Code/particula/data/loader/#args_2","title":"Args","text":"<p>data_lake : DataLake     DataLake object to be saved. path : str     Path to save pickle file. sufix_name : str, optional     Suffix to add to pickle file name. The default is None.</p>"},{"location":"Source-Code/particula/data/loader/#signature_15","title":"Signature","text":"<pre><code>def save_lake(\n    path: str,\n    lake: Lake,\n    sufix_name: Optional[str] = None,\n    folder: Optional[str] = \"output\",\n) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#see-also_2","title":"See also","text":"<ul> <li>Lake</li> </ul>"},{"location":"Source-Code/particula/data/loader/#save_stream","title":"save_stream","text":"<p>Show source in loader.py:688</p> <p>Save stream object as a pickle file.</p>"},{"location":"Source-Code/particula/data/loader/#args_3","title":"Args","text":"<p>stream : Stream     Stream object to be saved. path : str     Path to save pickle file. sufix_name : str, optional     Suffix to add to pickle file name. The default is None.</p>"},{"location":"Source-Code/particula/data/loader/#signature_16","title":"Signature","text":"<pre><code>def save_stream(\n    path: str,\n    stream: Stream,\n    sufix_name: Optional[str] = None,\n    folder: Optional[str] = \"output\",\n) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#see-also_3","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/loader/#save_stream_to_csv","title":"save_stream_to_csv","text":"<p>Show source in loader.py:624</p> <p>Save stream object as a CSV file, with an option to include formatted time.</p>"},{"location":"Source-Code/particula/data/loader/#arguments_13","title":"Arguments","text":"<p>stream : Stream     Stream object to be saved. path : str     Path where the CSV file will be saved. suffix_name : str, optional     Suffix to add to CSV file name. The default is None. folder : str, optional     Subfolder within path to save the CSV file. The default is 'output'. include_time : bool, optional     Whether to include time data in the first column. The default is True.</p>"},{"location":"Source-Code/particula/data/loader/#signature_17","title":"Signature","text":"<pre><code>def save_stream_to_csv(\n    stream: Stream,\n    path: str,\n    suffix_name: Optional[str] = None,\n    folder: Optional[str] = \"output\",\n    include_time: bool = True,\n) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader/#see-also_4","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/loader/#sizer_data_formatter","title":"sizer_data_formatter","text":"<p>Show source in loader.py:448</p> <p>Formats data from a particle sizer.</p>"},{"location":"Source-Code/particula/data/loader/#args_4","title":"Args","text":"<p>data : List[str]     The data to be formatted. data_checks : Dict[str, Any]     Dictionary specifying the formatting requirements for the data. data_sizer_reader : Dict[str, str]     Dictionary containing information about the sizer data format. time_column : int     The index of the time column in the data. time_format : str     The format of the time information. delimiter : str, default=','     The delimiter used in the data. date_offset : str, default=None     The date offset to add to the timestamp. seconds_shift : int, default=0     The number of seconds to add to the timestamp. timezone_identifier : str, default='UTC'     The timezone identifier for the data.</p>"},{"location":"Source-Code/particula/data/loader/#returns_15","title":"Returns","text":"<p>Tuple[np.ndarray, List(str) np.ndarray, np.ndarray]     A tuple containing the epoch time, the Dp header, and the data arrays.</p>"},{"location":"Source-Code/particula/data/loader/#signature_18","title":"Signature","text":"<pre><code>def sizer_data_formatter(\n    data: List[str],\n    data_checks: Dict[str, Any],\n    data_sizer_reader: Dict[str, str],\n    time_column: Union[int, List[int]],\n    time_format: str,\n    delimiter: str = \",\",\n    header_row: int = 0,\n    date_offset: Optional[str] = None,\n    seconds_shift: int = 0,\n    timezone_identifier: str = \"UTC\",\n) -&gt; Tuple[np.ndarray, np.ndarray, list]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader_interface/","title":"Loader Interface","text":"<p>Particula Index / Particula / Data / Loader Interface</p> <p>Auto-generated documentation for particula.data.loader_interface module.</p>"},{"location":"Source-Code/particula/data/loader_interface/#get_1d_stream","title":"get_1d_stream","text":"<p>Show source in loader_interface.py:226</p> <p>Loads and formats a 1D data stream from a file and initializes or updates a Stream object.</p>"},{"location":"Source-Code/particula/data/loader_interface/#arguments","title":"Arguments","text":"<p>file_path : str     The path of the file to load data from. first_pass : bool     Whether this is the first time data is being loaded. If True, the     stream is initialized.     If False, raises an error as only one file can be loaded. settings : dict     A dictionary containing data formatting settings such as data checks,     column names,     time format, delimiter, and timezone information. stream : Stream, optional     An instance of Stream class to be updated with loaded data. Defaults     to a new Stream object.</p>"},{"location":"Source-Code/particula/data/loader_interface/#returns","title":"Returns","text":"<p>Stream     The Stream object updated with the loaded data and corresponding time     information.</p>"},{"location":"Source-Code/particula/data/loader_interface/#raises","title":"Raises","text":"<p>ValueError     If <code>first_pass</code> is False, indicating data has already been loaded. TypeError     If <code>settings</code> is not a dictionary. FileNotFoundError     If the file specified by <code>file_path</code> does not exist. KeyError     If any required keys are missing in the <code>settings</code> dictionary.</p>"},{"location":"Source-Code/particula/data/loader_interface/#signature","title":"Signature","text":"<pre><code>def get_1d_stream(\n    file_path: str,\n    settings: dict,\n    first_pass: bool = True,\n    stream: Optional[Stream] = None,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader_interface/#see-also","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/loader_interface/#get_2d_stream","title":"get_2d_stream","text":"<p>Show source in loader_interface.py:338</p> <p>Initializes a 2D stream using the settings in the DataLake object.</p>"},{"location":"Source-Code/particula/data/loader_interface/#arguments_1","title":"Arguments","text":"<pre><code>- `key` *str* - The key of the stream to initialise.\n- `path` *str* - The path of the file to load data from.\n- `first_pass` *bool* - Whether this is the first time loading data.\n</code></pre>"},{"location":"Source-Code/particula/data/loader_interface/#returns_1","title":"Returns","text":"<pre><code>None.\n</code></pre>"},{"location":"Source-Code/particula/data/loader_interface/#signature_1","title":"Signature","text":"<pre><code>def get_2d_stream(\n    file_path: str,\n    settings: dict,\n    first_pass: bool = True,\n    stream: Optional[Stream] = None,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader_interface/#see-also_1","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/loader_interface/#get_new_files","title":"get_new_files","text":"<p>Show source in loader_interface.py:13</p> <p>Scan a directory for new files based on import settings and stream status.</p> <p>This function looks for files in a specified path using import settings. It compares the new list of files with a pre-loaded list in the stream object to determine which files are new. The comparison is made based on file names and sizes. It returns a tuple with the paths of new files, a boolean indicating if this was the first pass, and a list of file information for new files.</p>"},{"location":"Source-Code/particula/data/loader_interface/#arguments_2","title":"Arguments","text":"<p>path : str     The top-level directory path to scan for files. import_settings : dict     A dictionary with 'relative_data_folder', 'filename_regex',     and 'MIN_SIZE_BYTES' as keys     used to specify the subfolder path and the regex pattern for filtering     file names. It should also include 'min_size' key to specify the     minimum size of the files to be considered. loaded_list : list of lists     A list of lists with file names and sizes that have already been     loaded. The default is None. If None, it will be assumed that no     files have been loaded.</p>"},{"location":"Source-Code/particula/data/loader_interface/#returns_2","title":"Returns","text":"<p>tuple of (list, bool, list)     A tuple containing a list of full paths of new files, a boolean     indicating if no previous files were loaded (True if it's the first     pass), and a list of lists with new file names and sizes.</p>"},{"location":"Source-Code/particula/data/loader_interface/#raises_1","title":"Raises","text":"<p>YourErrorType     Explanation of when and why your error is raised and what it means.</p>"},{"location":"Source-Code/particula/data/loader_interface/#signature_2","title":"Signature","text":"<pre><code>def get_new_files(\n    path: str, import_settings: dict, loaded_list: Optional[list] = None\n) -&gt; tuple: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader_interface/#load_files_interface","title":"load_files_interface","text":"<p>Show source in loader_interface.py:109</p> <p>Load files into a stream object based on settings.</p>"},{"location":"Source-Code/particula/data/loader_interface/#arguments_3","title":"Arguments","text":"<p>path : str     The top-level directory path to scan for folders of data. folder_settings : dict     A dictionary with keys corresponding to the stream names and values     corresponding to the settings for each stream. The settings can     be generated using the settings_generator function. stream : Stream, optional     An instance of Stream class to be updated with loaded data. Defaults     to a new Stream object. - <code>sub_sample</code> - int, optional     sub-sample only the first n files. Defaults to None.</p>"},{"location":"Source-Code/particula/data/loader_interface/#returns_3","title":"Returns","text":"<p>Stream     The Stream object updated with the loaded data.</p>"},{"location":"Source-Code/particula/data/loader_interface/#signature_3","title":"Signature","text":"<pre><code>def load_files_interface(\n    path: str,\n    settings: dict,\n    stream: Optional[Stream] = None,\n    sub_sample: Optional[int] = None,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader_interface/#see-also_2","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/loader_interface/#load_folders_interface","title":"load_folders_interface","text":"<p>Show source in loader_interface.py:185</p> <p>Load files into a lake object based on settings.</p>"},{"location":"Source-Code/particula/data/loader_interface/#arguments_4","title":"Arguments","text":"<p>path : str     The top-level directory path to scan for folders of data. folder_settings : dict     A dictionary with keys corresponding to the stream names and values     corresponding to the settings for each stream. The settings can     be generated using the settings_generator function. lake : Lake, optional     An instance of Lake class to be updated with loaded data. Defaults     to a new Lake object.</p>"},{"location":"Source-Code/particula/data/loader_interface/#returns_4","title":"Returns","text":"<p>Lake     The Lake object updated with the loaded data streams.</p>"},{"location":"Source-Code/particula/data/loader_interface/#signature_4","title":"Signature","text":"<pre><code>def load_folders_interface(\n    path: str, folder_settings: dict, lake: Optional[Lake] = None\n) -&gt; Lake: ...\n</code></pre>"},{"location":"Source-Code/particula/data/loader_interface/#see-also_3","title":"See also","text":"<ul> <li>Lake</li> </ul>"},{"location":"Source-Code/particula/data/merger/","title":"Merger","text":"<p>Particula Index / Particula / Data / Merger</p> <p>Auto-generated documentation for particula.data.merger module.</p>"},{"location":"Source-Code/particula/data/merger/#combine_data","title":"combine_data","text":"<p>Show source in merger.py:15</p> <p>\" Merge or adds processed data together. Accounts for data shape miss matches and duplicate timestamps. If the data is a different shape than the existing data, it will be reshaped to match the existing data.</p>"},{"location":"Source-Code/particula/data/merger/#arguments","title":"Arguments","text":"<p>data : np.array     Existing data stream. time : np.array     Time array for the existing data. header_list : List[str]     List of headers for the existing data. data_new : np.array     Processed data to add to the data stream. time_new : np.array     Time array for the new data. header_new : List[str]     List of headers for the new data.</p>"},{"location":"Source-Code/particula/data/merger/#returns","title":"Returns","text":"<p>Tuple[np.array, List[str], Dict[str, int]]     A tuple containing the updated data stream, the updated header list,     and     a dictionary mapping the header names to their corresponding indices in     the data stream.</p>"},{"location":"Source-Code/particula/data/merger/#signature","title":"Signature","text":"<pre><code>def combine_data(\n    data: np.ndarray,\n    time: np.ndarray,\n    header_list: list,\n    data_new: np.ndarray,\n    time_new: np.ndarray,\n    header_new: list,\n) -&gt; Tuple[np.ndarray, list]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/merger/#stream_add_data","title":"stream_add_data","text":"<p>Show source in merger.py:100</p> <p>Adds a new data stream and corresponding time stream to the existing data.</p>"},{"location":"Source-Code/particula/data/merger/#args","title":"Args","text":"<p>stream : object     A Stream object, containing the existing data. new_time : np.ndarray (m,)     An array of time values for the new data stream. new_data : np.ndarray     An array of data values for the new data stream. header_check : bool, optional     If True, checks whether the header in the new data matches the     header in the existing data. Defaults to False. new_header : list of str, optional     A list of header names for the new data stream. Required if     header_check is True.</p>"},{"location":"Source-Code/particula/data/merger/#returns_1","title":"Returns","text":"<p>stream : object     A Stream object, containing the updated data.</p>"},{"location":"Source-Code/particula/data/merger/#raises","title":"Raises","text":"<p>ValueError     If header_check is True and header is not provided or     header does not match the existing header.</p>"},{"location":"Source-Code/particula/data/merger/#notes","title":"Notes","text":"<p>If header_check is True, the method checks whether the header in the new data matches the header in the existing data. If they do not match, the method attempts to merge the headers and updates the header dictionary.</p> <p>If header_check is False or the headers match, the new data is appended to the existing data.</p> <p>The function also checks whether the time stream is increasing, and if not, sorts the time stream and corresponding data.</p>"},{"location":"Source-Code/particula/data/merger/#signature_1","title":"Signature","text":"<pre><code>def stream_add_data(\n    stream: Stream,\n    time_new: np.ndarray,\n    data_new: np.ndarray,\n    header_check: Optional[bool] = False,\n    header_new: Optional[list] = None,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"Source-Code/particula/data/merger/#see-also","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/","title":"Settings Generator","text":"<p>Particula Index / Particula / Data / Settings Generator</p> <p>Auto-generated documentation for particula.data.settings_generator module.</p>"},{"location":"Source-Code/particula/data/settings_generator/#for_general_1d_load","title":"for_general_1d_load","text":"<p>Show source in settings_generator.py:13</p> <p>Generate a settings dictionary for loading and checking 1D data from CSV files.</p>"},{"location":"Source-Code/particula/data/settings_generator/#arguments","title":"Arguments","text":"<ul> <li>relative_data_folder (str): The folder path relative to the main script     where data files are located. Default is 'instrument_data'.</li> <li>filename_regex (str): Regular expression pattern to match filenames in     the data folder. Default is '*.csv'.</li> <li>file_min_size_bytes (int): Minimum size in bytes for files to be     considered valid. Default is 10.</li> <li>header_row (int): The index of the row containing column headers     (0-indexed). Default is 0.</li> <li>data_checks (Optional[dict]): A dictionary containing data quality     checks such as character length, required character counts, rows to     skip at the beginning or end. Defaults to basic checks if None.</li> <li>data_column (list of int): List of indices for columns containing data     points to be loaded. Default is [3, 5].</li> <li>data_header (List[str]): List of strings representing the header names     for data columns. Default is ['data 1', 'data 3'].</li> <li>time_column (List[int]): List of indices for columns containing time     information. Default is [0, 1].</li> <li>time_format (str): String format for parsing time columns, using     strftime conventions. Default is '%Y-%m-%d %H:%M:%S.%f'.</li> <li>delimiter (str): Character used to separate values in the file.     Default is ','.</li> <li>time_shift_seconds (int): Number of seconds by which to shift time data     (positive or negative). Default is 0.</li> <li>timezone_identifier (str): Timezone identifier for time conversion.     Default is 'UTC'.</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#returns","title":"Returns","text":"<ul> <li><code>-</code> dict - A dictionary with settings for data loading procedures including     file paths, size requirements, header information, and data check     parameters.</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#signature","title":"Signature","text":"<pre><code>def for_general_1d_load(\n    relative_data_folder: str = \"instrument_data\",\n    filename_regex: str = \"*.csv\",\n    file_min_size_bytes: int = 10,\n    header_row: int = 0,\n    data_checks: Optional[dict] = None,\n    data_column: list = [3, 5],\n    data_header: List[str] = [\"data 1\", \"data 3\"],\n    time_column: List[int] = [0, 1],\n    time_format: str = \"%Y-%m-%d %H:%M:%S.%f\",\n    delimiter: str = \",\",\n    time_shift_seconds: int = 0,\n    timezone_identifier: str = \"UTC\",\n) -&gt; dict: ...\n</code></pre>"},{"location":"Source-Code/particula/data/settings_generator/#for_general_sizer_1d_2d_load","title":"for_general_sizer_1d_2d_load","text":"<p>Show source in settings_generator.py:88</p> <p>Generate settings for the 1D general file loader and the 2D general sizer     file loader.</p>"},{"location":"Source-Code/particula/data/settings_generator/#arguments_1","title":"Arguments","text":"<ul> <li>relative_data_folder (str): Path to the folder containing data files,     relative to the script's location.</li> <li>filename_regex (str): Regex pattern to match filenames for loading.</li> <li>file_min_size_bytes (int): Minimum file size in bytes for a file to be     considered valid for loading.</li> <li>header_row (int): Row index for the header (0-based) in the data files.</li> <li>data_checks (dict, optional): Specifications for data integrity checks     to apply when loading data.</li> <li>data_1d_column (list of int): Column indices for 1D data extraction.</li> <li>data_1d_header (list of str): Header names corresponding to the     <code>data_1d_column</code> indices.</li> <li>data_2d_dp_start_keyword (str): Keyword indicating the start of 2D data     points in a file.</li> <li>data_2d_dp_end_keyword (str): Keyword indicating the end of 2D data     points in a file.</li> <li>data_2d_convert_concentration_from (str, optional): Unit to convert from     if concentration scaling is needed for 2D data.</li> <li>time_column (list of int): Column indices for time data extraction.</li> <li>time_format (str): Format string for parsing time data.</li> <li>delimiter (str): Delimiter character for splitting data in the file.</li> <li>time_shift_seconds (int): Seconds to shift the time data by.</li> <li>timezone_identifier (str): Timezone ID for time data interpretation.</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#returns_1","title":"Returns","text":"<ul> <li>tuple of (dict, dict): A tuple containing two dictionaries with settings     for the 1D and 2D data loaders.</li> </ul> <p>The function defaults <code>data_checks</code> to basic validation criteria if not     provided. It returns separate dictionaries for settings applicable to     1D and 2D data loaders, which include file paths, size checks, and     data parsing rules.</p>"},{"location":"Source-Code/particula/data/settings_generator/#signature_1","title":"Signature","text":"<pre><code>def for_general_sizer_1d_2d_load(\n    relative_data_folder: str = \"instrument_data\",\n    filename_regex: str = \"*.csv\",\n    file_min_size_bytes: int = 10,\n    header_row: int = 0,\n    data_checks: Optional[dict] = None,\n    data_1d_column: list = [3, 5],\n    data_1d_header: List[str] = [\"data 1\", \"data 3\"],\n    data_2d_dp_start_keyword: str = \"Date Time\",\n    data_2d_dp_end_keyword: str = \"Total Conc\",\n    data_2d_convert_concentration_from: str = \"dw/dlogdp\",\n    time_column: List[int] = [0, 1],\n    time_format: str = \"%Y-%m-%d %H:%M:%S.%f\",\n    delimiter: str = \",\",\n    time_shift_seconds: int = 0,\n    timezone_identifier: str = \"UTC\",\n) -&gt; tuple: ...\n</code></pre>"},{"location":"Source-Code/particula/data/settings_generator/#load_settings_for_lake","title":"load_settings_for_lake","text":"<p>Show source in settings_generator.py:261</p> <p>Load settings for Lake data from a JSON file. The settings file is a dictionary of stream settings dictionaries.</p> <p>Given a path and subfolder, this function searches for a JSON file named 'lake_settings' with an optional suffix. It returns the settings as a dictionary. If no file is found, or multiple files are found, appropriate errors or warnings are raised.</p>"},{"location":"Source-Code/particula/data/settings_generator/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> path - The path where the subfolder is located.</li> <li><code>-</code> subfolder - The subfolder where the settings file is expected.</li> <li><code>-</code> settings_suffix - An optional suffix for the settings     file name. Default is an empty string.</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> dict - A dictionary of settings loaded from the file.</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#raises","title":"Raises","text":"<ul> <li><code>-</code> FileNotFoundError - If no settings file is found.</li> <li><code>-</code> Warning - If more than one settings file is found.</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#signature_2","title":"Signature","text":"<pre><code>def load_settings_for_lake(\n    path: str, subfolder: str = \"\", settings_suffix: str = \"\"\n) -&gt; dict: ...\n</code></pre>"},{"location":"Source-Code/particula/data/settings_generator/#load_settings_for_stream","title":"load_settings_for_stream","text":"<p>Show source in settings_generator.py:185</p> <p>Load settings for Stream data from a JSON file.</p> <p>Given a path and subfolder, this function searches for a JSON file named 'stream_settings' with an optional suffix. It returns the settings as a dictionary. If no file is found, or multiple files are found, appropriate errors or warnings are raised.</p>"},{"location":"Source-Code/particula/data/settings_generator/#arguments_3","title":"Arguments","text":"<ul> <li><code>-</code> path - The path where the subfolder is located.</li> <li><code>-</code> subfolder - The subfolder where the settings file is expected.</li> <li><code>-</code> settings_suffix - An optional suffix for the settings     file name. Default is an empty string.</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#returns_3","title":"Returns","text":"<ul> <li><code>-</code> dict - A dictionary of settings loaded from the file.</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#raises_1","title":"Raises","text":"<ul> <li><code>-</code> FileNotFoundError - If no settings file is found.</li> <li><code>-</code> Warning - If more than one settings file is found.</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#signature_3","title":"Signature","text":"<pre><code>def load_settings_for_stream(\n    path: str, subfolder: str, settings_suffix: str = \"\"\n) -&gt; dict: ...\n</code></pre>"},{"location":"Source-Code/particula/data/settings_generator/#save_settings_for_lake","title":"save_settings_for_lake","text":"<p>Show source in settings_generator.py:307</p> <p>Save settings for lake data to a JSON file.</p> <p>Given a dictionary of settings, this function saves it to a JSON file named 'lake_settings' with an optional suffix in the specified filename. The JSON file is formatted with a 4-space indentation.</p>"},{"location":"Source-Code/particula/data/settings_generator/#arguments_4","title":"Arguments","text":"<ul> <li><code>-</code> settings - The settings dictionary to be saved.</li> <li><code>-</code> path - The path where the subfolder is located.</li> <li><code>-</code> subfolder - The subfolder where the settings file will be saved.</li> <li><code>-</code> settings_suffix - An optional suffix for the settings     file name. Default is an empty string.</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#returns_4","title":"Returns","text":"<ul> <li>None</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#signature_4","title":"Signature","text":"<pre><code>def save_settings_for_lake(\n    settings: dict, path: str, subfolder: str = \"\", settings_suffix: str = \"\"\n) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/data/settings_generator/#save_settings_for_stream","title":"save_settings_for_stream","text":"<p>Show source in settings_generator.py:230</p> <p>Save settings for lake data to a JSON file.</p> <p>Given a dictionary of settings, this function saves it to a JSON file named 'stream_settings' with an optional suffix in the specified filename. The JSON file is formatted with a 4-space indentation.</p>"},{"location":"Source-Code/particula/data/settings_generator/#arguments_5","title":"Arguments","text":"<ul> <li><code>-</code> settings - The settings dictionary to be saved.</li> <li><code>-</code> path - The path where the subfolder is located.</li> <li><code>-</code> subfolder - The subfolder where the settings file will be saved.</li> <li><code>-</code> settings_suffix - An optional suffix for the settings     file name. Default is an empty string.</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#returns_5","title":"Returns","text":"<ul> <li>None</li> </ul>"},{"location":"Source-Code/particula/data/settings_generator/#signature_5","title":"Signature","text":"<pre><code>def save_settings_for_stream(\n    settings: dict, path: str, subfolder: str, settings_suffix: str = \"\"\n) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream/","title":"Stream","text":"<p>Particula Index / Particula / Data / Stream</p> <p>Auto-generated documentation for particula.data.stream module.</p>"},{"location":"Source-Code/particula/data/stream/#stream_1","title":"Stream","text":"<p>Show source in stream.py:11</p>"},{"location":"Source-Code/particula/data/stream/#attributes","title":"Attributes","text":"<ul> <li><code>header</code>: <code>List[str]</code> - Initialize other fields as empty arrays: field(default_factory=list)</li> </ul> <p>A class for consistent data storage and format.</p>"},{"location":"Source-Code/particula/data/stream/#attributes_1","title":"Attributes","text":"<p>header : List[str]     A list of strings representing the header of the data stream. data : np.ndarray     A numpy array representing the data stream. The first dimension     represents time and the second dimension represents the header. time : np.ndarray     A numpy array representing the time stream. files : List[str]     A list of strings representing the files containing the data stream.</p>"},{"location":"Source-Code/particula/data/stream/#methods","title":"Methods","text":"<p>validate_inputs     Validates the inputs to the Stream class. datetime64 -&gt; np.ndarray     Returns an array of datetime64 objects representing the time stream.     Useful for plotting, with matplotlib.dates. return_header_dict -&gt; dict     Returns the header as a dictionary with keys as header elements and     values as their indices.</p>"},{"location":"Source-Code/particula/data/stream/#signature","title":"Signature","text":"<pre><code>class Stream: ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream/#streamgetitem","title":"Stream().getitem","text":"<p>Show source in stream.py:57</p> <p>Allows for indexing of the data stream.</p>"},{"location":"Source-Code/particula/data/stream/#arguments","title":"Arguments","text":"<p>index : int or str     The index of the data stream to return.</p>"},{"location":"Source-Code/particula/data/stream/#returns","title":"Returns","text":"<p>np.ndarray     The data stream at the specified index.</p>"},{"location":"Source-Code/particula/data/stream/#signature_1","title":"Signature","text":"<pre><code>def __getitem__(self, index: Union[int, str]): ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream/#streamlen","title":"Stream().len","text":"<p>Show source in stream.py:86</p> <p>Returns the length of the time stream.</p>"},{"location":"Source-Code/particula/data/stream/#signature_2","title":"Signature","text":"<pre><code>def __len__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream/#streamsetitem","title":"Stream().setitem","text":"<p>Show source in stream.py:71</p> <p>Allows for setting or adding of a row of data in the stream.</p>"},{"location":"Source-Code/particula/data/stream/#arguments_1","title":"Arguments","text":"<p>index : The index of the data stream to set. value : The data to set at the specified index.</p> <p>future work maybe add a list option and iterate through the list</p>"},{"location":"Source-Code/particula/data/stream/#signature_3","title":"Signature","text":"<pre><code>def __setitem__(self, index: Union[int, str], value): ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream/#streamdatetime64","title":"Stream().datetime64","text":"<p>Show source in stream.py:90</p> <p>Returns an array of datetime64 objects representing the time stream. Useful for plotting, with matplotlib.dates.</p>"},{"location":"Source-Code/particula/data/stream/#signature_4","title":"Signature","text":"<pre><code>@property\ndef datetime64(self) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream/#streamheader_dict","title":"Stream().header_dict","text":"<p>Show source in stream.py:98</p> <p>Returns the header as a dictionary with index (0, 1) as the keys and the names as values.</p>"},{"location":"Source-Code/particula/data/stream/#signature_5","title":"Signature","text":"<pre><code>@property\ndef header_dict(self) -&gt; dict: ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream/#streamheader_float","title":"Stream().header_float","text":"<p>Show source in stream.py:104</p> <p>Returns the header as a numpy array of floats.</p>"},{"location":"Source-Code/particula/data/stream/#signature_6","title":"Signature","text":"<pre><code>@property\ndef header_float(self) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream/#streamvalidate_inputs","title":"Stream().validate_inputs","text":"<p>Show source in stream.py:47</p> <p>Validates the inputs for the DataStream object.</p>"},{"location":"Source-Code/particula/data/stream/#raises","title":"Raises","text":"<pre><code>- `TypeError` - If header is not a list.\n</code></pre>"},{"location":"Source-Code/particula/data/stream/#this-might-be-why-i-cant-call-stream-without-inputs","title":"this might be why I can't call Stream without inputs","text":""},{"location":"Source-Code/particula/data/stream/#signature_7","title":"Signature","text":"<pre><code>def validate_inputs(self): ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream/#streamaveraged","title":"StreamAveraged","text":"<p>Show source in stream.py:111</p> <p>A subclass of Stream with additional parameters related to averaging.</p>"},{"location":"Source-Code/particula/data/stream/#attributes_2","title":"Attributes","text":"<ul> <li><code>average_interval</code> float - The size of the window used for averaging.</li> <li><code>start_time</code> float - The start time for averaging.</li> <li><code>stop_time</code> float - The stop time for averaging.</li> <li><code>standard_deviation</code> float - The standard deviation of the data.</li> </ul>"},{"location":"Source-Code/particula/data/stream/#signature_8","title":"Signature","text":"<pre><code>class StreamAveraged(Stream): ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream/#see-also","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/stream/#streamaveragedget_std","title":"StreamAveraged().get_std","text":"<p>Show source in stream.py:149</p> <p>Returns the standard deviation of the data.</p>"},{"location":"Source-Code/particula/data/stream/#signature_9","title":"Signature","text":"<pre><code>def get_std(self, index) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream/#streamaveragedvalidate_averaging_params","title":"StreamAveraged().validate_averaging_params","text":"<p>Show source in stream.py:131</p> <p>Validates the averaging parameters for the stream.</p>"},{"location":"Source-Code/particula/data/stream/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If average_window is not a positive number or if start_time and stop_time are not numbers or if start_time is greater than or equal to stop_time.</li> </ul>"},{"location":"Source-Code/particula/data/stream/#signature_10","title":"Signature","text":"<pre><code>def validate_averaging_params(self): ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream_stats/","title":"Stream Stats","text":"<p>Particula Index / Particula / Data / Stream Stats</p> <p>Auto-generated documentation for particula.data.stream_stats module.</p>"},{"location":"Source-Code/particula/data/stream_stats/#average_std","title":"average_std","text":"<p>Show source in stream_stats.py:31</p> <p>Calculate the average and standard deviation of data within a given 'stream' object over specified intervals.</p> <p>This function takes a 'stream' object, which should contain time-series data, and computes the average and standard deviation of the data at intervals specified by 'average_interval'. If data.time is in seconds then the units of the interval are seconds (hour in hours etc). The results are returned as a new 'StreamAveraged' object containing the processed data.</p>"},{"location":"Source-Code/particula/data/stream_stats/#arguments","title":"Arguments","text":"<ul> <li>stream (object): The input stream object containing 'time' and 'data'     arrays along with other associated metadata.</li> <li>average_interval (float|int, optional): The time interval over which the     averaging is to be performed.</li> <li>new_time_array (np.ndarray, optional): An optional array of time points     at which the average and standard deviation are computed.     If not provided, a new time array is generated based on the start and     end times within the 'stream.time' object.</li> </ul>"},{"location":"Source-Code/particula/data/stream_stats/#returns","title":"Returns","text":"<ul> <li>StreamAveraged (object): An object of type 'StreamAveraged' containing     the averaged data, time array, start and stop times, the standard     deviation of the averaged data, and other metadata from the original     'stream' object.</li> </ul> <p>The function checks for an existing 'new_time_array' and generates one if needed. It then calculates the average and standard deviation for each interval and constructs a 'StreamAveraged' object with the results and metadata from the original 'stream' object.</p>"},{"location":"Source-Code/particula/data/stream_stats/#signature","title":"Signature","text":"<pre><code>def average_std(\n    stream: Stream,\n    average_interval: Union[float, int] = 60,\n    new_time_array: Optional[np.ndarray] = None,\n) -&gt; StreamAveraged: ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream_stats/#see-also","title":"See also","text":"<ul> <li>StreamAveraged</li> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/stream_stats/#drop_masked","title":"drop_masked","text":"<p>Show source in stream_stats.py:11</p> <p>Drop rows where mask is false, and return data stream.</p>"},{"location":"Source-Code/particula/data/stream_stats/#args","title":"Args","text":"<p>stream : object     data stream object mask : np.ndarray     mask to apply to data stream</p>"},{"location":"Source-Code/particula/data/stream_stats/#returns_1","title":"Returns","text":"<p>object     stream object</p>"},{"location":"Source-Code/particula/data/stream_stats/#signature_1","title":"Signature","text":"<pre><code>def drop_masked(stream: Stream, mask: np.ndarray) -&gt; Stream: ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream_stats/#see-also_1","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/stream_stats/#filtering","title":"filtering","text":"<p>Show source in stream_stats.py:103</p> <p>Filters the data of the given 'stream' object based on the specified bounds or specific value. The filtered data can be either dropped or replaced with a specified value.  Note, not all parameters need to be specified, but at least one must be provided (top, bottom, value)</p>"},{"location":"Source-Code/particula/data/stream_stats/#arguments_1","title":"Arguments","text":"<ul> <li>stream (Stream): The input stream object containing 'data' and 'time'     attributes.</li> <li>bottom (float, optional): The lower bound for filtering data. Defaults     to None.</li> <li>top (float, optional): The upper bound for filtering data.     Defaults to None.</li> <li>value (float, optional): Specific value to filter from data.     Defaults to None.</li> <li>invert (bool): If True, inverts the filter criteria.     Defaults to False.</li> <li>clone (bool): If True, returns a copy of the 'stream' object, with     filtered data. If False, modifies the 'stream' object in-place.     Defaults to True.</li> <li>replace_with (float|int, optional): Value to replace filtered-out data.     Defaults to None.</li> <li>drop (bool, optional): If True, filtered-out data points are dropped     from the dataset. Defaults to False.</li> <li>header (list, optional): The header of the data to filter on. This can     same as calling Stream['header']     Defaults to None.</li> </ul>"},{"location":"Source-Code/particula/data/stream_stats/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> Stream - The 'stream' object with data filtered as specified.</li> </ul> <p>If 'drop' is True, 'replace_with' is ignored and filtered data points are removed from the 'stream' object. Otherwise, filtered data points are replaced with 'replace_with' value.</p> <p>add specific data row to filter on</p>"},{"location":"Source-Code/particula/data/stream_stats/#signature_2","title":"Signature","text":"<pre><code>def filtering(\n    stream: Stream,\n    bottom: Optional[float] = None,\n    top: Optional[float] = None,\n    value: Optional[float] = None,\n    invert: Optional[bool] = False,\n    clone: Optional[bool] = True,\n    replace_with: Optional[Union[float, int]] = None,\n    drop: Optional[bool] = False,\n    header: Optional[Union[list, int, str]] = None,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream_stats/#see-also_2","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/stream_stats/#remove_time_window","title":"remove_time_window","text":"<p>Show source in stream_stats.py:176</p> <p>Remove a time window from a stream object.</p>"},{"location":"Source-Code/particula/data/stream_stats/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> stream - The input stream object containing 'data' and 'time'     attributes.</li> <li><code>-</code> epoch_start - The start time of the time window to be     removed.</li> <li><code>-</code> epoch_end - The end time of the time window to be     removed. If not provided, the time window is the closest time point to     'epoch_start'.</li> </ul>"},{"location":"Source-Code/particula/data/stream_stats/#returns_3","title":"Returns","text":"<ul> <li><code>-</code> Stream - The 'stream' object with the specified time window removed.</li> </ul>"},{"location":"Source-Code/particula/data/stream_stats/#signature_3","title":"Signature","text":"<pre><code>def remove_time_window(\n    stream: Stream,\n    epoch_start: Union[float, int],\n    epoch_end: Optional[Union[float, int]] = None,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"Source-Code/particula/data/stream_stats/#see-also_3","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/process/","title":"Process","text":"<p>Particula Index / Particula / Data / Process</p> <p>Auto-generated documentation for particula.data.process module.</p>"},{"location":"Source-Code/particula/data/process/#modules","title":"Modules","text":"<ul> <li>Kappa Via Extinction</li> <li>Mie Angular</li> <li>Mie Bulk</li> <li>Scattering Truncation</li> <li>Size Distribution</li> </ul>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/","title":"Kappa Via Extinction","text":"<p>Particula Index / Particula / Data / Process / Kappa Via Extinction</p> <p>Auto-generated documentation for particula.data.process.kappa_via_extinction module.</p>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/#extinction_ratio_wet_dry","title":"extinction_ratio_wet_dry","text":"<p>Show source in kappa_via_extinction.py:16</p> <p>Calculates the extinction ratio between wet and dry aerosols, considering water uptake through kappa. This function uses Mie theory to determine the optical properties of aerosols with varying water content, allowing for analysis of hygroscopic growth and its impact on aerosol optical characteristics.</p>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/#parameters","title":"Parameters","text":"<p>kappa : Union[float, NDArray[np.float64]]     Hygroscopicity parameter, defining water uptake ability of particles. number_per_cm3 : NDArray[np.float64]     Number concentration of particles per cubic centimeter for each size     bin. diameters : NDArray[np.float64]     Diameters of particles in nanometers for each size bin. water_activity_sizer : NDArray[np.float64]     Water activity of the aerosol size distribution. water_activity_dry : NDArray[np.float64]     Water activity for the calculation of 'dry' aerosol properties. water_activity_wet : NDArray[np.float64]     Water activity for the calculation of 'wet' aerosol properties. refractive_index_dry : Union[complex, float, np.float16], optional     Refractive index of the dry aerosol particles. water_refractive_index : Union[complex, float], optional     Refractive index of water. wavelength : float, optional     Wavelength of the incident light in nanometers. discretize : bool, optional     If True, discretizes input parameters for Mie calculations to enable     caching. return_coefficients : bool, optional     If True, returns the individual extinction coefficients for wet and     dry aerosols instead of their ratio. return_all_optics : bool, optional     If True, returns all optical properties calculated by Mie theory,     not just extinction.</p>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/#returns","title":"Returns","text":"<p>Union[float, Tuple[NDArray, NDArray]]     By default, returns the ratio of wet to dry aerosol extinction.     If <code>return_coefficients</code> is True, returns a tuple of NDArrays     containing the extinction coefficients for wet and dry aerosols,     respectively.</p>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/#signature","title":"Signature","text":"<pre><code>def extinction_ratio_wet_dry(\n    kappa: Union[float, NDArray[np.float64]],\n    number_per_cm3: NDArray[np.float64],\n    diameters: NDArray[np.float64],\n    water_activity_sizer: NDArray[np.float64],\n    water_activity_dry: NDArray[np.float64],\n    water_activity_wet: NDArray[np.float64],\n    refractive_index_dry: Union[complex, float] = 1.45,\n    water_refractive_index: Union[complex, float] = 1.33,\n    wavelength: float = 450,\n    discretize: bool = True,\n    return_coefficients: bool = False,\n    return_all_optics: bool = False,\n) -&gt; Union[float, Tuple[NDArray, NDArray]]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/#fit_extinction_ratio_with_kappa","title":"fit_extinction_ratio_with_kappa","text":"<p>Show source in kappa_via_extinction.py:131</p> <p>Fits the kappa parameter based on the measured extinction ratios of dry and wet aerosols, utilizing Mie theory to account for water uptake effects. This method optimizes kappa to minimize the difference between the calculated and observed extinction ratio of wet to dry aerosols.</p>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/#parameters_1","title":"Parameters","text":"<p>b_ext_dry : Union[float, np.float64]     The measured extinction of the dry aerosol. b_ext_wet : Union[float, np.float64]     The measured extinction of the wet aerosol. number_per_cm3 : NDArray[np.float64]     The number concentration of particles per cubic centimeter for each     size bin. diameters : NDArray[np.float64]     The diameters of particles in nanometers for each size bin. water_activity_sizer : NDArray[np.float64]     The water activity corresponding to the aerosol size distribution. water_activity_dry : NDArray[np.float64]     The water activity for the 'dry' aerosol condition. water_activity_wet : NDArray[np.float64]     The water activity for the 'wet' aerosol condition. refractive_index_dry : Union[complex, float, np.float16], optional     The refractive index of the dry aerosol particles. water_refractive_index : Union[complex, float], optional     The refractive index of water. wavelength : float, optional     The wavelength of incident light in nanometers. discretize : bool, optional     If True, discretizes input parameters for Mie calculations to enable     caching. kappa_bounds : Tuple[float, float], optional     The bounds within which to fit the kappa parameter. kappa_tolerance : float, optional     The tolerance level for the optimization of kappa. kappa_maxiter : int, optional     The maximum number of iterations allowed in the optimization process.</p>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/#returns_1","title":"Returns","text":"<p>Union[float, np.float64]     The optimized kappa parameter that best fits the observed extinction     ratios.</p>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/#signature_1","title":"Signature","text":"<pre><code>def fit_extinction_ratio_with_kappa(\n    b_ext_dry: Union[float, np.float64],\n    b_ext_wet: Union[float, np.float64],\n    number_per_cm3: NDArray[np.float64],\n    diameters: NDArray[np.float64],\n    water_activity_sizer: NDArray[np.float64],\n    water_activity_dry: NDArray[np.float64],\n    water_activity_wet: NDArray[np.float64],\n    refractive_index_dry: Union[complex, float] = 1.45,\n    water_refractive_index: Union[complex, float] = 1.33,\n    wavelength: float = 450,\n    discretize: bool = True,\n    kappa_bounds: Tuple[float, float] = (0, 1),\n    kappa_tolerance: float = 1e-06,\n    kappa_maxiter: int = 200,\n) -&gt; Union[float, np.float64]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/#kappa_from_extinction_looped","title":"kappa_from_extinction_looped","text":"<p>Show source in kappa_via_extinction.py:232</p> <p>Fits the extinction ratio to the kappa value for a given set of measurements, looping over time indexes in number_per_cm3. This function is tailored for analyzing data from a CAPS (Cavity Attenuated Phase Shift) instrument under varying humidities.</p>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/#parameters_2","title":"Parameters","text":"<p>extinction_dry : NDArray[np.float64]     Array of dry aerosol extinction measurements. extinction_wet : NDArray[np.float64]     Array of wet aerosol extinction measurements. number_per_cm3 : NDArray[np.float64]     Array of particle number concentrations in #/cm\u00b3. diameter : NDArray[np.float64]     Array of particle diameters. water_activity_sizer : NDArray[np.float64]     Water activity (relative humidity/100) of the sizing instrument's air. water_activity_sample_dry : NDArray[np.float64]     Water activity (relative humidity/100) of the air for dry measurements. water_activity_sample_wet : NDArray[np.float64]     Water activity (relative humidity/100) of the air for wet measurements. refractive_index_dry : Union[complex, float], optional     Refractive index of dry particles. Default is 1.45. water_refractive_index : Union[complex, float], optional     Refractive index of water. Default is 1.33. wavelength : float, optional     Wavelength of the light source in nanometers. Default is 450. discretize : bool, optional     If True, calculations are performed with discretized parameter values     to potentially improve performance. Default is True.</p>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/#returns_2","title":"Returns","text":"<p>NDArray[np.float64]     A 2D array where each row corresponds to the time-indexed kappa value,     lower and upper bounds of the kappa estimation, structured as     [kappa, lower, upper].</p>"},{"location":"Source-Code/particula/data/process/kappa_via_extinction/#signature_2","title":"Signature","text":"<pre><code>def kappa_from_extinction_looped(\n    extinction_dry: NDArray[np.float64],\n    extinction_wet: NDArray[np.float64],\n    number_per_cm3: NDArray[np.float64],\n    diameter: NDArray[np.float64],\n    water_activity_sizer: NDArray[np.float64],\n    water_activity_sample_dry: NDArray[np.float64],\n    water_activity_sample_wet: NDArray[np.float64],\n    refractive_index_dry: Union[complex, float] = 1.45,\n    water_refractive_index: Union[complex, float] = 1.33,\n    wavelength: float = 450,\n    discretize: bool = True,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/mie_angular/","title":"Mie Angular","text":"<p>Particula Index / Particula / Data / Process / Mie Angular</p> <p>Auto-generated documentation for particula.data.process.mie_angular module.</p>"},{"location":"Source-Code/particula/data/process/mie_angular/#assign_scattering_thetas","title":"assign_scattering_thetas","text":"<p>Show source in mie_angular.py:110</p> <p>Assigns scattering angles and efficiencies based on the z-axis position within the CAPS instrument.</p>"},{"location":"Source-Code/particula/data/process/mie_angular/#parameters","title":"Parameters","text":"<p>alpha : float     Forward scattering angle in radians. beta : float     Backward scattering angle in radians. q_mie : float     The Mie scattering efficiency. z_position : Union[float, np.float64]     The position along the z-axis (in cm). integrate_sphere_diameter_cm : float     The diameter of the integrating sphere (in cm).</p>"},{"location":"Source-Code/particula/data/process/mie_angular/#returns","title":"Returns","text":"<p>Tuple[float, float, float]     A tuple containing the forward scattering angle (theta1), backward     scattering angle (theta2), and the ideal scattering efficiency     (qsca_ideal) for the given z-axis position.</p>"},{"location":"Source-Code/particula/data/process/mie_angular/#signature","title":"Signature","text":"<pre><code>def assign_scattering_thetas(\n    alpha: float,\n    beta: float,\n    q_mie: float,\n    z_position: Union[float, np.float64],\n    integrate_sphere_diameter_cm: float,\n) -&gt; Tuple[float, float, float]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/mie_angular/#calculate_scattering_angles","title":"calculate_scattering_angles","text":"<p>Show source in mie_angular.py:68</p> <p>Calculates forward and backward scattering angles for a given position along the z-axis within the CAPS instrument geometry.</p>"},{"location":"Source-Code/particula/data/process/mie_angular/#parameters_1","title":"Parameters","text":"<p>z_position : Union[float, np.float64]     The position along the z-axis (in cm). integrate_sphere_diameter_cm : float     The diameter of the integrating sphere (in cm). tube_diameter_cm : float     The diameter of the sample tube (in cm).</p>"},{"location":"Source-Code/particula/data/process/mie_angular/#returns_1","title":"Returns","text":"<p>Tuple[float, float]     A tuple containing the forward (alpha) and backward (beta)     scattering angles in radians.</p>"},{"location":"Source-Code/particula/data/process/mie_angular/#signature_1","title":"Signature","text":"<pre><code>def calculate_scattering_angles(\n    z_position: Union[float, np.float64],\n    integrate_sphere_diameter_cm: float,\n    tube_diameter_cm: float,\n) -&gt; Tuple[float, float]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/mie_angular/#discretize_scattering_angles","title":"discretize_scattering_angles","text":"<p>Show source in mie_angular.py:14</p> <p>Discretizes and caches the scattering function for a spherical particle with specified material properties and size. This function aims to optimize the performance of scattering calculations by caching results for frequently used parameters, reducing the need for repeated calculations.</p>"},{"location":"Source-Code/particula/data/process/mie_angular/#parameters_2","title":"Parameters","text":"<p>m_sphere : Union[complex, float]     The complex or real refractive index of the particle. wavelength : float     The wavelength of the incident light in nanometers (nm). diameter : Union[float, np.float64]     The diameter of the particle in nanometers (nm). min_angle : float, optional     The minimum scattering angle in degrees to be considered in the     calculation. Defaults to 0. max_angle : float, optional     The maximum scattering angle in degrees to be considered in the     calculation. Defaults to 180. angular_resolution : float, optional     The resolution in degrees between calculated scattering angles.     Defaults to 1.</p>"},{"location":"Source-Code/particula/data/process/mie_angular/#returns_2","title":"Returns","text":"<p>Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray] A tuple containing numpy arrays for the scattering function measurements:     - measure: The scattering intensity as a function of angle.     - parallel: The scattering intensity for parallel polarization.     - perpendicular: The scattering intensity for         perpendicular polarization.     - unpolarized: The unpolarized scattering intensity.</p>"},{"location":"Source-Code/particula/data/process/mie_angular/#signature_2","title":"Signature","text":"<pre><code>@lru_cache(maxsize=100000)\ndef discretize_scattering_angles(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter: Union[float, np.float64],\n    min_angle: int = 0,\n    max_angle: int = 180,\n    angular_resolution: float = 1,\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/mie_bulk/","title":"Mie Bulk","text":"<p>Particula Index / Particula / Data / Process / Mie Bulk</p> <p>Auto-generated documentation for particula.data.process.mie_bulk module.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#compute_bulk_optics","title":"compute_bulk_optics","text":"<p>Show source in mie_bulk.py:142</p> <p>Computes bulk optical properties from size dependent efficiency factors for the size distribution.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#parameters","title":"Parameters","text":"<p>q_ext, q_sca, q_abs, q_pr, q_back, q_ratio, g : NDArray[np.float64]     Arrays of efficiency factors and the asymmetry factor. area : NDArray[np.float64]     area scaled size distribution. extinction_only : bool     Flag to compute only the extinction coefficient. pms : bool     Flag indicating if probability mass distribution, where sum of     all bins is total number of particles, is used. dp : NDArray[np.float64]     An array of particle diameters in nanometers.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#returns","title":"Returns","text":"<p>Tuple containing bulk optical properties.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#signature","title":"Signature","text":"<pre><code>def compute_bulk_optics(\n    q_ext: NDArray[np.float64],\n    q_sca: NDArray[np.float64],\n    q_back: NDArray[np.float64],\n    q_ratio: NDArray[np.float64],\n    g: NDArray[np.float64],\n    area_dist: NDArray[np.float64],\n    extinction_only: bool,\n    pms: bool,\n    dp: NDArray[np.float64],\n) -&gt; Union[NDArray[np.float64], tuple[NDArray[np.float64], ...]]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/mie_bulk/#discretize_auto_mieq","title":"discretize_auto_mieq","text":"<p>Show source in mie_bulk.py:17</p> <p>Computes Mie coefficients for a spherical particle based on its material properties, size, and the properties of the surrounding medium.</p> <p>This function leverages the PyMieScatt library to calculate the extinction (q_ext), scattering (q_sca), absorption (q_abs) efficiencies, the asymmetry factor (g), radiation pressure efficiency (q_pr), backscatter efficiency (q_back), and the ratio of backscatter to extinction efficiency (q_ratio) for a single sphere under specified conditions.</p> <p>This function is optimized with an LRU (Least Recently Used) cache to enhance performance by storing up to 100,000 recent calls. The cache memorizes the results of expensive function calls and returns the cached result when the same inputs occur again, reducing the need to recompute these values.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#args","title":"Args","text":"<p>m_sphere : The complex refractive index of the sphere. For non-absorbing     material a real number can be provided. wavelength : The wavelength of the incident light in nanometers (nm). diameter : The diameter of the sphere in nanometers (nm). mMedium : The refractive index of the surrounding medium.     Defaults to 1.0, corresponding to vacuum.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#returns_1","title":"Returns","text":"<p>Tuple[float, float, float, float, float, float, float]     A tuple containing the calculated Mie efficiencies and parameters:     q_ext (extinction efficiency), q_sca (scattering efficiency),     q_abs (absorption efficiency), g (asymmetry factor),     q_pr (radiation pressure efficiency), q_back (backscatter efficiency),     and q_ratio (the ratio of backscatter to extinction efficiency).</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#signature_1","title":"Signature","text":"<pre><code>@lru_cache(maxsize=100000)\ndef discretize_auto_mieq(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter: float,\n    m_medium: float = 1.0,\n) -&gt; Tuple[float, ...]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/mie_bulk/#discretize_mie_parameters","title":"discretize_mie_parameters","text":"<p>Show source in mie_bulk.py:64</p> <p>Discretizes the refractive index of the material, the wavelength of incident light, and the diameters of particles to enhance the numerical stability and performance of Mie scattering calculations. This approach is particularly useful for caching Mie scattering computations, as it reduces the variability in input parameters leading to a more manageable set of unique calculations.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#parameters_1","title":"Parameters","text":"<p>m_sphere : Union[complex, float]     The complex or real refractive index of the particles. This value is     discretized to a specified base to reduce the granularity of input     variations. wavelength : float     The wavelength of incident light in nanometers (nm). It is discretized     to minimize the variations in computations related to different     wavelengths. diameter : NDArray[np.float64]     An array of particle diameters in nanometers (nm), each of which is     discretized to a specified base to standardize the input sizes for     calculations. base_m_sphere : float, optional     The base value to which the real and imaginary parts of the refractive     index are rounded. Defaults to 0.001. base_wavelength : float, optional     The base value to which the wavelength is rounded. Defaults to 1 nm. base_diameter : float, optional     The base value to which particle diameters are rounded.     Defaults to 5 nm.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#returns_2","title":"Returns","text":"<p>Tuple[Union[complex, float], float, NDArray[np.float64]] A tuple containing the discretized refractive index (m_sphere), wavelength, and diameters (diameter), suitable for use in further Mie scattering calculations with potentially improved performance and reduced computational overhead.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#signature_2","title":"Signature","text":"<pre><code>def discretize_mie_parameters(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter: Union[float, NDArray[np.float64]],\n    base_m_sphere: float = 0.001,\n    base_wavelength: float = 1,\n    base_diameter: float = 5,\n) -&gt; Tuple[Union[complex, float], float, Union[float, list[float]]]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/mie_bulk/#format_mie_results","title":"format_mie_results","text":"<p>Show source in mie_bulk.py:200</p> <p>Formats the output results of the Mie scattering calculations.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#parameters_2","title":"Parameters","text":"<p>b_ext, b_sca, b_abs, bigG, b_pr, b_back, b_ratio : float     Bulk optical properties. asDict : bool     Determines the format of the results.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#returns_3","title":"Returns","text":"<p>Either a dictionary or a tuple of the computed bulk optical properties.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#signature_3","title":"Signature","text":"<pre><code>def format_mie_results(\n    b_ext: NDArray[np.float64],\n    b_sca: NDArray[np.float64],\n    b_abs: NDArray[np.float64],\n    big_g: NDArray[np.float64],\n    b_pr: NDArray[np.float64],\n    b_back: NDArray[np.float64],\n    b_ratio: NDArray[np.float64],\n    as_dict: bool,\n) -&gt; Union[dict[str, NDArray[np.float64]], tuple[NDArray[np.float64], ...]]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/mie_bulk/#mie_size_distribution","title":"mie_size_distribution","text":"<p>Show source in mie_bulk.py:237</p> <p>Calculates Mie scattering parameters for a size distribution of spherical particles.</p> <p>This function computes optical properties such as extinction, scattering, absorption coefficients, asymmetry factor, backscatter efficiency, and their ratios for a given size distribution of spherical particles. It supports various modes of calculation, including discretization of input parameters and optional truncation of the scattering efficiency.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#parameters_3","title":"Parameters","text":"<p>m_sphere : Union[complex, float]     The complex refractive index of the particles. Real values can be used     for non-absorbing materials. wavelength : float     The wavelength of the incident light in nanometers (nm). diameter : NDArray[np.float64]     An array of particle diameters in nanometers (nm). number_per_cm3 : NDArray[np.float64]     The number distribution of particles per cubic centimeter (#/cm^3). n_medium : float, optional     The refractive index of the medium. Defaults to 1.0 (air or vacuum). pms : bool, optional     Specifies if the size distribution is in probability mass form. as_dict : bool, optional     If True, results are returned as a dictionary. Otherwise, as a tuple. extinction_only : bool, optional     If True, only the extinction coefficient is calculated and returned. discretize : bool, optional     If True, input parameters (m, wavelength, dp) are discretized for     computation. Defaults to False. truncation_calculation : bool, optional     Enables truncation of the scattering efficiency based on a multiple     of the backscattering coefficient. Defaults to False. truncation_b_sca_multiple : Optional[float], optional     The multiple of the backscattering coefficient used for truncating the     scattering efficiency. Required if <code>truncation_calculation</code> is True.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#returns_4","title":"Returns","text":"<p>Union[float, Dict[str, float], Tuple[float, ...]]     Depending on the parameters <code>asDict</code> and <code>extinction_only</code>, the     function can return:     - A single float (extinction coefficient) if <code>extinction_only</code> is True.     - A dictionary of computed optical properties if <code>asDict</code> is True.     - A tuple of computed optical properties.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#raises","title":"Raises","text":"<p>ValueError     If <code>truncation_calculation</code> is True but <code>truncation_b_sca_multiple</code>     is not specified.</p>"},{"location":"Source-Code/particula/data/process/mie_bulk/#signature_4","title":"Signature","text":"<pre><code>def mie_size_distribution(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter: NDArray[np.float64],\n    number_per_cm3: NDArray[np.float64],\n    n_medium: float = 1.0,\n    pms: bool = True,\n    as_dict: bool = False,\n    extinction_only: bool = False,\n    discretize: bool = False,\n    truncation_calculation: bool = False,\n    truncation_b_sca_multiple: Optional[float] = None,\n) -&gt; Union[\n    NDArray[np.float64], dict[str, NDArray[np.float64]], Tuple[NDArray[np.float64], ...]\n]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/scattering_truncation/","title":"Scattering Truncation","text":"<p>Particula Index / Particula / Data / Process / Scattering Truncation</p> <p>Auto-generated documentation for particula.data.process.scattering_truncation module.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#correction_for_distribution","title":"correction_for_distribution","text":"<p>Show source in scattering_truncation.py:246</p> <p>Calculates the correction factor for scattering measurements due to truncation effects in aerosol size distribution measurements. This correction factor is used to adjust the measured scattering coefficient, accounting for the limited angular range of the instrument.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#parameters","title":"Parameters","text":"<p>m_sphere : Union[complex, float]     The complex or real refractive index of the particles. wavelength : float     The wavelength of the incident light in nanometers (nm). diameter_sizes : NDArray[np.float64]     An array of particle diameters in nanometers (nm) corresponding to the     size distribution. number_per_cm3 : NDArray[np.float64]     An array of particle number concentrations (#/cm^3) for each diameter     in the size distribution. discretize : bool, optional     If True, the calculation will use discretized values for the     refractive index, wavelength, and diameters to potentially improve     computation performance. Default is True.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#returns","title":"Returns","text":"<p>float     The correction factor for scattering measurements. This factor is     dimensionless and is used to correct the measured scattering     coefficient for truncation effects, calculated as the ratio of     the ideal (full angular range) to truncated scattering coefficient.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#example","title":"Example","text":"<p>b_sca_corrected = b_sca_measured * bsca_correction</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#signature","title":"Signature","text":"<pre><code>def correction_for_distribution(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter_sizes: NDArray[np.float64],\n    number_per_cm3: NDArray[np.float64],\n    discretize: bool = True,\n) -&gt; Union[float, np.float64]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#correction_for_humidified","title":"correction_for_humidified","text":"<p>Show source in scattering_truncation.py:321</p> <p>Calculates the scattering correction for humidified aerosol measurements, accounting for water uptake by adjusting the aerosol's refractive index. This function requires the kappa values for the particles, which describe their hygroscopic growth.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#parameters_1","title":"Parameters","text":"<p>kappa : Union[float, NDArray[np.float64]]     Hygroscopicity parameter kappa, indicating the water uptake capability     of the particles. number_per_cm3 : NDArray[np.float64]     Number concentration of particles per cubic centimeter (#/cm\u00b3) for     each size bin. diameter : NDArray[np.float64]     Array of particle diameters in nanometers (nm). water_activity_sizer : NDArray[np.float64]     Water activity (relative humidity/100) of the air sample used for     sizing. water_activity_sample : NDArray[np.float64]     Water activity (relative humidity/100) of the air sample in optical     measurements. refractive_index_dry : Union[complex, float], optional     Refractive index of the dry particles. Default is 1.45. water_refractive_index : Union[complex, float], optional     Refractive index of water. Default is 1.33. wavelength : float, optional     Wavelength of the incident light in nanometers (nm). Default is 450. discretize : bool, optional     If True, calculation uses discretized values for refractive index,     wavelength, and diameters to improve performance. Default is True.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#returns_1","title":"Returns","text":"<p>np.float64     A numpy array of scattering correction factors for each particle size     in the distribution, to be applied to measured backscatter     coefficients to account for truncation effects due to humidity.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#signature_1","title":"Signature","text":"<pre><code>def correction_for_humidified(\n    kappa: Union[float, np.float64],\n    number_per_cm3: NDArray[np.float64],\n    diameter: NDArray[np.float64],\n    water_activity_sizer: np.float64,\n    water_activity_sample: np.float64,\n    refractive_index_dry: Union[complex, float] = 1.45,\n    water_refractive_index: Union[complex, float] = 1.33,\n    wavelength: float = 450,\n    discretize: bool = True,\n) -&gt; np.float64: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#correction_for_humidified_looped","title":"correction_for_humidified_looped","text":"<p>Show source in scattering_truncation.py:407</p> <p>Corrects scattering measurements for aerosol particles to account for truncation errors in CAPS instrument. This correction is vital for accurate representation of particle scattering properties under different humidity conditions. The function iterates over time-indexed measurements, calculating corrections based on input parameters reflecting the particles' physical and chemical characteristics.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#parameters_2","title":"Parameters","text":"<p>kappa : NDArray[np.float64]     Hygroscopicity parameter array for the aerosol particles, indicating     water uptake ability. number_per_cm3 : NDArray[np.float64]     Time-indexed number concentration of particles in #/cm\u00b3 for each size. diameter : NDArray[np.float64]     Particle diameters, crucial for calculating scattering effects. water_activity_sizer : NDArray[np.float64]     Water activity measured by the sizing instrument, indicating relative     humidity. water_activity_sample : NDArray[np.float64]     Sample water activity, corresponding to the ambient conditions during     measurement. refractive_index_dry : Union[complex, float], optional     Refractive index of the dry particles, affecting their scattering     behavior. Default is 1.45. water_refractive_index : Union[complex, float], optional     Refractive index of water, important for calculations involving     humidified conditions. Default is 1.33. wavelength : float, optional     Wavelength of the incident light in nanometers, which influences     scattering intensity. Default is 450. discretize : bool, optional     If set to True, performs discretized calculations for potentially     improved computational performance. Default is True.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#returns_2","title":"Returns","text":"<p>NDArray[np.float64] An array of corrected scattering multipliers for each time index, accounting for aerosol particle size, composition, and environmental conditions.</p> <p>The correction process includes data nan checks for missing values, ensuring robust and reliable correction outcomes.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#signature_2","title":"Signature","text":"<pre><code>def correction_for_humidified_looped(\n    kappa: NDArray[np.float64],\n    number_per_cm3: NDArray[np.float64],\n    diameter: NDArray[np.float64],\n    water_activity_sizer: NDArray[np.float64],\n    water_activity_sample: NDArray[np.float64],\n    refractive_index_dry: Union[complex, float] = 1.45,\n    water_refractive_index: Union[complex, float] = 1.33,\n    wavelength: float = 450,\n    discretize: bool = True,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#get_truncated_scattering","title":"get_truncated_scattering","text":"<p>Show source in scattering_truncation.py:16</p> <p>Extracts the truncated scattering intensity and corresponding angles based on the given truncation angles.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#parameters_3","title":"Parameters","text":"<p>su : np.ndarray     The scattering intensity for unpolarized light as a function of angle. theta : np.ndarray     The array of angles corresponding to the scattering intensity     measurements. theta1 : float     The lower bound of the angle range for truncation in radians. theta2 : float     The upper bound of the angle range for truncation in radians.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#returns_3","title":"Returns","text":"<p>Tuple[np.ndarray, np.ndarray]     A tuple containing the truncated scattering intensity and the     corresponding angles within the truncated range.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#signature_3","title":"Signature","text":"<pre><code>def get_truncated_scattering(\n    scattering_unpolarized: np.ndarray, theta: np.ndarray, theta1: float, theta2: float\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#trunc_mono","title":"trunc_mono","text":"<p>Show source in scattering_truncation.py:51</p> <p>Calculates the single scattering albedo (SSA) correction due to truncation for monodisperse aerosol measurements using the CAPS-PM-SSA instrument. The correction accounts for the incomplete angular range of scattering measurements due to the instrument's geometry.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#parameters_4","title":"Parameters","text":"<p>m_sphere : Union[complex, float]     Complex or real refractive index of the aerosol. wavelength : float     Wavelength of light in nanometers used in the CAPS instrument. diameter : Union[float, np.float64]     Diameter of the monodisperse aerosol in nanometers. full_output : bool, optional     If True, additional details about the calculation are returned,     including z-axis values, angles of integration, and both truncated and     ideal scattering efficiencies. calibrated_trunc : bool, optional     If True, applies a numberical calibration factor to the truncation     correction, so 150 is 1. Default is True. discretize : bool, optional     If True, discretizes the input parameters for potentially improved     stability/performance in scattering function calculations. Can not be     done for full_output=True</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#returns_4","title":"Returns","text":"<p>Union[float, Tuple[float, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]] If fullOutput is False, returns only the truncation correction factor. If fullOutput is True, returns a tuple containing the truncation correction factor, z-axis positions, truncated scattering efficiency, ideal scattering efficiency, forward scattering angle, and backward scattering angle.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#signature_4","title":"Signature","text":"<pre><code>@lru_cache(maxsize=100000)\ndef trunc_mono(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter: float,\n    full_output: bool = False,\n    calibrated_trunc: bool = True,\n    discretize: bool = True,\n) -&gt; Union[\n    float, Tuple[float, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]\n]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#truncation_for_diameters","title":"truncation_for_diameters","text":"<p>Show source in scattering_truncation.py:189</p> <p>Calculates the truncation correction for an array of particle diameters given a specific refractive index and wavelength. This function is particularly useful for aerosol optical property measurements where truncation effects due to instrument geometry need to be accounted for.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#parameters_5","title":"Parameters","text":"<p>m_sphere : Union[complex, float]     The complex or real refractive index of the particles. wavelength : float     The wavelength of the incident light in nanometers (nm). diameter_sizes : NDArray[np.float64]     An array of particle diameters in nanometers (nm) for which the     truncation correction will be calculated. discretize : bool, optional     A flag indicating whether to discretize the input parameters for     potentially improved calculation performance. Default is True. calibrated_trunc : bool, optional     If True, applies a numberical calibration factor to the truncation     correction, so 150 is 1. Default is True.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#returns_5","title":"Returns","text":"<p>NDArray[np.float64]     An array of truncation corrections corresponding to the input array of     particle diameters.</p>"},{"location":"Source-Code/particula/data/process/scattering_truncation/#signature_5","title":"Signature","text":"<pre><code>def truncation_for_diameters(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter_sizes: NDArray[np.float64],\n    discretize: bool = True,\n    calibrated_trunc: bool = True,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/size_distribution/","title":"Size Distribution","text":"<p>Particula Index / Particula / Data / Process / Size Distribution</p> <p>Auto-generated documentation for particula.data.process.size_distribution module.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#iterate_merge_distributions","title":"iterate_merge_distributions","text":"<p>Show source in size_distribution.py:351</p> <p>Merge two sets of particle size distributions using linear weighting.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#arguments","title":"Arguments","text":"<ul> <li><code>concentration_lower</code> - The concentration of particles in the     lower distribution.</li> <li><code>diameters_lower</code> - The diameters corresponding to the     lower distribution.</li> <li><code>concentration_upper</code> - The concentration of particles in the     upper distribution.</li> <li><code>diameters_upper</code> - The diameters corresponding to the upper distribution.</li> </ul>"},{"location":"Source-Code/particula/data/process/size_distribution/#returns","title":"Returns","text":"<p>A tuple containing the merged diameter distribution and the merged     concentration distribution.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#signature","title":"Signature","text":"<pre><code>def iterate_merge_distributions(\n    concentration_lower: np.ndarray,\n    diameters_lower: np.ndarray,\n    concentration_upper: np.ndarray,\n    diameters_upper: np.ndarray,\n) -&gt; tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/size_distribution/#mean_properties","title":"mean_properties","text":"<p>Show source in size_distribution.py:20</p> <p>Calculates the mean properties of the size distribution.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#args","title":"Args","text":"<p>sizer_dndlogdp : List[float]     Concentration of particles in each bin. sizer_diameter : List[float]     Bin centers total_concentration : Optional[float], default=None     Total concentration of particles in the distribution. sizer_limits : Optional[Tuple[float, float]], default=None     The lower and upper limits of the size of interest.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#returns_1","title":"Returns","text":"<p>Tuple[float, float, float, float, float, float, float]     Total concentration of particles in the distribution.     Total mass of particles in the distribution.     Mean diameter of the distribution by number.     Mean diameter of the distribution by volume.     Geometric mean diameter of the distribution.     Mode diameter of the distribution by number.     Mode diameter of the distribution by volume.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#signature_1","title":"Signature","text":"<pre><code>def mean_properties(\n    sizer_dndlogdp: np.ndarray,\n    sizer_diameter: np.ndarray,\n    total_concentration: Optional[float] = None,\n    sizer_limits: Optional[list] = None,\n) -&gt; Tuple[float, float, float, float, float, float, float]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/size_distribution/#merge_distributions","title":"merge_distributions","text":"<p>Show source in size_distribution.py:271</p> <p>Merge two particle size distributions using linear weighting.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#arguments_1","title":"Arguments","text":"<p>concentration_lower:     The concentration of particles in the lower     distribution. diameters_lower:     The diameters corresponding to the lower distribution.     - <code>concentration_upper</code> - The concentration of particles in the upper     distribution. diameters_upper:     The diameters corresponding to the upper distribution.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#returns_2","title":"Returns","text":"<ul> <li><code>new_2d</code> - The merged concentration distribution.</li> <li><code>new_diameter</code> - The merged diameter distribution.</li> </ul> <p>add in an acount for the moblity vs aerodynamic diameters</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#signature_2","title":"Signature","text":"<pre><code>def merge_distributions(\n    concentration_lower: np.ndarray,\n    diameters_lower: np.ndarray,\n    concentration_upper: np.ndarray,\n    diameters_upper: np.ndarray,\n) -&gt; tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/size_distribution/#merge_size_distribution","title":"merge_size_distribution","text":"<p>Show source in size_distribution.py:397</p> <p>Merge two sets of particle size distributions using linear weighting. The concentration should be in dN/dlogDp.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#arguments_2","title":"Arguments","text":"<ul> <li><code>stream_smaller</code> - The stream with lower sizes, e.g. SMPS.</li> <li><code>stream_larger</code> - The stream with larger sizes, e.g. OPS. or APS</li> <li><code>lower_units</code> - The units of the lower distribution. The default is 'nm'.</li> <li><code>upper_units</code> - The units of the upper distribution. The default is 'um'.</li> </ul>"},{"location":"Source-Code/particula/data/process/size_distribution/#returns_3","title":"Returns","text":"<ul> <li><code>Stream</code> - A stream object containing the merged size distribution.</li> </ul>"},{"location":"Source-Code/particula/data/process/size_distribution/#signature_3","title":"Signature","text":"<pre><code>def merge_size_distribution(\n    stream_lower: Stream,\n    stream_upper: Stream,\n    lower_units: str = \"nm\",\n    upper_units: str = \"um\",\n) -&gt; object: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/size_distribution/#see-also","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/process/size_distribution/#resample_distribution","title":"resample_distribution","text":"<p>Show source in size_distribution.py:437</p> <p>Resample a particle size distribution to a new set of diameters. Using np interpolation, and extrapolation is nan.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#arguments_3","title":"Arguments","text":"<ul> <li><code>stream</code> - (Stream)     The stream to resample.</li> <li><code>new_diameters</code> - (np.ndarry)     The new diameters to resample to.</li> <li><code>concentration_scale</code> - (str)     The concentration scale of the distribution. Either, 'dn/dlogdp',     'dn', 'pms' (which is dn), or 'pdf'.</li> </ul>"},{"location":"Source-Code/particula/data/process/size_distribution/#returns_4","title":"Returns","text":"<ul> <li><code>Stream</code> - The resampled stream.</li> </ul>"},{"location":"Source-Code/particula/data/process/size_distribution/#signature_4","title":"Signature","text":"<pre><code>def resample_distribution(\n    stream: Stream,\n    new_diameters: np.ndarray,\n    concentration_scale: str = \"dn/dlogdp\",\n    clone: bool = False,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/size_distribution/#see-also_1","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/data/process/size_distribution/#sizer_mean_properties","title":"sizer_mean_properties","text":"<p>Show source in size_distribution.py:116</p> <p>Calculates the mean properties of the size distribution, and returns a stream.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#args_1","title":"Args","text":"<p>stream : Stream     The stream to process. sizer_limits : list, optional [in diameter_units]     The lower and upper limits of the size of interest. The default is None density : float, optional     The density of the particles. The default is 1.5 g/cm3. diameter_units : str     The units of the diameter. The default is 'nm'. This will be converted     to nm.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#returns_5","title":"Returns","text":"<p>stream : Stream     The stream with the mean properties added.</p>"},{"location":"Source-Code/particula/data/process/size_distribution/#signature_5","title":"Signature","text":"<pre><code>def sizer_mean_properties(\n    stream: Stream,\n    sizer_limits: Optional[List[float]] = None,\n    density: float = 1.5,\n    diameter_units: str = \"nm\",\n) -&gt; Stream: ...\n</code></pre>"},{"location":"Source-Code/particula/data/process/size_distribution/#see-also_2","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"Source-Code/particula/equilibria/","title":"Equilibria","text":"<p>Particula Index / Particula / Equilibria</p> <p>Auto-generated documentation for particula.equilibria module.</p>"},{"location":"Source-Code/particula/equilibria/#modules","title":"Modules","text":"<ul> <li>Partitioning</li> </ul>"},{"location":"Source-Code/particula/equilibria/partitioning/","title":"Partitioning","text":"<p>Particula Index / Particula / Equilibria / Partitioning</p> <p>Auto-generated documentation for particula.equilibria.partitioning module.</p>"},{"location":"Source-Code/particula/equilibria/partitioning/#get_properties_for_liquid_vapor_partitioning","title":"get_properties_for_liquid_vapor_partitioning","text":"<p>Show source in partitioning.py:180</p> <p>Get properties for liquid-vapor partitioning.</p>"},{"location":"Source-Code/particula/equilibria/partitioning/#signature","title":"Signature","text":"<pre><code>def get_properties_for_liquid_vapor_partitioning(\n    water_activity_desired, molar_mass, oxygen2carbon, density\n): ...\n</code></pre>"},{"location":"Source-Code/particula/equilibria/partitioning/#liquid_vapor_obj_function","title":"liquid_vapor_obj_function","text":"<p>Show source in partitioning.py:9</p> <p>Objective function for liquid-vapor partitioning.</p>"},{"location":"Source-Code/particula/equilibria/partitioning/#signature_1","title":"Signature","text":"<pre><code>def liquid_vapor_obj_function(\n    e_j_partition_guess,\n    c_star_j_dry,\n    concentration_organic_matter,\n    gamma_organic_ab,\n    mass_fraction_water_ab,\n    q_ab,\n    molar_mass,\n    error_only=True,\n): ...\n</code></pre>"},{"location":"Source-Code/particula/equilibria/partitioning/#liquid_vapor_partitioning","title":"liquid_vapor_partitioning","text":"<p>Show source in partitioning.py:128</p> <p>Thermodynamic equilibrium between liquid and vapor phase. with activity coefficients,</p>"},{"location":"Source-Code/particula/equilibria/partitioning/#signature_2","title":"Signature","text":"<pre><code>def liquid_vapor_partitioning(\n    c_star_j_dry,\n    concentration_organic_matter,\n    molar_mass,\n    gamma_organic_ab,\n    mass_fraction_water_ab,\n    q_ab,\n    partition_coefficient_guess=None,\n): ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/","title":"Lagrangian","text":"<p>Particula Index / Particula / Lagrangian</p> <p>Auto-generated documentation for particula.lagrangian module.</p>"},{"location":"Source-Code/particula/lagrangian/#modules","title":"Modules","text":"<ul> <li>Boundary</li> <li>Collisions</li> <li>Integration</li> <li>Particle Pairs</li> <li>Particle Property</li> </ul>"},{"location":"Source-Code/particula/lagrangian/boundary/","title":"Boundary","text":"<p>Particula Index / Particula / Lagrangian / Boundary</p> <p>Auto-generated documentation for particula.lagrangian.boundary module.</p>"},{"location":"Source-Code/particula/lagrangian/boundary/#wrapped_cube","title":"wrapped_cube","text":"<p>Show source in boundary.py:6</p> <p>Apply cubic boundary conditions with wrap-around, to the position tensor.</p> <p>This function modifies positions that exceed the cubic domain side, wrapping them around to the opposite side of the domain. It handles both positive and negative overflows. The center of the cube is assumed to be at zero. If a particle is way outside the cube, it is wrapped around to the opposite side of the cube.</p>"},{"location":"Source-Code/particula/lagrangian/boundary/#arguments","title":"Arguments","text":"<ul> <li>position (torch.Tensor): A tensor representing positions that might     exceed the domain boundaries. [3, num_particles]</li> <li>cube_side (float): The cube side length of the domain.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/boundary/#returns","title":"Returns","text":"<ul> <li><code>-</code> torch.Tensor - The modified position tensor with boundary conditions     applied.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/boundary/#examples","title":"Examples","text":"<p>position = torch.tensor([...])  # Position tensor cube_side = 10.0  # Define the domain wrapped_position = boundary.wrapped_cube(position,     cube_side)</p>"},{"location":"Source-Code/particula/lagrangian/boundary/#signature","title":"Signature","text":"<pre><code>def wrapped_cube(position: torch.Tensor, cube_side: float) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/collisions/","title":"Collisions","text":"<p>Particula Index / Particula / Lagrangian / Collisions</p> <p>Auto-generated documentation for particula.lagrangian.collisions module.</p>"},{"location":"Source-Code/particula/lagrangian/collisions/#coalescence","title":"coalescence","text":"<p>Show source in collisions.py:69</p> <p>Update mass and velocity of particles based on collision pairs, conserving mass and momentum.</p> <p>This function processes collision pairs, sorts them to avoid duplicate handling, and then updates the mass and velocity of colliding particles according to the conservation of mass and momentum.</p>"},{"location":"Source-Code/particula/lagrangian/collisions/#arguments","title":"Arguments","text":"<ul> <li><code>position</code> torch.Tensor - A 2D tensor of shape [n_dimensions, n_particles]     representing the positions of particles.</li> <li><code>velocity</code> torch.Tensor - A 2D tensor of shape [n_dimensions, n_particles]     representing the velocities of particles.</li> <li><code>mass</code> torch.Tensor - A 1D tensor containing the mass of each particle.</li> <li><code>radius</code> torch.Tensor - A 1D tensor containing the radius of each particle.</li> <li><code>collision_indices_pairs</code> torch.Tensor - A 2D tensor containing pairs of     indices representing colliding particles.</li> <li><code>remove_duplicates_func</code> function - A function to remove duplicate entries     from a tensor of index pairs.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/collisions/#returns","title":"Returns","text":"<ul> <li><code>-</code> torch.Tensor - A 2D tensor of shape [n_dimensions, n_particles]     representing the updated velocities of particles.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/collisions/#notes","title":"Notes","text":"<ul> <li>This function modifies the <code>velocity</code> and <code>mass</code> tensors in-place.</li> <li>It assumes that the mass and momentum are transferred from the right     particle to the left in each collision pair.</li> <li>The subtraction approach for the right-side particles ensures no mass is     lost in multi-particle collisions (e.g., A&lt;-B and B&lt;-D).</li> </ul>"},{"location":"Source-Code/particula/lagrangian/collisions/#signature","title":"Signature","text":"<pre><code>def coalescence(\n    position: torch.Tensor,\n    velocity: torch.Tensor,\n    mass: torch.Tensor,\n    radius: torch.Tensor,\n    collision_indices_pairs: torch.Tensor,\n) -&gt; Tuple[torch.Tensor, torch.Tensor]: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/collisions/#elastic_collision","title":"elastic_collision","text":"<p>Show source in collisions.py:136</p> <p>Update velocities of particles based on elastic collision pairs using matrix operations, conserving kinetic energy and momentum.</p>"},{"location":"Source-Code/particula/lagrangian/collisions/#arguments_1","title":"Arguments","text":"<ul> <li><code>velocity</code> torch.Tensor - A 2D tensor of shape [n_dimensions, n_particles]     representing the velocities of particles.</li> <li><code>mass</code> torch.Tensor - A 1D tensor containing the mass of each particle.</li> <li><code>collision_indices_pairs</code> torch.Tensor - A 2D tensor containing pairs of     indices representing colliding particles.</li> <li><code>remove_duplicates_func</code> function - A function to remove duplicate entries     from a tensor of index pairs.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/collisions/#returns_1","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A 2D tensor of shape [n_dimensions, n_particles]     representing the updated velocities of particles.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/collisions/#notes_1","title":"Notes","text":"<ul> <li>This function modifies the <code>velocity</code> tensor in-place.</li> <li>Mass remains unchanged in elastic collisions.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/collisions/#examples","title":"Examples","text":"<ul> <li><code>2d</code> - https://www.wolframalpha.com/input?i=elastic+collision&amp;assumption=%7B%22F%22%2C+%22ElasticCollision%22%2C+%22m2%22%7D+-%3E%221+kg%22&amp;assumption=%7B%22F%22%2C+%22ElasticCollision%22%2C+%22m1%22%7D+-%3E%221+kg%22&amp;assumption=%22FSelect%22+-%3E+%7B%7B%22ElasticCollision2D%22%7D%7D&amp;assumption=%7B%22F%22%2C+%22ElasticCollision%22%2C+%22v1i%22%7D+-%3E%221+m%2Fs%22&amp;assumption=%7B%22F%22%2C+%22ElasticCollision%22%2C+%22v2i%22%7D+-%3E%22-0.5+m%2Fs%22</li> <li><code>3d</code> fortran - https://www.plasmaphysics.org.uk/programs/coll3d_for.htm https://www.plasmaphysics.org.uk/collision3d.htm</li> </ul> <p>I think the approach is take a pair, and rotate the coordinate system so that the collision is in the x-y plane. Then, the z component of the velocity is a 1d problem, and the x-y component is a 2d problem. Then, rotate back to the original coordinate system.</p>"},{"location":"Source-Code/particula/lagrangian/collisions/#signature_1","title":"Signature","text":"<pre><code>def elastic_collision(\n    velocity: torch.Tensor, mass: torch.Tensor, collision_indices_pairs: torch.Tensor\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/collisions/#find_collisions","title":"find_collisions","text":"<p>Show source in collisions.py:9</p> <p>Find the collision pairs from a distance matrix, given the mass and indices of particles.</p> <p>This function identifies pairs of particles that are within a certain distance threshold (&lt;0), indicating a collision. It filters out pairs involving particles with zero mass.</p>"},{"location":"Source-Code/particula/lagrangian/collisions/#arguments_2","title":"Arguments","text":"<ul> <li><code>distance_matrix</code> torch.Tensor - A 2D tensor containing the pairwise     distances between particles.</li> <li><code>indices</code> torch.Tensor - A 1D tensor containing the indices of the     particles.</li> <li><code>mass</code> torch.Tensor - A 1D tensor containing the mass of each particle.</li> <li><code>k</code> int, optional - The number of closest neighbors to consider for each     particle. Defaults to 1.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/collisions/#returns_2","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A 2D tensor of shape [n_collisions, 2] containing the indices of colliding pairs of particles.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/collisions/#notes_2","title":"Notes","text":"<ul> <li>The function assumes that the diagonal elements of the distance matrix (distances of particles to themselves) are less than zero.</li> <li>Particles with zero mass are excluded from the collision pairs.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/collisions/#signature_2","title":"Signature","text":"<pre><code>def find_collisions(\n    distance_matrix: torch.Tensor, indices: torch.Tensor, mass: torch.Tensor, k: int = 1\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/integration/","title":"Integration","text":"<p>Particula Index / Particula / Lagrangian / Integration</p> <p>Auto-generated documentation for particula.lagrangian.integration module.</p>"},{"location":"Source-Code/particula/lagrangian/integration/#leapfrog","title":"leapfrog","text":"<p>Show source in integration.py:7</p> <p>Perform a single step of leapfrog integration on the position and velocity of a particle.</p> <p>Leapfrog integration is a numerical method used for solving differential equations typically found in molecular dynamics and astrophysics. It is symplectic, hence conserves energy over long simulations, and is known for its simple implementation and stability over large time steps.</p>"},{"location":"Source-Code/particula/lagrangian/integration/#arguments","title":"Arguments","text":"<ul> <li>position (Tensor): The current position of the particle.</li> <li>velocity (Tensor): The current velocity of the particle.</li> <li>force (Tensor): The current force acting on the particle.</li> <li>mass (float): The mass of the particle.</li> <li>time_step (float): The time step for the integration.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/integration/#returns","title":"Returns","text":"<ul> <li><code>-</code> tuple - Updated position and velocity of the particle after one time step.</li> </ul> <p>Reference: - https://en.wikipedia.org/wiki/Leapfrog_integration</p>"},{"location":"Source-Code/particula/lagrangian/integration/#signature","title":"Signature","text":"<pre><code>def leapfrog(\n    position: torch.Tensor,\n    velocity: torch.Tensor,\n    force: torch.Tensor,\n    mass: torch.Tensor,\n    time_step: float,\n) -&gt; Tuple[torch.Tensor, torch.Tensor]: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/","title":"Particle Pairs","text":"<p>Particula Index / Particula / Lagrangian / Particle Pairs</p> <p>Auto-generated documentation for particula.lagrangian.particle_pairs module.</p>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#calculate_pairwise_distance","title":"calculate_pairwise_distance","text":"<p>Show source in particle_pairs.py:48</p> <p>need to test this:</p> <p>Calculate the pairwise Euclidean distances between points in a given position tensor.</p> <p>This function computes the pairwise distances between points represented in the input tensor. Each row of the input tensor is considered a point in n-dimensional space.</p>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#arguments","title":"Arguments","text":"<ul> <li><code>position</code> torch.Tensor - A 2D tensor of shape [n_dimensions, n_points]</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#returns","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A 2D tensor of shape [n_points, n_points] containing the pairwise Euclidean distances between each pair of points. The element at [i, j] in the output tensor represents the distance between the i-th and j-th points in the input tensor.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#examples","title":"Examples","text":"<p>position = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</p>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#output-will-be-a-3x3-tensor-with-the-pairwise-distances-between-these","title":"Output will be a 3x3 tensor with the pairwise distances between these","text":"<p>3 points.</p>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#signature","title":"Signature","text":"<pre><code>def calculate_pairwise_distance(position: torch.Tensor) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#full_sweep_and_prune","title":"full_sweep_and_prune","text":"<p>Show source in particle_pairs.py:159</p> <p>Sweep and prune algorithm for collision detection along all three axes (x, y, z). This function identifies pairs of particles that are close enough to potentially collide in 3D space.</p>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#arguments_1","title":"Arguments","text":"<ul> <li><code>position</code> torch.Tensor - The 2D tensor of particle positions,     where each row represents an axis (x, y, z).</li> <li><code>radius</code> torch.Tensor - The radius of particles.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#returns_1","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor containing pairs of indices of potentially     colliding particles.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#signature_1","title":"Signature","text":"<pre><code>def full_sweep_and_prune(\n    position: torch.Tensor, radius: torch.Tensor\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#full_sweep_and_prune_simplified","title":"full_sweep_and_prune_simplified","text":"<p>Show source in particle_pairs.py:240</p> <p>A simplified version of the full sweep and prune algorithm for collision written above, it is not working yet. there is an error in the update of the indices in the y and z axis.</p> <p>Sweep and prune algorithm for collision detection along all three axes (x, y, z). This function identifies pairs of particles that are close enough to potentially collide in 3D space.</p>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#arguments_2","title":"Arguments","text":"<ul> <li><code>position</code> torch.Tensor - The 2D tensor of particle positions,     where each row represents an axis (x, y, z).</li> <li><code>radius</code> torch.Tensor - The radius of particles.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#returns_2","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor containing pairs of indices of potentially     colliding particles.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#signature_2","title":"Signature","text":"<pre><code>def full_sweep_and_prune_simplified(\n    position: torch.Tensor, radius: torch.Tensor, working_yet: bool = False\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#remove_duplicates","title":"remove_duplicates","text":"<p>Show source in particle_pairs.py:7</p> <p>Removes duplicate entries from a specified column in a tensor of index pairs.</p> <p>This function is designed to work with tensors where each row represents a pair of indices. It removes rows containing duplicate entries in the specified column.</p>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#arguments_3","title":"Arguments","text":"<ul> <li>index_pairs (torch.Tensor): A 2D tensor of shape [n, 2], where n is the     number of index pairs.</li> <li>index_to_remove (int): The column index (0 or 1) from which to remove     duplicate entries.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#returns_3","title":"Returns","text":"<ul> <li><code>-</code> torch.Tensor - A 2D tensor of index pairs with duplicates removed from     the specified column.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#examples_1","title":"Examples","text":"<p>index_pairs = torch.tensor([[1, 2], [3, 4], [1, 2]]) index_to_remove = 0</p>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#output-will-be-1-2-3-4-assuming-column-0-is-chosen-for-removing","title":"Output will be [[1, 2], [3, 4]] assuming column 0 is chosen for removing","text":"<pre><code>duplicates.\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#signature_3","title":"Signature","text":"<pre><code>def remove_duplicates(\n    index_pairs: torch.Tensor, index_to_remove: int\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#single_axis_sweep_and_prune","title":"single_axis_sweep_and_prune","text":"<p>Show source in particle_pairs.py:118</p> <p>Sweep and prune algorithm for collision detection along a single axis. This function identifies pairs of particles that are close enough to potentially collide.</p>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#arguments_4","title":"Arguments","text":"<ul> <li><code>position_axis</code> torch.Tensor - The position of particles along a single     axis.</li> <li><code>radius</code> torch.Tensor - The radius of particles.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#returns_4","title":"Returns","text":"<ul> <li><code>Tuple[torch.Tensor,</code> torch.Tensor] - Two tensors containing the indices of potentially colliding particles.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#signature_4","title":"Signature","text":"<pre><code>def single_axis_sweep_and_prune(\n    position_axis: torch.Tensor, radius: torch.Tensor\n) -&gt; Tuple[torch.Tensor, torch.Tensor]: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#validate_pair_distance","title":"validate_pair_distance","text":"<p>Show source in particle_pairs.py:79</p> <p>Validates if the Euclidean distances between pairs of points are smaller than the sum of their radii.</p>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#arguments_5","title":"Arguments","text":"<ul> <li><code>collision_indices_pairs</code> torch.Tensor - A tensor containing pairs of     indices of potentially colliding particles.</li> <li><code>position</code> torch.Tensor - A 2D tensor of particle positions, where each     column represents a particle, and each row represents an axis.</li> <li><code>radius</code> torch.Tensor - A 1D tensor representing the radius of each     particle.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#returns_5","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor containing the indices of the pairs of     particles that are actually colliding.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_pairs/#signature_5","title":"Signature","text":"<pre><code>def validate_pair_distance(\n    collision_indices_pairs: torch.Tensor, position: torch.Tensor, radius: torch.Tensor\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_property/","title":"Particle Property","text":"<p>Particula Index / Particula / Lagrangian / Particle Property</p> <p>Auto-generated documentation for particula.lagrangian.particle_property module.</p>"},{"location":"Source-Code/particula/lagrangian/particle_property/#friction_factor_wrapper","title":"friction_factor_wrapper","text":"<p>Show source in particle_property.py:70</p> <p>Calculate the friction factor for a given radius, temperature, and pressure.</p> <p>This function wraps several underlying calculations related to dynamic viscosity, mean free path, Knudsen number, and slip correction factor to compute the particle friction factor.</p>"},{"location":"Source-Code/particula/lagrangian/particle_property/#arguments","title":"Arguments","text":"<ul> <li><code>radius_meter</code> - A tensor representing the radius of the sphere(s) in meters. Can be a scalar or a vector.</li> <li><code>temperature_kelvin</code> - A tensor of the temperature in Kelvin.</li> <li><code>pressure_pascal</code> - A tensor of the pressure in Pascals.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#returns","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor of the same shape as <code>radius_meter</code>, representing the particle friction factor.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#signature","title":"Signature","text":"<pre><code>def friction_factor_wrapper(\n    radius_meter: torch.Tensor, temperature_kelvin: float, pressure_pascal: float\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_property/#generate_particle_masses","title":"generate_particle_masses","text":"<p>Show source in particle_property.py:122</p> <p>Generate an array of particle masses based on a log-normal distribution of particle radii and a given density.</p>"},{"location":"Source-Code/particula/lagrangian/particle_property/#arguments_1","title":"Arguments","text":"<ul> <li><code>mean_radius</code> float - Mean radius of the particles. The units are     specified by <code>radius_input_units</code>.</li> <li><code>std_dev_radius</code> float - Standard deviation of the particle radii. The     units are specified by <code>radius_input_units</code>.</li> <li><code>density</code> torch.Tensor - Density of the particles in kg/m^3.</li> <li><code>num_particles</code> int - Number of particles to generate.</li> <li><code>radius_input_units</code> str, optional - Units of <code>mean_radius</code> and     <code>std_dev_radius</code>. Defaults to 'nm' (nanometers).</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#returns_1","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor of particle masses in kg, corresponding to each     particle.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If <code>mean_radius</code> or <code>std_dev_radius</code> are non-positive.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#signature_1","title":"Signature","text":"<pre><code>def generate_particle_masses(\n    mean_radius: float,\n    std_dev_radius: float,\n    density: torch.Tensor,\n    num_particles: int,\n    radius_input_units: str = \"nm\",\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_property/#mass_calculation","title":"mass_calculation","text":"<p>Show source in particle_property.py:44</p> <p>Calculate the mass of a sphere given its radius and density using the formula for the volume of a sphere.</p> <p>This function assumes a uniform density and spherical shape to compute the mass based on the mass-density relationship: Volume = Mass / Density. The volume of a sphere is given by (4/3) * pi * radius^3.</p>"},{"location":"Source-Code/particula/lagrangian/particle_property/#arguments_2","title":"Arguments","text":"<ul> <li>radius (torch.Tensor): A tensor containing the radius of the sphere(s).     Can be a scalar or a vector.</li> <li>density (torch.Tensor): A tensor containing the density of the sphere(s).     Can be a scalar or a vector.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#returns_2","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor of the same shape as <code>radius</code> and <code>density</code>     representing the mass of the sphere(s).</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#signature_2","title":"Signature","text":"<pre><code>def mass_calculation(radius: torch.Tensor, density: torch.Tensor) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_property/#nearest_match","title":"nearest_match","text":"<p>Show source in particle_property.py:254</p> <p>Perform nearest neighbor interpolation (on torch objects) to find y-values corresponding to new x-values. The function identifies the nearest x-value for each value in x_new and returns the corresponding y-value.</p>"},{"location":"Source-Code/particula/lagrangian/particle_property/#arguments_3","title":"Arguments","text":"<ul> <li><code>x_values</code> torch.Tensor - The original x-values of shape (n,).</li> <li><code>y_values</code> torch.Tensor - The original y-values of shape (n,).     Each y-value corresponds to an x-value.</li> <li><code>x_new</code> torch.Tensor - The new x-values for which y-values are to be     interpolated, of shape (m,).</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#returns_3","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - The interpolated y-values of shape (m,). Each value     corresponds to the nearest match from x_values.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#signature_3","title":"Signature","text":"<pre><code>def nearest_match(\n    x_values: torch.Tensor, y_values: torch.Tensor, x_new: torch.Tensor\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_property/#radius_calculation","title":"radius_calculation","text":"<p>Show source in particle_property.py:12</p> <p>Calculate the radius of a sphere given its mass and density using the formula for the volume of a sphere.</p> <p>This function assumes a uniform density and spherical shape to compute the radius based on the mass-density relationship: Volume = Mass / Density. The volume of a sphere is given by (4/3) * pi * radius^3.</p>"},{"location":"Source-Code/particula/lagrangian/particle_property/#arguments_4","title":"Arguments","text":"<ul> <li>mass (torch.Tensor): A tensor containing the mass of the sphere(s). Can     be a scalar or a vector.</li> <li>density (torch.Tensor): A tensor containing the density of the sphere(s).     Can be a scalar or a vector.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#returns_4","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor of the same shape as <code>mass</code> and <code>density</code>     representing the radius of the sphere(s).</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#notes","title":"Notes","text":"<ul> <li>The function supports broadcasting, so <code>mass</code> and <code>density</code> can be of     different shapes, as long as they are broadcastable to a common shape.</li> <li>Units of mass and density should be consistent to obtain a radius in     meaningful units.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#signature_4","title":"Signature","text":"<pre><code>def radius_calculation(mass: torch.Tensor, density: torch.Tensor) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_property/#random_thermal_velocity","title":"random_thermal_velocity","text":"<p>Show source in particle_property.py:221</p> <p>Generate a random thermal velocity for each particle.</p>"},{"location":"Source-Code/particula/lagrangian/particle_property/#arguments_5","title":"Arguments","text":"<ul> <li><code>temperature_kelvin</code> torch.Tensor - Temperature of the fluid in Kelvin.</li> <li><code>mass_kg</code> torch.Tensor - Mass of the particle in kilograms.</li> <li><code>number_of_particles</code> int - Number of particles.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#returns_5","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - Thermal speed of the particle in meters per second.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#signature_5","title":"Signature","text":"<pre><code>def random_thermal_velocity(\n    temperature_kelvin: float,\n    mass_kg: torch.Tensor,\n    number_of_particles: int,\n    t_type=torch.float,\n    random_seed: int = 0,\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_property/#speed","title":"speed","text":"<p>Show source in particle_property.py:206</p> <p>Calculate the speed of a particle.</p>"},{"location":"Source-Code/particula/lagrangian/particle_property/#arguments_6","title":"Arguments","text":"<ul> <li><code>velocity</code> torch.Tensor - Velocity of the particle.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#returns_6","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - Speed of the particle.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#signature_6","title":"Signature","text":"<pre><code>def speed(velocity: torch.Tensor) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/lagrangian/particle_property/#thermal_speed","title":"thermal_speed","text":"<p>Show source in particle_property.py:173</p> <p>Calculate the thermal speed of a particle based on its temperature and mass.</p> <p>The thermal speed is computed using the formula: sqrt(8 * k * T / (pi * m)) where k is the Boltzmann constant, T is the temperature in Kelvin, and m is the particle mass in kilograms.</p>"},{"location":"Source-Code/particula/lagrangian/particle_property/#arguments_7","title":"Arguments","text":"<ul> <li><code>temperature_kelvin</code> float - Temperature of the environment in Kelvin.</li> <li><code>mass_kg</code> torch.Tensor - Mass of the particle(s) in kilograms.     Can be a scalar or a vector.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#returns_7","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - The thermal speed of the particle(s) in meters per second</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If <code>temperature_kelvin</code> is less than or equal to zero or if any element of <code>mass_kg</code> is non-positive.</li> </ul>"},{"location":"Source-Code/particula/lagrangian/particle_property/#signature_7","title":"Signature","text":"<pre><code>def thermal_speed(temperature_kelvin: float, mass_kg: torch.Tensor) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"Source-Code/particula/next/","title":"Next","text":"<p>Particula Index / Particula / Next</p> <p>Auto-generated documentation for particula.next module.</p>"},{"location":"Source-Code/particula/next/#modules","title":"Modules","text":"<ul> <li>Abc Builder</li> <li>Abc Factory</li> <li>Aerosol</li> <li>Dynamics</li> <li>Gas</li> <li>Particles</li> <li>Runnable</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/","title":"Abc Builder","text":"<p>Particula Index / Particula / Next / Abc Builder</p> <p>Auto-generated documentation for particula.next.abc_builder module.</p>"},{"location":"Source-Code/particula/next/abc_builder/#builderabc","title":"BuilderABC","text":"<p>Show source in abc_builder.py:20</p> <p>Abstract base class for builders with common methods to check keys and set parameters from a dictionary.</p>"},{"location":"Source-Code/particula/next/abc_builder/#attributes","title":"Attributes","text":"<ul> <li>required_parameters (list): List of required parameters for the builder.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#methods","title":"Methods","text":"<ul> <li>check_keys (parameters): Check if the keys you want to set are     present in the parameters dictionary.</li> <li>set_parameters (parameters): Set parameters from a dictionary including     optional suffix for units as '_units'.</li> <li><code>-</code> pre_build_check() - Check if all required attribute parameters are set     before building.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#abstract-methods","title":"Abstract Methods:","text":"<ul> <li><code>-</code> build() - Build and return the strategy object with the set parameters.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If any required key is missing during check_keys or     pre_build_check, or if trying to set an invalid parameter.</li> <li><code>-</code> Warning - If using default units for any parameter.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature","title":"Signature","text":"<pre><code>class BuilderABC(ABC):\n    def __init__(self, required_parameters: Optional[list[str]] = None): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_builder/#builderabcbuild","title":"BuilderABC().build","text":"<p>Show source in abc_builder.py:144</p> <p>Build and return the strategy object with the set parameters.</p>"},{"location":"Source-Code/particula/next/abc_builder/#returns","title":"Returns","text":"<ul> <li><code>-</code> strategy - The built strategy object.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef build(self) -&gt; Any: ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_builder/#builderabccheck_keys","title":"BuilderABC().check_keys","text":"<p>Show source in abc_builder.py:51</p> <p>Check if the keys you want to set are present in the parameters dictionary and if all keys are valid.</p>"},{"location":"Source-Code/particula/next/abc_builder/#arguments","title":"Arguments","text":"<ul> <li>parameters (dict): The parameters dictionary to check.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#returns_1","title":"Returns","text":"<ul> <li>None</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#raises_1","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If any required key is missing or if trying to set an invalid parameter.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature_2","title":"Signature","text":"<pre><code>def check_keys(self, parameters: dict[str, Any]): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_builder/#builderabcpre_build_check","title":"BuilderABC().pre_build_check","text":"<p>Show source in abc_builder.py:126</p> <p>Check if all required attribute parameters are set before building.</p>"},{"location":"Source-Code/particula/next/abc_builder/#returns_2","title":"Returns","text":"<ul> <li>None</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#raises_2","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If any required parameter is missing.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature_3","title":"Signature","text":"<pre><code>def pre_build_check(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_builder/#builderabcset_parameters","title":"BuilderABC().set_parameters","text":"<p>Show source in abc_builder.py:93</p> <p>Set parameters from a dictionary including optional suffix for units as '_units'.</p>"},{"location":"Source-Code/particula/next/abc_builder/#arguments_1","title":"Arguments","text":"<ul> <li>parameters (dict): The parameters dictionary to set.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#returns_3","title":"Returns","text":"<ul> <li><code>-</code> self - The builder object with the set parameters.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#raises_3","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If any required key is missing.</li> <li><code>-</code> Warning - If using default units for any parameter.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature_4","title":"Signature","text":"<pre><code>def set_parameters(self, parameters: dict[str, Any]): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_builder/#builderconcentrationmixin","title":"BuilderConcentrationMixin","text":"<p>Show source in abc_builder.py:255</p> <p>Mixin class for Builder classes to set concentration and concentration_units.</p>"},{"location":"Source-Code/particula/next/abc_builder/#methods_1","title":"Methods","text":"<ul> <li><code>-</code> set_concentration(concentration - float, concentration_units: str): Set the concentration attribute and units.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature_5","title":"Signature","text":"<pre><code>class BuilderConcentrationMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_builder/#builderconcentrationmixinset_concentration","title":"BuilderConcentrationMixin().set_concentration","text":"<p>Show source in abc_builder.py:268</p> <p>Set the concentration of the particle in kg/m^3.</p>"},{"location":"Source-Code/particula/next/abc_builder/#arguments_2","title":"Arguments","text":"<ul> <li>concentration (float or NDArray[float]): Concentration of the species or particle in the mixture.</li> <li>concentration_units (str, optional): Units of the concentration.     Default is 'kg/m^3'.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature_6","title":"Signature","text":"<pre><code>def set_concentration(\n    self,\n    concentration: Union[float, NDArray[np.float_]],\n    concentration_units: Optional[str] = \"kg/m^3\",\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_builder/#builderdensitymixin","title":"BuilderDensityMixin","text":"<p>Show source in abc_builder.py:154</p> <p>Mixin class for Builder classes to set density and density_units.</p>"},{"location":"Source-Code/particula/next/abc_builder/#methods_2","title":"Methods","text":"<ul> <li><code>-</code> set_density(density - float, density_units: str): Set the density     attribute and units.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature_7","title":"Signature","text":"<pre><code>class BuilderDensityMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_builder/#builderdensitymixinset_density","title":"BuilderDensityMixin().set_density","text":"<p>Show source in abc_builder.py:166</p> <p>Set the density of the particle in kg/m^3.</p>"},{"location":"Source-Code/particula/next/abc_builder/#arguments_3","title":"Arguments","text":"<ul> <li>density (float or NDArray[float]): Density of the particle [kg/m^3].</li> <li>density_units (str, optional): Units of the density. Default is     'kg/m^3'.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature_8","title":"Signature","text":"<pre><code>def set_density(\n    self,\n    density: Union[float, NDArray[np.float_]],\n    density_units: Optional[str] = \"kg/m^3\",\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_builder/#buildermolarmassmixin","title":"BuilderMolarMassMixin","text":"<p>Show source in abc_builder.py:221</p> <p>Mixin class for Builder classes to set molar_mass and molar_mass_units.</p>"},{"location":"Source-Code/particula/next/abc_builder/#methods_3","title":"Methods","text":"<ul> <li><code>-</code> set_molar_mass(molar_mass - float, molar_mass_units: str): Set the     molar_mass attribute and units.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature_9","title":"Signature","text":"<pre><code>class BuilderMolarMassMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_builder/#buildermolarmassmixinset_molar_mass","title":"BuilderMolarMassMixin().set_molar_mass","text":"<p>Show source in abc_builder.py:233</p> <p>Set the molar mass of the particle in kg/mol.</p>"},{"location":"Source-Code/particula/next/abc_builder/#arguments_4","title":"Arguments","text":"<ul> <li>molar_mass (float or NDArray[float]): Molar mass of the particle     [kg/mol].</li> <li>molar_mass_units (str, optional): Units of the molar mass. Default is     'kg/mol'.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature_10","title":"Signature","text":"<pre><code>def set_molar_mass(\n    self,\n    molar_mass: Union[float, NDArray[np.float_]],\n    molar_mass_units: Optional[str] = \"kg/mol\",\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_builder/#buildersurfacetensionmixin","title":"BuilderSurfaceTensionMixin","text":"<p>Show source in abc_builder.py:186</p> <p>Mixin class for Builder classes to set surface_tension and surface_tension_units.</p>"},{"location":"Source-Code/particula/next/abc_builder/#methods_4","title":"Methods","text":"<ul> <li><code>-</code> set_surface_tension(surface_tension - float, surface_tension_units: str):     Set the surface_tension attribute and units.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature_11","title":"Signature","text":"<pre><code>class BuilderSurfaceTensionMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_builder/#buildersurfacetensionmixinset_surface_tension","title":"BuilderSurfaceTensionMixin().set_surface_tension","text":"<p>Show source in abc_builder.py:199</p> <p>Set the surface tension of the particle in N/m.</p>"},{"location":"Source-Code/particula/next/abc_builder/#arguments_5","title":"Arguments","text":"<ul> <li>surface_tension (float or NDArray[float]): Surface tension of the     particle [N/m].</li> <li>surface_tension_units (str, optional): Units of the surface tension.     Default is 'N/m'.</li> </ul>"},{"location":"Source-Code/particula/next/abc_builder/#signature_12","title":"Signature","text":"<pre><code>def set_surface_tension(\n    self,\n    surface_tension: Union[float, NDArray[np.float_]],\n    surface_tension_units: Optional[str] = \"N/m\",\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_factory/","title":"Abc Factory","text":"<p>Particula Index / Particula / Next / Abc Factory</p> <p>Auto-generated documentation for particula.next.abc_factory module.</p>"},{"location":"Source-Code/particula/next/abc_factory/#attributes","title":"Attributes","text":"<ul> <li><code>BuilderT</code> - Define a generic type variable for the strategy type, to get good type hints: TypeVar('BuilderT')</li> </ul>"},{"location":"Source-Code/particula/next/abc_factory/#strategyfactory","title":"StrategyFactory","text":"<p>Show source in abc_factory.py:18</p> <p>Abstract base class for strategy factories.</p>"},{"location":"Source-Code/particula/next/abc_factory/#signature","title":"Signature","text":"<pre><code>class StrategyFactory(ABC, Generic[BuilderT, StrategyT]): ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_factory/#see-also","title":"See also","text":"<ul> <li>BuilderT</li> <li>StrategyT</li> </ul>"},{"location":"Source-Code/particula/next/abc_factory/#strategyfactoryget_builders","title":"StrategyFactory().get_builders","text":"<p>Show source in abc_factory.py:23</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"Source-Code/particula/next/abc_factory/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef get_builders(self) -&gt; Dict[str, BuilderT]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_factory/#see-also_1","title":"See also","text":"<ul> <li>BuilderT</li> </ul>"},{"location":"Source-Code/particula/next/abc_factory/#strategyfactoryget_strategy","title":"StrategyFactory().get_strategy","text":"<p>Show source in abc_factory.py:29</p> <p>Generic factory method to create strategies.</p>"},{"location":"Source-Code/particula/next/abc_factory/#signature_2","title":"Signature","text":"<pre><code>def get_strategy(\n    self, strategy_type: str, parameters: Optional[Dict[str, Any]] = None\n) -&gt; StrategyT: ...\n</code></pre>"},{"location":"Source-Code/particula/next/abc_factory/#see-also_2","title":"See also","text":"<ul> <li>StrategyT</li> </ul>"},{"location":"Source-Code/particula/next/aerosol/","title":"Aerosol","text":"<p>Particula Index / Particula / Next / Aerosol</p> <p>Auto-generated documentation for particula.next.aerosol module.</p>"},{"location":"Source-Code/particula/next/aerosol/#aerosol_1","title":"Aerosol","text":"<p>Show source in aerosol.py:13</p> <p>A class for interacting with collections of Gas and Particle objects. Allows for the representation and manipulation of an aerosol, which is composed of various gases and particles.</p>"},{"location":"Source-Code/particula/next/aerosol/#signature","title":"Signature","text":"<pre><code>class Aerosol:\n    def __init__(\n        self,\n        gas: Atmosphere,\n        particles: Union[ParticleRepresentation, List[ParticleRepresentation]],\n    ): ...\n</code></pre>"},{"location":"Source-Code/particula/next/aerosol/#see-also","title":"See also","text":"<ul> <li>Atmosphere</li> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/aerosol/#aerosoladd_gas","title":"Aerosol().add_gas","text":"<p>Show source in aerosol.py:55</p> <p>Replaces the current Gas instance with a new one.</p>"},{"location":"Source-Code/particula/next/aerosol/#arguments","title":"Arguments","text":"<ul> <li>gas (Gas): The Gas instance to replace the current one.</li> </ul>"},{"location":"Source-Code/particula/next/aerosol/#signature_1","title":"Signature","text":"<pre><code>def add_gas(self, gas: Atmosphere): ...\n</code></pre>"},{"location":"Source-Code/particula/next/aerosol/#see-also_1","title":"See also","text":"<ul> <li>Atmosphere</li> </ul>"},{"location":"Source-Code/particula/next/aerosol/#aerosoladd_particle","title":"Aerosol().add_particle","text":"<p>Show source in aerosol.py:64</p> <p>Adds a Particle instance to the aerosol.</p>"},{"location":"Source-Code/particula/next/aerosol/#arguments_1","title":"Arguments","text":"<ul> <li>particle (Particle): The Particle instance to add.</li> </ul>"},{"location":"Source-Code/particula/next/aerosol/#signature_2","title":"Signature","text":"<pre><code>def add_particle(self, particle: ParticleRepresentation): ...\n</code></pre>"},{"location":"Source-Code/particula/next/aerosol/#see-also_2","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/aerosol/#aerosoliterate_gas","title":"Aerosol().iterate_gas","text":"<p>Show source in aerosol.py:37</p> <p>Returns an iterator for gas species.</p>"},{"location":"Source-Code/particula/next/aerosol/#returns","title":"Returns","text":"<ul> <li><code>Iterator[GasSpecies]</code> - An iterator over the gas species type.</li> </ul>"},{"location":"Source-Code/particula/next/aerosol/#signature_3","title":"Signature","text":"<pre><code>def iterate_gas(self) -&gt; Iterator[GasSpecies]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/aerosol/#see-also_3","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"Source-Code/particula/next/aerosol/#aerosoliterate_particle","title":"Aerosol().iterate_particle","text":"<p>Show source in aerosol.py:46</p> <p>Returns an iterator for particle.</p>"},{"location":"Source-Code/particula/next/aerosol/#returns_1","title":"Returns","text":"<ul> <li><code>Iterator[Particle]</code> - An iterator over the particle type.</li> </ul>"},{"location":"Source-Code/particula/next/aerosol/#signature_4","title":"Signature","text":"<pre><code>def iterate_particle(self) -&gt; Iterator[ParticleRepresentation]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/aerosol/#see-also_4","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/runnable/","title":"Runnable","text":"<p>Particula Index / Particula / Next / Runnable</p> <p>Auto-generated documentation for particula.next.runnable module.</p>"},{"location":"Source-Code/particula/next/runnable/#runnable_1","title":"Runnable","text":"<p>Show source in runnable.py:10</p> <p>Runnable process that can modify an aerosol instance.</p> <p>Parameters: None</p>"},{"location":"Source-Code/particula/next/runnable/#methods","title":"Methods","text":"<ul> <li><code>-</code> rate - Return the rate of the process.</li> <li><code>-</code> execute - Execute the process and modify the aerosol instance.</li> <li><code>-</code> or - Chain this process with another process using the | operator.</li> </ul>"},{"location":"Source-Code/particula/next/runnable/#signature","title":"Signature","text":"<pre><code>class Runnable(ABC): ...\n</code></pre>"},{"location":"Source-Code/particula/next/runnable/#runnableor","title":"Runnable().or","text":"<p>Show source in runnable.py:36</p> <p>Chain this process with another process using the | operator.</p>"},{"location":"Source-Code/particula/next/runnable/#signature_1","title":"Signature","text":"<pre><code>def __or__(self, other: \"Runnable\"): ...\n</code></pre>"},{"location":"Source-Code/particula/next/runnable/#runnableexecute","title":"Runnable().execute","text":"<p>Show source in runnable.py:28</p> <p>Execute the process and modify the aerosol instance.</p>"},{"location":"Source-Code/particula/next/runnable/#arguments","title":"Arguments","text":"<ul> <li>aerosol (Aerosol): The aerosol instance to modify.</li> <li>time_step (float): The time step for the process in seconds.</li> </ul>"},{"location":"Source-Code/particula/next/runnable/#signature_2","title":"Signature","text":"<pre><code>@abstractmethod\ndef execute(self, aerosol: Aerosol, time_step: float) -&gt; Aerosol: ...\n</code></pre>"},{"location":"Source-Code/particula/next/runnable/#see-also","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"Source-Code/particula/next/runnable/#runnablerate","title":"Runnable().rate","text":"<p>Show source in runnable.py:21</p> <p>Return the rate of the process.</p>"},{"location":"Source-Code/particula/next/runnable/#arguments_1","title":"Arguments","text":"<ul> <li>aerosol (Aerosol): The aerosol instance to modify.</li> </ul>"},{"location":"Source-Code/particula/next/runnable/#signature_3","title":"Signature","text":"<pre><code>@abstractmethod\ndef rate(self, aerosol: Aerosol) -&gt; Any: ...\n</code></pre>"},{"location":"Source-Code/particula/next/runnable/#see-also_1","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"Source-Code/particula/next/runnable/#runnablesequence","title":"RunnableSequence","text":"<p>Show source in runnable.py:45</p> <p>A sequence of processes to be executed in order.</p>"},{"location":"Source-Code/particula/next/runnable/#attributes","title":"Attributes","text":"<ul> <li>processes (List[Runnable]): A list of RunnableProcess objects.</li> </ul>"},{"location":"Source-Code/particula/next/runnable/#methods_1","title":"Methods","text":"<ul> <li><code>-</code> add_process - Add a process to the sequence.</li> <li><code>-</code> execute - Execute the sequence of processes on an aerosol instance.</li> <li><code>-</code> or - Add a process to the sequence using the | operator.</li> </ul>"},{"location":"Source-Code/particula/next/runnable/#signature_4","title":"Signature","text":"<pre><code>class RunnableSequence:\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/runnable/#runnablesequenceor","title":"RunnableSequence().or","text":"<p>Show source in runnable.py:70</p> <p>Add a runnable to the sequence using the | operator.</p>"},{"location":"Source-Code/particula/next/runnable/#signature_5","title":"Signature","text":"<pre><code>def __or__(self, process: Runnable): ...\n</code></pre>"},{"location":"Source-Code/particula/next/runnable/#see-also_2","title":"See also","text":"<ul> <li>Runnable</li> </ul>"},{"location":"Source-Code/particula/next/runnable/#runnablesequenceadd_process","title":"RunnableSequence().add_process","text":"<p>Show source in runnable.py:59</p> <p>Add a process to the sequence.</p>"},{"location":"Source-Code/particula/next/runnable/#signature_6","title":"Signature","text":"<pre><code>def add_process(self, process: Runnable): ...\n</code></pre>"},{"location":"Source-Code/particula/next/runnable/#see-also_3","title":"See also","text":"<ul> <li>Runnable</li> </ul>"},{"location":"Source-Code/particula/next/runnable/#runnablesequenceexecute","title":"RunnableSequence().execute","text":"<p>Show source in runnable.py:63</p> <p>Execute the sequence of runnables on an aerosol instance.</p>"},{"location":"Source-Code/particula/next/runnable/#signature_7","title":"Signature","text":"<pre><code>def execute(self, aerosol: Aerosol, time_step: float) -&gt; Aerosol: ...\n</code></pre>"},{"location":"Source-Code/particula/next/runnable/#see-also_4","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/","title":"Dynamics","text":"<p>Particula Index / Particula / Next / Dynamics</p> <p>Auto-generated documentation for particula.next.dynamics module.</p>"},{"location":"Source-Code/particula/next/dynamics/#modules","title":"Modules","text":"<ul> <li>Coagulation</li> <li>Condensation</li> <li>Particle Process</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/","title":"Condensation","text":"<p>Particula Index / Particula / Next / Dynamics / Condensation</p> <p>Auto-generated documentation for particula.next.dynamics.condensation module.</p>"},{"location":"Source-Code/particula/next/dynamics/condensation/#condensationisothermal","title":"CondensationIsothermal","text":"<p>Show source in condensation.py:306</p> <p>Condensation strategy for isothermal conditions, where the temperature remains constant. This class implements the mass transfer rate calculation for condensation of particles based on partial pressures. No Latent heat of vaporization effect is considered.</p>"},{"location":"Source-Code/particula/next/dynamics/condensation/#signature","title":"Signature","text":"<pre><code>class CondensationIsothermal(CondensationStrategy):\n    def __init__(\n        self,\n        molar_mass: Union[float, NDArray[np.float_]],\n        diffusion_coefficient: Union[float, NDArray[np.float_]] = 2 * 1e-09,\n        accommodation_coefficient: Union[float, NDArray[np.float_]] = 1.0,\n    ): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/condensation/#see-also","title":"See also","text":"<ul> <li>CondensationStrategy</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#condensationisothermalmass_transfer_rate","title":"CondensationIsothermal().mass_transfer_rate","text":"<p>Show source in condensation.py:325</p>"},{"location":"Source-Code/particula/next/dynamics/condensation/#signature_1","title":"Signature","text":"<pre><code>def mass_transfer_rate(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/condensation/#see-also_1","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#condensationstrategy","title":"CondensationStrategy","text":"<p>Show source in condensation.py:122</p> <p>Abstract class for mass transfer strategies, for condensation or evaporation of particles. This class should be subclassed to implement specific mass transfer strategies.</p>"},{"location":"Source-Code/particula/next/dynamics/condensation/#arguments","title":"Arguments","text":"<ul> <li>molar_mass (Union[float, NDArray[np.float_]]): The molar mass of the species [kg/mol]. If a single value is provided, it will be used for all species.</li> <li>diffusion_coefficient (Union[float, NDArray[np.float_]]): The diffusion coefficient of the species [m^2/s]. If a single value is provided, it will be used for all species. Default is 2*1e-9 m^2/s for air.</li> <li>accommodation_coefficient (Union[float, NDArray[np.float_]]): The mass accommodation coefficient of the species. If a single value is provided, it will be used for all species. Default is 1.0.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#signature_2","title":"Signature","text":"<pre><code>class CondensationStrategy(ABC):\n    def __init__(\n        self,\n        molar_mass: Union[float, NDArray[np.float_]],\n        diffusion_coefficient: Union[float, NDArray[np.float_]] = 2 * 1e-09,\n        accommodation_coefficient: Union[float, NDArray[np.float_]] = 1.0,\n    ): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/condensation/#condensationstrategyfirst_order_mass_transport","title":"CondensationStrategy().first_order_mass_transport","text":"<p>Show source in condensation.py:225</p> <p>Calculate the first-order mass transport coefficient, K, for a given particle based on the diffusion coefficient, radius, and vapor transition correction factor.</p>"},{"location":"Source-Code/particula/next/dynamics/condensation/#arguments_1","title":"Arguments","text":"<ul> <li>radius (Union[float, NDArray[np.float_]]): The radius of the particle [m].</li> <li>temperature (float): The temperature at which the first-order mass transport coefficient is to be calculated.</li> <li>pressure (float): The pressure of the gas phase.</li> <li>dynamic_viscosity (Optional[float]): The dynamic viscosity of the gas [Pa*s]. If not provided, it will be calculated based on the temperature</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The first-order mass transport coefficient per particle (m^3/s).</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#references","title":"References","text":"<ul> <li>Aerosol Modeling, Chapter 2, Equation 2.49 (excluding particle number)</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#signature_3","title":"Signature","text":"<pre><code>def first_order_mass_transport(\n    self,\n    radius: Union[float, NDArray[np.float_]],\n    temperature: float,\n    pressure: float,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/condensation/#condensationstrategyknudsen_number","title":"CondensationStrategy().knudsen_number","text":"<p>Show source in condensation.py:187</p> <p>Calculate the Knudsen number based on the mean free path of the gas molecules and the radius of the particle.</p>"},{"location":"Source-Code/particula/next/dynamics/condensation/#arguments_2","title":"Arguments","text":"<ul> <li>radius (Union[float, NDArray[np.float_]]): The radius of the particle [m].</li> <li>temperature (float): The temperature of the gas [K].</li> <li>pressure (float): The pressure of the gas [Pa].</li> <li>dynamic_viscosity (Optional[float]): The dynamic viscosity of the gas [Pa*s]. If not provided, it will be calculated based on the temperature</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#returns_1","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The Knudsen number, which is the ratio of the mean free path to the particle radius.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#references_1","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Knudsen_number</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#signature_4","title":"Signature","text":"<pre><code>def knudsen_number(\n    self,\n    radius: Union[float, NDArray[np.float_]],\n    temperature: float,\n    pressure: float,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/condensation/#condensationstrategymass_transfer_rate","title":"CondensationStrategy().mass_transfer_rate","text":"<p>Show source in condensation.py:272</p> <p>Calculate the mass transfer rate based on the difference in partial pressure and the first-order mass transport coefficient.</p>"},{"location":"Source-Code/particula/next/dynamics/condensation/#arguments_3","title":"Arguments","text":"<ul> <li>particle (Particle class): The particle for which the mass transfer rate is to be calculated.</li> <li>gas_species (GasSpecies class): The gas species with which the particle is in contact.</li> <li>temperature (float): The temperature at which the mass transfer rate is to be calculated.</li> <li>pressure (float): The pressure of the gas phase.</li> <li>dynamic_viscosity (Optional[float]): The dynamic viscosity of the gas [Pa*s]. If not provided, it will be calculated based on the temperature</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#returns_2","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The mass transfer rate for the particle [kg/s].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#signature_5","title":"Signature","text":"<pre><code>@abstractmethod\ndef mass_transfer_rate(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/condensation/#see-also_2","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#condensationstrategymean_free_path","title":"CondensationStrategy().mean_free_path","text":"<p>Show source in condensation.py:152</p> <p>Calculate the mean free path of the gas molecules based on the temperature, pressure, and dynamic viscosity of the gas.</p>"},{"location":"Source-Code/particula/next/dynamics/condensation/#arguments_4","title":"Arguments","text":"<ul> <li>temperature (float): The temperature of the gas [K].</li> <li>pressure (float): The pressure of the gas [Pa].</li> <li>dynamic_viscosity (Optional[float]): The dynamic viscosity of the gas [Pa*s]. If not provided, it will be calculated based on the temperature</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#returns_3","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The mean free path of the gas molecules in meters (m).</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#references_2","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Mean_free_path</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#signature_6","title":"Signature","text":"<pre><code>def mean_free_path(\n    self, temperature: float, pressure: float, dynamic_viscosity: Optional[float] = None\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/condensation/#first_order_mass_transport_k","title":"first_order_mass_transport_k","text":"<p>Show source in condensation.py:53</p> <p>Calculate the first-order mass transport coefficient, K, for a given radius diffusion coefficient, and vapor transition correction factor. For a single particle.</p>"},{"location":"Source-Code/particula/next/dynamics/condensation/#arguments_5","title":"Arguments","text":"<ul> <li>radius (Union[float, NDArray[np.float_]]): The radius of the particle [m].</li> <li>diffusion_coefficient (Union[float, NDArray[np.float_]]): The diffusion coefficient of the vapor [m^2/s], default to air.</li> <li>vapor_transition (Union[float, NDArray[np.float_]]): The vapor transition correction factor. [unitless]</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#returns_4","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The first-order mass transport coefficient per particle (m^3/s).</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#references_3","title":"References","text":"<ul> <li>Aerosol Modeling, Chapter 2, Equation 2.49 (excluding particle number)</li> <li>https://en.wikipedia.org/wiki/Mass_diffusivity</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#signature_7","title":"Signature","text":"<pre><code>def first_order_mass_transport_k(\n    radius: Union[float, NDArray[np.float_]],\n    vapor_transition: Union[float, NDArray[np.float_]],\n    diffusion_coefficient: Union[float, NDArray[np.float_]] = 2 * 1e-09,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/condensation/#mass_transfer_rate","title":"mass_transfer_rate","text":"<p>Show source in condensation.py:85</p> <p>Calculate the mass transfer rate based on the difference in partial pressure and the first-order mass transport coefficient.</p>"},{"location":"Source-Code/particula/next/dynamics/condensation/#arguments_6","title":"Arguments","text":"<ul> <li>pressure_delta (Union[float, NDArray[np.float_]]): The difference in partial pressure between the gas phase and the particle phase.</li> <li>first_order_mass_transport (Union[float, NDArray[np.float_]]): The first-order mass transport coefficient per particle.</li> <li>temperature (Union[float, NDArray[np.float_]]): The temperature at which the mass transfer rate is to be calculated.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#returns_5","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The mass transfer rate for the particle [kg/s].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#references_4","title":"References","text":"<ul> <li>Aerosol Modeling, Chapter 2, Equation 2.41 (excluding particle number)</li> <li>Seinfeld and Pandis, \"Atmospheric Chemistry and Physics\", Equation 13.3</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/condensation/#signature_8","title":"Signature","text":"<pre><code>def mass_transfer_rate(\n    pressure_delta: Union[float, NDArray[np.float_]],\n    first_order_mass_transport: Union[float, NDArray[np.float_]],\n    temperature: Union[float, NDArray[np.float_]],\n    molar_mass: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/particle_process/","title":"Particle Process","text":"<p>Particula Index / Particula / Next / Dynamics / Particle Process</p> <p>Auto-generated documentation for particula.next.dynamics.particle_process module.</p>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#coagulation","title":"Coagulation","text":"<p>Show source in particle_process.py:102</p> <p>A class for running a coagulation strategy.</p>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#arguments","title":"Arguments","text":"<ul> <li>coagulation_strategy (CoagulationStrategy): The coagulation strategy to use.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#methods","title":"Methods","text":"<ul> <li><code>-</code> execute - Execute the coagulation process.</li> <li><code>-</code> rate - Calculate the rate of coagulation for each particle.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#signature","title":"Signature","text":"<pre><code>class Coagulation(Runnable):\n    def __init__(self, coagulation_strategy: CoagulationStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#see-also","title":"See also","text":"<ul> <li>CoagulationStrategy</li> <li>Runnable</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#coagulationexecute","title":"Coagulation().execute","text":"<p>Show source in particle_process.py:120</p> <p>Execute the coagulation process.</p>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#arguments_1","title":"Arguments","text":"<ul> <li>aerosol (Aerosol): The aerosol instance to modify.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#signature_1","title":"Signature","text":"<pre><code>def execute(self, aerosol: Aerosol, time_step: float) -&gt; Aerosol: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#see-also_1","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#coagulationrate","title":"Coagulation().rate","text":"<p>Show source in particle_process.py:140</p> <p>Calculate the rate of coagulation for each particle.</p>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#arguments_2","title":"Arguments","text":"<ul> <li>aerosol (Aerosol): The aerosol instance to modify.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#returns","title":"Returns","text":"<ul> <li><code>-</code> np.ndarray - An array of coagulation rates for each particle.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#signature_2","title":"Signature","text":"<pre><code>def rate(self, aerosol: Aerosol) -&gt; Any: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#see-also_2","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#masscondensation","title":"MassCondensation","text":"<p>Show source in particle_process.py:15</p> <p>A class for running a mass condensation process.</p>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#arguments_3","title":"Arguments","text":"<ul> <li>condensation_strategy (CondensationStrategy): The condensation strategy to use.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#methods_1","title":"Methods","text":"<ul> <li><code>-</code> execute - Execute the mass condensation process.</li> <li><code>-</code> rate - Calculate the rate of mass condensation for each particle due to each condensable gas species.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#signature_3","title":"Signature","text":"<pre><code>class MassCondensation(Runnable):\n    def __init__(self, condensation_strategy: CondensationStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#see-also_3","title":"See also","text":"<ul> <li>CondensationStrategy</li> <li>Runnable</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#masscondensationexecute","title":"MassCondensation().execute","text":"<p>Show source in particle_process.py:34</p> <p>Execute the mass condensation process.</p>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#arguments_4","title":"Arguments","text":"<ul> <li>aerosol (Aerosol): The aerosol instance to modify.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#signature_4","title":"Signature","text":"<pre><code>def execute(self, aerosol: Aerosol, time_step: float) -&gt; Aerosol: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#see-also_4","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#masscondensationrate","title":"MassCondensation().rate","text":"<p>Show source in particle_process.py:69</p> <p>Calculate the rate of mass condensation for each particle due to each condensable gas species.</p>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#arguments_5","title":"Arguments","text":"<ul> <li>aerosol (Aerosol): The aerosol instance to modify.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#returns_1","title":"Returns","text":"<ul> <li><code>-</code> np.ndarray - An array of condensation rates for each particle.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#signature_5","title":"Signature","text":"<pre><code>def rate(self, aerosol: Aerosol) -&gt; Any: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/particle_process/#see-also_5","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/","title":"Coagulation","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation module.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/#modules","title":"Modules","text":"<ul> <li>Brownian Kernel</li> <li>Kernel</li> <li>Rate</li> <li>Strategy</li> <li>Transition Regime</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/","title":"Brownian Kernel","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation / Brownian Kernel</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation.brownian_kernel module.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#brownian_coagulation_kernel","title":"brownian_coagulation_kernel","text":"<p>Show source in brownian_kernel.py:103</p> <p>Returns the Brownian coagulation kernel for aerosol particles. Defined as the product of the diffusivity of the particles, the collection term <code>g</code>, and the radius of the particles.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#args","title":"Args","text":"<p>radius_particle : The radius of the particles [m]. diffusivity_particle : The diffusivity of the particles [m^2/s]. g_collection_term_particle : The collection term for Brownian coagulation [dimensionless]. alpha_collision_efficiency : The collision efficiency of the particles [dimensionless].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#returns","title":"Returns","text":"<p>Square matrix of Brownian coagulation kernel for aerosol particles [m^3/s].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#references","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12 (with alpha collision efficiency term 13.56)</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#signature","title":"Signature","text":"<pre><code>def brownian_coagulation_kernel(\n    radius_particle: Union[float, NDArray[np.float_]],\n    diffusivity_particle: Union[float, NDArray[np.float_]],\n    g_collection_term_particle: Union[float, NDArray[np.float_]],\n    mean_thermal_speed_particle: Union[float, NDArray[np.float_]],\n    alpha_collision_efficiency: Union[float, NDArray[np.float_]] = 1.0,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#brownian_coagulation_kernel_via_system_state","title":"brownian_coagulation_kernel_via_system_state","text":"<p>Show source in brownian_kernel.py:169</p> <p>Returns the Brownian coagulation kernel for aerosol particles. Calculating the intermediate properties needed.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#args_1","title":"Args","text":"<p>radius_particle : The radius of the particles [m]. mass_particle : The mass of the particles [kg]. temperature : The temperature of the air [K]. pressure : The pressure of the air [Pa]. alpha_collision_efficiency : The collision efficiency of the particles [dimensionless].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#returns_1","title":"Returns","text":"<p>Square matrix of Brownian coagulation kernel for aerosol particles [m^3/s].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#references_1","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#signature_1","title":"Signature","text":"<pre><code>def brownian_coagulation_kernel_via_system_state(\n    radius_particle: Union[float, NDArray[np.float_]],\n    mass_particle: Union[float, NDArray[np.float_]],\n    temperature: float,\n    pressure: float,\n    alpha_collision_efficiency: Union[float, NDArray[np.float_]] = 1.0,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#brownian_diffusivity","title":"brownian_diffusivity","text":"<p>Show source in brownian_kernel.py:78</p> <p>Returns the diffusivity of the particles due to Brownian motion. Which is just the scaled aerodynamic mobility of the particles.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#args_2","title":"Args","text":"<ul> <li>temperature : The temperature of the air [K].</li> <li>aerodynamic_mobility : The aerodynamic mobility of the particles [m^2/s].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#returns_2","title":"Returns","text":"<p>The diffusivity of the particles due to Brownian motion [m^2/s].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#references_2","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#signature_2","title":"Signature","text":"<pre><code>def brownian_diffusivity(\n    temperature: Union[float, NDArray[np.float_]],\n    aerodynamic_mobility: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#g_collection_term","title":"g_collection_term","text":"<p>Show source in brownian_kernel.py:45</p> <p>Returns the <code>g</code> collection term for Brownian coagulation. Defined as the ratio of the mean free path of the particles to the radius of the particles.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#args_3","title":"Args","text":"<p>mean_free_path_particle : The mean free path of the particles [m]. radius_particle : The radius of the particles [m].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#returns_3","title":"Returns","text":"<p>The collection term for Brownian coagulation [dimensionless].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#references_3","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12</p> <p>The np.sqrt(2) term appears to be an error in the text, as the term is not used in the second edition of the book. And when it it is used, the values are too small, by about 2x.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#signature_3","title":"Signature","text":"<pre><code>def g_collection_term(\n    mean_free_path_particle: Union[float, NDArray[np.float_]],\n    radius_particle: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#mean_free_path_l","title":"mean_free_path_l","text":"<p>Show source in brownian_kernel.py:16</p> <p>Calculate the mean free path of particles, defined for Brownian coagulation as the ratio of the diffusivity of the particles to their mean thermal speed. This parameter is crucial for understanding particle dynamics in a fluid.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#arguments","title":"Arguments","text":"<ul> <li>diffusivity_particle : The diffusivity of the particles [m^2/s].</li> <li>mean_thermal_speed_particle : The mean thermal speed of the particles [m/s].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#returns_4","title":"Returns","text":"<p>The mean free path of the particles [m].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#references_4","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/brownian_kernel/#signature_4","title":"Signature","text":"<pre><code>def mean_free_path_l(\n    diffusivity_particle: Union[float, NDArray[np.float_]],\n    mean_thermal_speed_particle: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/","title":"Kernel","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation / Kernel</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation.kernel module.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#coulombdyachkov2007","title":"CoulombDyachkov2007","text":"<p>Show source in kernel.py:129</p> <p>Dyachkov et al. (2007) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#references","title":"References","text":"<ul> <li>Dyachkov, S. A., Kustova, E. V., &amp; Kustov, A. V. (2007). Coagulation of particles in the transition regime: The effect of the Coulomb potential. Journal of Chemical Physics, 126(12). https://doi.org/10.1063/1.2713719</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature","title":"Signature","text":"<pre><code>class CoulombDyachkov2007(KernelStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#see-also","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#coulombdyachkov2007dimensionless","title":"CoulombDyachkov2007().dimensionless","text":"<p>Show source in kernel.py:142</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature_1","title":"Signature","text":"<pre><code>def dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float_],\n    coulomb_potential_ratio: NDArray[np.float_],\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#coulombgatti2008","title":"CoulombGatti2008","text":"<p>Show source in kernel.py:153</p> <p>Gatti and Kortshagen (2008) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#references_1","title":"References","text":"<ul> <li>Gatti, M., &amp; Kortshagen, U. (2008). Analytical model of particle charging in plasmas over a wide range of collisionality. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 78(4). https://doi.org/10.1103/PhysRevE.78.046402</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature_2","title":"Signature","text":"<pre><code>class CoulombGatti2008(KernelStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#see-also_1","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#coulombgatti2008dimensionless","title":"CoulombGatti2008().dimensionless","text":"<p>Show source in kernel.py:166</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature_3","title":"Signature","text":"<pre><code>def dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float_],\n    coulomb_potential_ratio: NDArray[np.float_],\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#coulombgopalakrishnan2012","title":"CoulombGopalakrishnan2012","text":"<p>Show source in kernel.py:177</p> <p>Gopalakrishnan and Hogan (2012) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#references_2","title":"References","text":"<ul> <li>Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature_4","title":"Signature","text":"<pre><code>class CoulombGopalakrishnan2012(KernelStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#see-also_2","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#coulombgopalakrishnan2012dimensionless","title":"CoulombGopalakrishnan2012().dimensionless","text":"<p>Show source in kernel.py:190</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature_5","title":"Signature","text":"<pre><code>def dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float_],\n    coulomb_potential_ratio: NDArray[np.float_],\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#coulumbchahl2019","title":"CoulumbChahl2019","text":"<p>Show source in kernel.py:201</p> <p>Chahl and Gopalakrishnan (2019) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#references_3","title":"References","text":"<ul> <li>Chahl, H. S., &amp; Gopalakrishnan, R. (2019). High potential, near free molecular regime Coulombic collisions in aerosols and dusty plasmas. Aerosol Science and Technology, 53(8), 933-957. https://doi.org/10.1080/02786826.2019.1614522</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature_6","title":"Signature","text":"<pre><code>class CoulumbChahl2019(KernelStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#see-also_3","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#coulumbchahl2019dimensionless","title":"CoulumbChahl2019().dimensionless","text":"<p>Show source in kernel.py:214</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature_7","title":"Signature","text":"<pre><code>def dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float_],\n    coulomb_potential_ratio: NDArray[np.float_],\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#hardsphere","title":"HardSphere","text":"<p>Show source in kernel.py:116</p> <p>Hard sphere dimensionless coagulation strategy.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature_8","title":"Signature","text":"<pre><code>class HardSphere(KernelStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#see-also_4","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#hardspheredimensionless","title":"HardSphere().dimensionless","text":"<p>Show source in kernel.py:121</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature_9","title":"Signature","text":"<pre><code>def dimensionless(\n    self, diffusive_knudsen: NDArray[np.float_], coulomb_potential_ratio: ignore\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#kernelstrategy","title":"KernelStrategy","text":"<p>Show source in kernel.py:12</p> <p>Abstract class for dimensionless coagulation strategies. This class defines the dimensionless kernel (H) method that must be implemented by any dimensionless coagulation strategy.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#methods","title":"Methods","text":"<ul> <li>dimensionless (abstractmethod): Calculate the dimensionless coagulation kernel.</li> <li><code>-</code> kernel - Calculate the dimensioned coagulation kernel.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature_10","title":"Signature","text":"<pre><code>class KernelStrategy(ABC): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#kernelstrategydimensionless","title":"KernelStrategy().dimensionless","text":"<p>Show source in kernel.py:25</p> <p>Return the dimensionless coagulation kernel (H)</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#returns","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#references_4","title":"References","text":"<ul> <li>Dyachkov, S. A., Kustova, E. V., &amp; Kustov, A. V. (2007). Coagulation of particles in the transition regime: The effect of the Coulomb potential. Journal of Chemical Physics, 126(12). https://doi.org/10.1063/1.2713719</li> <li>Gatti, M., &amp; Kortshagen, U. (2008). Analytical model of particle charging in plasmas over a wide range of collisionality. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 78(4). https://doi.org/10.1103/PhysRevE.78.046402</li> <li>Gopalakrishnan, R., &amp; Hogan, C. J. (2011). Determination of the transition regime collision kernel from mean first passage times. Aerosol Science and Technology, 45(12), 1499-1509. https://doi.org/10.1080/02786826.2011.601775</li> <li>Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</li> <li>Chahl, H. S., &amp; Gopalakrishnan, R. (2019). High potential, near free molecular regime Coulombic collisions in aerosols and dusty plasmas. Aerosol Science and Technology, 53(8), 933-957. https://doi.org/10.1080/02786826.2019.1614522</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature_11","title":"Signature","text":"<pre><code>@abstractmethod\ndef dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float_],\n    coulomb_potential_ratio: NDArray[np.float_],\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#kernelstrategykernel","title":"KernelStrategy().kernel","text":"<p>Show source in kernel.py:68</p> <p>The dimensioned coagulation kernel for each particle pair, calculated from the dimensionless coagulation kernel and the reduced quantities. All inputs are square matrices, for all particle-particle interactions.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> dimensionless_kernel - The dimensionless coagulation kernel [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio [dimensionless].</li> <li><code>-</code> sum_of_radii - The sum of the radii of the particles [m].</li> <li><code>-</code> reduced_mass - The reduced mass of the particles [kg].</li> <li><code>-</code> reduced_friction_factor - The reduced friction factor of the particles [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#returns_1","title":"Returns","text":"<p>The dimensioned coagulation kernel, as a square matrix, of all particle-particle interactions [m^3/s].</p> <p>Check, were the /s comes from.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#references_5","title":"References","text":""},{"location":"Source-Code/particula/next/dynamics/coagulation/kernel/#signature_12","title":"Signature","text":"<pre><code>def kernel(\n    self,\n    dimensionless_kernel: NDArray[np.float_],\n    coulomb_potential_ratio: NDArray[np.float_],\n    sum_of_radii: NDArray[np.float_],\n    reduced_mass: NDArray[np.float_],\n    reduced_friction_factor: NDArray[np.float_],\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/","title":"Rate","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation / Rate</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation.rate module.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#continuous_gain","title":"continuous_gain","text":"<p>Show source in rate.py:111</p> <p>Calculate the coagulation gain rate, via the integration method.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> radius - The radius of the particles.</li> <li><code>-</code> concentration - The distribution of particles.</li> <li><code>-</code> kernel - The coagulation kernel.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#returns","title":"Returns","text":"<ul> <li>The coagulation gain rate.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#references","title":"References","text":"<ul> <li>This equation necessitates the use of a for-loop due to the convoluted use of different radii at different stages. This is the most expensive step of all coagulation calculations. Using <code>RectBivariateSpline</code> accelerates this significantly.</li> <li>Note, to estimate the kernel and distribution at (other_radius**3 - some_radius**3)*(\u2153) we use interporlation techniques.</li> <li>Seinfeld, J. H., &amp; Pandis, S. (2016). Atmospheric chemistry and physics, Chapter 13 Equations 13.61</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#signature","title":"Signature","text":"<pre><code>def continuous_gain(\n    radius: Union[float, NDArray[np.float_]],\n    concentration: Union[float, NDArray[np.float_]],\n    kernel: NDArray[np.float_],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#continuous_loss","title":"continuous_loss","text":"<p>Show source in rate.py:84</p> <p>Calculate the coagulation loss rate, via the integration method.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> radius - The radius of the particles.</li> <li><code>-</code> concentration - The distribution of particles.</li> <li><code>-</code> kernel - The coagulation kernel.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#returns_1","title":"Returns","text":"<ul> <li>The coagulation loss rate.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#references_1","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Chapter 13 Equations 13.61</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#signature_1","title":"Signature","text":"<pre><code>def continuous_loss(\n    radius: Union[float, NDArray[np.float_]],\n    concentration: Union[float, NDArray[np.float_]],\n    kernel: NDArray[np.float_],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#discrete_gain","title":"discrete_gain","text":"<p>Show source in rate.py:43</p> <p>Calculate the coagulation gain rate, via the summation method.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> concentration - The distribution of particles.</li> <li><code>-</code> kernel - The coagulation kernel.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#returns_2","title":"Returns","text":"<ul> <li>The coagulation gain rate.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#references_2","title":"References","text":"<ul> <li>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Chapter 13 Equations 13.61</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#signature_2","title":"Signature","text":"<pre><code>def discrete_gain(\n    concentration: Union[float, NDArray[np.float_]], kernel: NDArray[np.float_]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#discrete_loss","title":"discrete_loss","text":"<p>Show source in rate.py:19</p> <p>Calculate the coagulation loss rate, via the summation method.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#arguments_3","title":"Arguments","text":"<ul> <li><code>-</code> concentraiton - The distribution of particles.</li> <li><code>-</code> kernel - The coagulation kernel.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#returns_3","title":"Returns","text":"<ul> <li>The coagulation loss rate.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#references_3","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Chapter 13 Equations 13.61</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/rate/#signature_3","title":"Signature","text":"<pre><code>def discrete_loss(\n    concentration: Union[float, NDArray[np.float_]], kernel: NDArray[np.float_]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/","title":"Strategy","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation / Strategy</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation.strategy module.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#coagulationstrategy","title":"CoagulationStrategy","text":"<p>Show source in strategy.py:20</p> <p>Abstract class for defining a coagulation strategy. This class defines the methods that must be implemented by any coagulation strategy.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#methods","title":"Methods","text":"<ul> <li>kernel (abstractmethod): Calculate the coagulation kernel.</li> <li><code>-</code> loss_rate - Calculate the coagulation loss rate.</li> <li><code>-</code> gain_rate - Calculate the coagulation gain rate.</li> <li><code>-</code> net_rate - Calculate the net coagulation rate.</li> <li><code>-</code> diffusive_knudsen - Calculate the diffusive Knudsen number.</li> <li><code>-</code> coulomb_potential_ratio - Calculate the Coulomb potential ratio.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature","title":"Signature","text":"<pre><code>class CoagulationStrategy(ABC): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#coagulationstrategycoulomb_potential_ratio","title":"CoagulationStrategy().coulomb_potential_ratio","text":"<p>Show source in strategy.py:200</p> <p>Calculate the Coulomb potential ratio based on the particle properties and temperature.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#arguments","title":"Arguments","text":"<ul> <li>particle (Particle class): The particles for which the Coulomb potential ratio is to be calculated.</li> <li>temperature (float): The temperature of the gas phase [K].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#returns","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - The Coulomb potential ratio for the particle [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_1","title":"Signature","text":"<pre><code>def coulomb_potential_ratio(\n    self, particle: ParticleRepresentation, temperature: float\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#coagulationstrategydiffusive_knudsen","title":"CoagulationStrategy().diffusive_knudsen","text":"<p>Show source in strategy.py:159</p> <p>Calculate the diffusive Knudsen number based on the particle properties, temperature, and pressure.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#arguments_1","title":"Arguments","text":"<ul> <li>particle (Particle class): The particle for which the diffusive Knudsen number is to be calculated.</li> <li>temperature (float): The temperature of the gas phase [K].</li> <li>pressure (float): The pressure of the gas phase [Pa].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#returns_1","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - The diffusive Knudsen number for the particle [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_2","title":"Signature","text":"<pre><code>def diffusive_knudsen(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_1","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#coagulationstrategydimensionless_kernel","title":"CoagulationStrategy().dimensionless_kernel","text":"<p>Show source in strategy.py:35</p> <p>Calculate the dimensionless coagulation kernel based on the particle properties interactions, diffusive Knudsen number and Coulomb potential</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#arguments_2","title":"Arguments","text":"<ul> <li>diffusive_knudsen (NDArray[np.float_]): The diffusive Knudsen number for the particle [dimensionless].</li> <li>coulomb_potential_ratio (NDArray[np.float_]): The Coulomb potential ratio for the particle [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - The dimensionless coagulation kernel for the particle [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_3","title":"Signature","text":"<pre><code>@abstractmethod\ndef dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float_],\n    coulomb_potential_ratio: NDArray[np.float_],\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#coagulationstrategyfriction_factor","title":"CoagulationStrategy().friction_factor","text":"<p>Show source in strategy.py:226</p> <p>Calculate the friction factor based on the particle properties, temperature, and pressure.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#arguments_3","title":"Arguments","text":"<ul> <li>particle (Particle class): The particle for which the friction factor is to be calculated.</li> <li>temperature (float): The temperature of the gas phase [K].</li> <li>pressure (float): The pressure of the gas phase [Pa].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#returns_3","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - The friction factor for the particle [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_4","title":"Signature","text":"<pre><code>def friction_factor(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_2","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#coagulationstrategygain_rate","title":"CoagulationStrategy().gain_rate","text":"<p>Show source in strategy.py:104</p> <p>Calculate the coagulation gain rate based on the particle radius, distribution, and the coagulation kernel.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#arguments_4","title":"Arguments","text":"<ul> <li>particle (Particle class): The particle for which the coagulation gain rate is to be calculated.</li> <li>kernel (NDArray[np.float_]): The coagulation kernel.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#returns_4","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The coagulation gain rate for the particle [kg/s].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#notes","title":"Notes","text":"<p>May be abstracted to a separate module when different coagulation strategies are implemented (super droplet).</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_5","title":"Signature","text":"<pre><code>@abstractmethod\ndef gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float_]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_3","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#coagulationstrategykernel","title":"CoagulationStrategy().kernel","text":"<p>Show source in strategy.py:59</p> <p>Calculate the coagulation kernel based on the particle properties, temperature, and pressure.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#arguments_5","title":"Arguments","text":"<ul> <li>particle (Particle class): The particle for which the coagulation kernel is to be calculated.</li> <li>temperature (float): The temperature of the gas phase [K].</li> <li>pressure (float): The pressure of the gas phase [Pa].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#returns_5","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - The coagulation kernel for the particle [m^3/s].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_6","title":"Signature","text":"<pre><code>@abstractmethod\ndef kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_4","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#coagulationstrategyloss_rate","title":"CoagulationStrategy().loss_rate","text":"<p>Show source in strategy.py:82</p> <p>Calculate the coagulation loss rate based on the particle radius, distribution, and the coagulation kernel.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#arguments_6","title":"Arguments","text":"<ul> <li>particle (Particle class): The particle for which the coagulation loss rate is to be calculated.</li> <li>kernel (NDArray[np.float_]): The coagulation kernel.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#returns_6","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The coagulation loss rate for the particle [kg/s].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_7","title":"Signature","text":"<pre><code>@abstractmethod\ndef loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float_]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_5","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#coagulationstrategynet_rate","title":"CoagulationStrategy().net_rate","text":"<p>Show source in strategy.py:131</p> <p>Calculate the net coagulation rate based on the particle radius, distribution, and the coagulation kernel.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#arguments_7","title":"Arguments","text":"<ul> <li>particle (Particle class): The particle class for which the coagulation net rate is to be calculated.</li> <li>temperature (float): The temperature of the gas phase [K].</li> <li>pressure (float): The pressure of the gas phase [Pa].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#returns_7","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The net coagulation rate for the particle [kg/s].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_8","title":"Signature","text":"<pre><code>def net_rate(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_6","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#continuousgeneralpdf","title":"ContinuousGeneralPDF","text":"<p>Show source in strategy.py:426</p> <p>Continuous PDF coagulation strategy class. This class implements the methods defined in the CoagulationStrategy abstract class. The kernel strategy is passed as an argument to the class, should use a dimensionless kernel representation.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#methods_1","title":"Methods","text":"<ul> <li><code>-</code> kernel - Calculate the coagulation kernel.</li> <li><code>-</code> loss_rate - Calculate the coagulation loss rate.</li> <li><code>-</code> gain_rate - Calculate the coagulation gain rate.</li> <li><code>-</code> net_rate - Calculate the net coagulation rate.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_9","title":"Signature","text":"<pre><code>class ContinuousGeneralPDF(CoagulationStrategy):\n    def __init__(self, kernel_strategy: KernelStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_7","title":"See also","text":"<ul> <li>CoagulationStrategy</li> <li>KernelStrategy</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#continuousgeneralpdfdimensionless_kernel","title":"ContinuousGeneralPDF().dimensionless_kernel","text":"<p>Show source in strategy.py:444</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_10","title":"Signature","text":"<pre><code>def dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float_],\n    coulomb_potential_ratio: NDArray[np.float_],\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#continuousgeneralpdfgain_rate","title":"ContinuousGeneralPDF().gain_rate","text":"<p>Show source in strategy.py:506</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_11","title":"Signature","text":"<pre><code>def gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float_]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_8","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#continuousgeneralpdfkernel","title":"ContinuousGeneralPDF().kernel","text":"<p>Show source in strategy.py:454</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_12","title":"Signature","text":"<pre><code>def kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_9","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#continuousgeneralpdfloss_rate","title":"ContinuousGeneralPDF().loss_rate","text":"<p>Show source in strategy.py:494</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_13","title":"Signature","text":"<pre><code>def loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float_]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_10","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#discretegeneral","title":"DiscreteGeneral","text":"<p>Show source in strategy.py:330</p> <p>Discrete general coagulation strategy class. This class implements the methods defined in the CoagulationStrategy abstract class. The kernel strategy is passed as an argument to the class, to use a dimensionless kernel representation.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#attributes","title":"Attributes","text":"<ul> <li><code>-</code> kernel_strategy - The kernel strategy to be used for the coagulation, from the KernelStrategy class.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#methods_2","title":"Methods","text":"<ul> <li><code>-</code> kernel - Calculate the coagulation kernel.</li> <li><code>-</code> loss_rate - Calculate the coagulation loss rate.</li> <li><code>-</code> gain_rate - Calculate the coagulation gain rate.</li> <li><code>-</code> net_rate - Calculate the net coagulation rate.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_14","title":"Signature","text":"<pre><code>class DiscreteGeneral(CoagulationStrategy):\n    def __init__(self, kernel_strategy: KernelStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_11","title":"See also","text":"<ul> <li>CoagulationStrategy</li> <li>KernelStrategy</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#discretegeneraldimensionless_kernel","title":"DiscreteGeneral().dimensionless_kernel","text":"<p>Show source in strategy.py:353</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_15","title":"Signature","text":"<pre><code>def dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float_],\n    coulomb_potential_ratio: NDArray[np.float_],\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#discretegeneralgain_rate","title":"DiscreteGeneral().gain_rate","text":"<p>Show source in strategy.py:414</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_16","title":"Signature","text":"<pre><code>def gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float_]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_12","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#discretegeneralkernel","title":"DiscreteGeneral().kernel","text":"<p>Show source in strategy.py:363</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_17","title":"Signature","text":"<pre><code>def kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_13","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#discretegeneralloss_rate","title":"DiscreteGeneral().loss_rate","text":"<p>Show source in strategy.py:403</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_18","title":"Signature","text":"<pre><code>def loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float_]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_14","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#discretesimple","title":"DiscreteSimple","text":"<p>Show source in strategy.py:270</p> <p>Discrete Brownian coagulation strategy class. This class implements the methods defined in the CoagulationStrategy abstract class.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#methods_3","title":"Methods","text":"<ul> <li><code>-</code> kernel - Calculate the coagulation kernel.</li> <li><code>-</code> loss_rate - Calculate the coagulation loss rate.</li> <li><code>-</code> gain_rate - Calculate the coagulation gain rate.</li> <li><code>-</code> net_rate - Calculate the net coagulation rate.</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_19","title":"Signature","text":"<pre><code>class DiscreteSimple(CoagulationStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_15","title":"See also","text":"<ul> <li>CoagulationStrategy</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#discretesimpledimensionless_kernel","title":"DiscreteSimple().dimensionless_kernel","text":"<p>Show source in strategy.py:283</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_20","title":"Signature","text":"<pre><code>def dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float_],\n    coulomb_potential_ratio: NDArray[np.float_],\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#discretesimplegain_rate","title":"DiscreteSimple().gain_rate","text":"<p>Show source in strategy.py:318</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_21","title":"Signature","text":"<pre><code>def gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float_]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_16","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#discretesimplekernel","title":"DiscreteSimple().kernel","text":"<p>Show source in strategy.py:293</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_22","title":"Signature","text":"<pre><code>def kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_17","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#discretesimpleloss_rate","title":"DiscreteSimple().loss_rate","text":"<p>Show source in strategy.py:307</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#signature_23","title":"Signature","text":"<pre><code>def loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float_]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/strategy/#see-also_18","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/","title":"Transition Regime","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation / Transition Regime</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation.transition_regime module.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#coulomb_chahl2019","title":"coulomb_chahl2019","text":"<p>Show source in transition_regime.py:202</p> <p>Chahl and Gopalakrishnan (2019) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#returns","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#references","title":"References","text":"<ul> <li>Equations X in: Chahl, H. S., &amp; Gopalakrishnan, R. (2019). High potential, near free molecular regime Coulombic collisions in aerosols and dusty plasmas. Aerosol Science and Technology, 53(8), 933-957. https://doi.org/10.1080/02786826.2019.1614522</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#signature","title":"Signature","text":"<pre><code>def coulomb_chahl2019(\n    diffusive_knudsen: Union[float, NDArray[np.float_]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#coulomb_dyachkov2007","title":"coulomb_dyachkov2007","text":"<p>Show source in transition_regime.py:51</p> <p>Dyachkov et al. (2007) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#returns_1","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#references_1","title":"References","text":"<p>Equations X in: - Dyachkov, S. A., Kustova, E. V., &amp; Kustov, A. V. (2007). Coagulation of particles in the transition regime: The effect of the Coulomb potential. Journal of Chemical Physics, 126(12). https://doi.org/10.1063/1.2713719</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#signature_1","title":"Signature","text":"<pre><code>def coulomb_dyachkov2007(\n    diffusive_knudsen: Union[float, NDArray[np.float_]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#coulomb_gatti2008","title":"coulomb_gatti2008","text":"<p>Show source in transition_regime.py:108</p> <p>Gatti et al. (2008) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#returns_2","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#references_2","title":"References","text":"<ul> <li>Equations X in: Gatti, M., &amp; Kortshagen, U. (2008). Analytical model of particle charging in plasmas over a wide range of collisionality. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 78(4). https://doi.org/10.1103/PhysRevE.78.046402</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#signature_2","title":"Signature","text":"<pre><code>def coulomb_gatti2008(\n    diffusive_knudsen: Union[float, NDArray[np.float_]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#coulomb_gopalakrishnan2012","title":"coulomb_gopalakrishnan2012","text":"<p>Show source in transition_regime.py:163</p> <p>Gopalakrishnan and Hogan (2012) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#arguments_3","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#returns_3","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#references_3","title":"References","text":"<ul> <li>Equations X in: Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#signature_3","title":"Signature","text":"<pre><code>def coulomb_gopalakrishnan2012(\n    diffusive_knudsen: Union[float, NDArray[np.float_]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#hard_sphere","title":"hard_sphere","text":"<p>Show source in transition_regime.py:12</p> <p>Hard sphere approximation for the dimensionless coagulation kernel.</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#arguments_4","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#returns_4","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#references_4","title":"References","text":"<p>Equations X in: - Dyachkov, S. A., Kustova, E. V., &amp; Kustov, A. V. (2007). Coagulation of particles in the transition regime: The effect of the Coulomb potential. Journal of Chemical Physics, 126(12). https://doi.org/10.1063/1.2713719</p>"},{"location":"Source-Code/particula/next/dynamics/coagulation/transition_regime/#signature_4","title":"Signature","text":"<pre><code>def hard_sphere(\n    diffusive_knudsen: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/","title":"Gas","text":"<p>Particula Index / Particula / Next / Gas</p> <p>Auto-generated documentation for particula.next.gas module.</p>"},{"location":"Source-Code/particula/next/gas/#modules","title":"Modules","text":"<ul> <li>Atmosphere</li> <li>AtmosphereBuilder</li> <li>Properties</li> <li>Species</li> <li>Species Builder</li> <li>Vapor Pressure Builders</li> <li>Vapor Pressure Factories</li> <li>Vapor Pressure Strategies</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere/","title":"Atmosphere","text":"<p>Particula Index / Particula / Next / Gas / Atmosphere</p> <p>Auto-generated documentation for particula.next.gas.atmosphere module.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere/#atmosphere_1","title":"Atmosphere","text":"<p>Show source in atmosphere.py:8</p> <p>Represents a mixture of gas species, detailing properties such as temperature, total pressure, and the list of gas species in the mixture.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere/#attributes","title":"Attributes","text":"<ul> <li>temperature (float): The temperature of the gas mixture in Kelvin.</li> <li>total_pressure (float): The total pressure of the gas mixture in Pascals.</li> <li>species (List[GasSpecies]): A list of GasSpecies objects representing the     species in the gas mixture.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere/#methods","title":"Methods","text":"<ul> <li><code>-</code> add_species - Adds a gas species to the mixture.</li> <li><code>-</code> remove_species - Removes a gas species from the mixture by index.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere/#signature","title":"Signature","text":"<pre><code>class Atmosphere: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/atmosphere/#atmospheregetitem","title":"Atmosphere().getitem","text":"<p>Show source in atmosphere.py:55</p> <p>Returns the gas species at the given index.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere/#signature_1","title":"Signature","text":"<pre><code>def __getitem__(self, index: int) -&gt; GasSpecies: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/atmosphere/#see-also","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere/#atmosphereiter","title":"Atmosphere().iter","text":"<p>Show source in atmosphere.py:51</p> <p>Allows iteration over the species in the gas mixture.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere/#signature_2","title":"Signature","text":"<pre><code>def __iter__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/atmosphere/#atmospherelen","title":"Atmosphere().len","text":"<p>Show source in atmosphere.py:59</p> <p>Returns the number of species in the gas mixture.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere/#signature_3","title":"Signature","text":"<pre><code>def __len__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/atmosphere/#atmospherestr","title":"Atmosphere().str","text":"<p>Show source in atmosphere.py:63</p> <p>Returns a string representation of the Gas object.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere/#signature_4","title":"Signature","text":"<pre><code>def __str__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/atmosphere/#atmosphereadd_species","title":"Atmosphere().add_species","text":"<p>Show source in atmosphere.py:28</p> <p>Adds a gas species to the mixture.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere/#arguments","title":"Arguments","text":"<ul> <li>gas_species (GasSpecies): The GasSpecies object to be added to the mixture.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere/#signature_5","title":"Signature","text":"<pre><code>def add_species(self, gas_species: GasSpecies) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/atmosphere/#see-also_1","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere/#atmosphereremove_species","title":"Atmosphere().remove_species","text":"<p>Show source in atmosphere.py:38</p> <p>Removes a gas species from the mixture by index.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere/#arguments_1","title":"Arguments","text":"<ul> <li>index (int): The index of the gas species to be removed from the list.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere/#signature_6","title":"Signature","text":"<pre><code>def remove_species(self, index: int) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/","title":"AtmosphereBuilder","text":"<p>Particula Index / Particula / Next / Gas / AtmosphereBuilder</p> <p>Auto-generated documentation for particula.next.gas.atmosphere_builder module.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#atmospherebuilder_1","title":"AtmosphereBuilder","text":"<p>Show source in atmosphere_builder.py:13</p> <p>A builder class for creating Atmosphere objects with a fluent interface.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#attributes","title":"Attributes","text":"<ul> <li>temperature (float): The temperature of the gas mixture in Kelvin.</li> <li>total_pressure (float): The total pressure of the gas mixture in Pascals.</li> <li>species (list[GasSpecies]): The list of gas species in the mixture.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#methods","title":"Methods","text":"<ul> <li><code>-</code> set_temperature(temperature) - Set the temperature of the gas mixture.</li> <li><code>-</code> set_total_pressure(total_pressure) - Set the total pressure of the gas mixture.</li> <li><code>-</code> add_species(species) - Add a GasSpecies component to the gas mixture.</li> <li><code>-</code> set_parameters(parameters) - Set the parameters from a dictionary.</li> <li><code>-</code> build() - Validate and return the Atmosphere object.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#signature","title":"Signature","text":"<pre><code>class AtmosphereBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#atmospherebuilderadd_species","title":"AtmosphereBuilder().add_species","text":"<p>Show source in atmosphere_builder.py:99</p> <p>Add a GasSpecies component to the gas mixture.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#arguments","title":"Arguments","text":"<ul> <li>species (GasSpecies): The GasSpecies object to be added to the mixture.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#returns","title":"Returns","text":"<ul> <li><code>-</code> self - The AtmosphereBuilder object.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#signature_1","title":"Signature","text":"<pre><code>def add_species(self, species: GasSpecies): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#see-also_1","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#atmospherebuilderbuild","title":"AtmosphereBuilder().build","text":"<p>Show source in atmosphere_builder.py:114</p> <p>Validate and return the Atmosphere object.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#returns_1","title":"Returns","text":"<ul> <li><code>-</code> Atmosphere - The Atmosphere object.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#signature_2","title":"Signature","text":"<pre><code>def build(self) -&gt; Atmosphere: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#see-also_2","title":"See also","text":"<ul> <li>Atmosphere</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#atmospherebuilderset_temperature","title":"AtmosphereBuilder().set_temperature","text":"<p>Show source in atmosphere_builder.py:39</p> <p>Set the temperature of the gas mixture, in Kelvin.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#arguments_1","title":"Arguments","text":"<ul> <li>temperature (float): The temperature of the gas mixture.</li> <li>temperature_units (str): The units of the temperature. options are 'degC', 'degF', 'degR', 'K'. Default is 'K'.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> self - The AtmosphereBuilder object.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the temperature is below absolute zero.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#signature_3","title":"Signature","text":"<pre><code>def set_temperature(self, temperature: float, temperature_units: str = \"K\"): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#atmospherebuilderset_total_pressure","title":"AtmosphereBuilder().set_total_pressure","text":"<p>Show source in atmosphere_builder.py:71</p> <p>Set the total pressure of the gas mixture, in Pascals.</p>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#arguments_2","title":"Arguments","text":"<ul> <li>total_pressure (float): The total pressure of the gas mixture.</li> <li>pressure_units (str): The units of the pressure. Options are 'Pa', 'kPa', 'MPa', 'psi', 'bar', 'atm'. Default is 'Pa'.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#returns_3","title":"Returns","text":"<ul> <li><code>-</code> self - The AtmosphereBuilder object.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#raises_1","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the total pressure is below zero.</li> </ul>"},{"location":"Source-Code/particula/next/gas/atmosphere_builder/#signature_4","title":"Signature","text":"<pre><code>def set_total_pressure(self, total_pressure: float, pressure_units: str = \"Pa\"): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species/","title":"Species","text":"<p>Particula Index / Particula / Next / Gas / Species</p> <p>Auto-generated documentation for particula.next.gas.species module.</p>"},{"location":"Source-Code/particula/next/gas/species/#gasspecies","title":"GasSpecies","text":"<p>Show source in species.py:16</p> <p>GasSpecies represents an individual or array of gas species with properties like name, molar mass, vapor pressure, and condensability.</p>"},{"location":"Source-Code/particula/next/gas/species/#attributes","title":"Attributes","text":"<ul> <li>name (str): The name of the gas species.</li> <li>molar_mass (float): The molar mass of the gas species.</li> <li>pure_vapor_pressure_strategy (VaporPressureStrategy): The strategy for     calculating the pure vapor pressure of the gas species. Can be a single     strategy or a list of strategies. Default is a constant vapor pressure     strategy with a vapor pressure of 0.0 Pa.</li> <li>condensable (bool): Indicates whether the gas species is condensable.     Default is True.</li> <li>concentration (float): The concentration of the gas species in the     mixture. Default is 0.0 kg/m^3.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#methods","title":"Methods","text":"<ul> <li><code>-</code> get_molar_mass - Get the molar mass of the gas species.</li> <li><code>-</code> get_condensable - Check if the gas species is condensable.</li> <li><code>-</code> get_concentration - Get the concentration of the gas species in the     mixture.</li> <li><code>-</code> get_pure_vapor_pressure - Calculate the pure vapor pressure of the gas     species at a given temperature.</li> <li><code>-</code> get_partial_pressure - Calculate the partial pressure of the gas species.</li> <li><code>-</code> get_saturation_ratio - Calculate the saturation ratio of the gas species.</li> <li><code>-</code> get_saturation_concentration - Calculate the saturation concentration of     the gas species.</li> <li><code>-</code> add_concentration - Add concentration to the gas species.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#signature","title":"Signature","text":"<pre><code>class GasSpecies:\n    def __init__(\n        self,\n        name: Union[str, NDArray[np.str_]],\n        molar_mass: Union[float, NDArray[np.float_]],\n        vapor_pressure_strategy: Union[\n            VaporPressureStrategy, list[VaporPressureStrategy]\n        ] = ConstantVaporPressureStrategy(0.0),\n        condensable: Union[bool, NDArray[np.bool_]] = True,\n        concentration: Union[float, NDArray[np.float_]] = 0.0,\n    ) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species/#see-also","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#gasspecieslen","title":"GasSpecies().len","text":"<p>Show source in species.py:68</p> <p>Return the number of gas species.</p>"},{"location":"Source-Code/particula/next/gas/species/#signature_1","title":"Signature","text":"<pre><code>def __len__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species/#gasspeciesstr","title":"GasSpecies().str","text":"<p>Show source in species.py:64</p> <p>Return a string representation of the GasSpecies object.</p>"},{"location":"Source-Code/particula/next/gas/species/#signature_2","title":"Signature","text":"<pre><code>def __str__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species/#gasspeciesadd_concentration","title":"GasSpecies().add_concentration","text":"<p>Show source in species.py:263</p> <p>Add concentration to the gas species.</p>"},{"location":"Source-Code/particula/next/gas/species/#arguments","title":"Arguments","text":"<ul> <li>added_concentration (float): The concentration to add to the gas     species.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#signature_3","title":"Signature","text":"<pre><code>def add_concentration(self, added_concentration: Union[float, NDArray[np.float_]]): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species/#gasspeciesget_concentration","title":"GasSpecies().get_concentration","text":"<p>Show source in species.py:99</p> <p>Get the concentration of the gas species in the mixture, in kg/m^3.</p>"},{"location":"Source-Code/particula/next/gas/species/#returns","title":"Returns","text":"<ul> <li>concentration (float or NDArray[np.float_]): The concentration of the     gas species in the mixture.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#signature_4","title":"Signature","text":"<pre><code>def get_concentration(self) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species/#gasspeciesget_condensable","title":"GasSpecies().get_condensable","text":"<p>Show source in species.py:91</p> <p>Check if the gas species is condensable or not.</p>"},{"location":"Source-Code/particula/next/gas/species/#returns_1","title":"Returns","text":"<ul> <li>condensable (bool): True if the gas species is condensable, False     otherwise.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#signature_5","title":"Signature","text":"<pre><code>def get_condensable(self) -&gt; Union[bool, NDArray[np.bool_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species/#gasspeciesget_molar_mass","title":"GasSpecies().get_molar_mass","text":"<p>Show source in species.py:83</p> <p>Get the molar mass of the gas species in kg/mol.</p>"},{"location":"Source-Code/particula/next/gas/species/#returns_2","title":"Returns","text":"<ul> <li>molar_mass (float or NDArray[np.float_]): The molar mass of the gas     species, in kg/mol.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#signature_6","title":"Signature","text":"<pre><code>def get_molar_mass(self) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species/#gasspeciesget_name","title":"GasSpecies().get_name","text":"<p>Show source in species.py:76</p> <p>Get the name of the gas species.</p>"},{"location":"Source-Code/particula/next/gas/species/#returns_3","title":"Returns","text":"<ul> <li>name (str or NDArray[np.str_]): The name of the gas species.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#signature_7","title":"Signature","text":"<pre><code>def get_name(self) -&gt; Union[str, NDArray[np.str_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species/#gasspeciesget_partial_pressure","title":"GasSpecies().get_partial_pressure","text":"<p>Show source in species.py:140</p> <p>Calculate the partial pressure of the gas based on the vapor pressure strategy. This method accounts for multiple strategies if assigned and calculates partial pressure for each strategy based on the corresponding concentration and molar mass.</p>"},{"location":"Source-Code/particula/next/gas/species/#arguments_1","title":"Arguments","text":"<ul> <li>temperature (float or NDArray[np.float_]): The temperature in Kelvin at which to calculate the partial pressure.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#returns_4","title":"Returns","text":"<ul> <li>partial_pressure (float or NDArray[np.float_]): Partial pressure of the gas in Pascals.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the vapor pressure strategy is not set.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#signature_8","title":"Signature","text":"<pre><code>def get_partial_pressure(\n    self, temperature: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species/#gasspeciesget_pure_vapor_pressure","title":"GasSpecies().get_pure_vapor_pressure","text":"<p>Show source in species.py:107</p> <p>Calculate the pure vapor pressure of the gas species at a given temperature in Kelvin.</p> <p>This method supports both a single strategy or a list of strategies for calculating vapor pressure.</p>"},{"location":"Source-Code/particula/next/gas/species/#arguments_2","title":"Arguments","text":"<ul> <li>temperature (float or NDArray[np.float_]): The temperature in Kelvin at which to calculate vapor pressure.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#returns_5","title":"Returns","text":"<ul> <li>vapor_pressure (float or NDArray[np.float_]): The calculated pure vapor pressure in Pascals.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If no vapor pressure strategy is set.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#signature_9","title":"Signature","text":"<pre><code>def get_pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species/#gasspeciesget_saturation_concentration","title":"GasSpecies().get_saturation_concentration","text":"<p>Show source in species.py:224</p> <p>Calculate the saturation concentration of the gas based on the vapor pressure strategy. This method accounts for multiple strategies if assigned and calculates saturation concentration for each strategy based on the molar mass.</p>"},{"location":"Source-Code/particula/next/gas/species/#arguments_3","title":"Arguments","text":"<ul> <li>temperature (float or NDArray[np.float_]): The temperature in Kelvin at which to calculate the partial pressure.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#returns_6","title":"Returns","text":"<ul> <li>saturation_concentration (float or NDArray[np.float_]): The saturation concentration of the gas</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#raises_2","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the vapor pressure strategy is not set.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#signature_10","title":"Signature","text":"<pre><code>def get_saturation_concentration(\n    self, temperature: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species/#gasspeciesget_saturation_ratio","title":"GasSpecies().get_saturation_ratio","text":"<p>Show source in species.py:182</p> <p>Calculate the saturation ratio of the gas based on the vapor pressure strategy. This method accounts for multiple strategies if assigned and calculates saturation ratio for each strategy based on the corresponding concentration and molar mass.</p>"},{"location":"Source-Code/particula/next/gas/species/#arguments_4","title":"Arguments","text":"<ul> <li>temperature (float or NDArray[np.float_]): The temperature in Kelvin at which to calculate the partial pressure.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#returns_7","title":"Returns","text":"<ul> <li>saturation_ratio (float or NDArray[np.float_]): The saturation ratio of the gas</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#raises_3","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the vapor pressure strategy is not set.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species/#signature_11","title":"Signature","text":"<pre><code>def get_saturation_ratio(\n    self, temperature: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species_builder/","title":"Species Builder","text":"<p>Particula Index / Particula / Next / Gas / Species Builder</p> <p>Auto-generated documentation for particula.next.gas.species_builder module.</p>"},{"location":"Source-Code/particula/next/gas/species_builder/#gasspeciesbuilder","title":"GasSpeciesBuilder","text":"<p>Show source in species_builder.py:19</p> <p>Builder class for GasSpecies objects, allowing for a more fluent and readable creation of GasSpecies instances with optional parameters.</p>"},{"location":"Source-Code/particula/next/gas/species_builder/#attributes","title":"Attributes","text":"<ul> <li>name (str): The name of the gas species.</li> <li>molar_mass (float): The molar mass of the gas species in kg/mol.</li> <li>vapor_pressure_strategy (VaporPressureStrategy): The vapor pressure     strategy for the gas species.</li> <li>condensable (bool): Whether the gas species is condensable.</li> <li>concentration (float): The concentration of the gas species in the     mixture, in kg/m^3.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species_builder/#methods","title":"Methods","text":"<ul> <li><code>-</code> set_name(name) - Set the name of the gas species.</li> <li>set_molar_mass(molar_mass, molar_mass_units): Set the molar mass of the     gas species in kg/mol.</li> <li><code>-</code> set_vapor_pressure_strategy(strategy) - Set the vapor pressure strategy     for the gas species.</li> <li><code>-</code> set_condensable(condensable) - Set the condensable bool of the gas     species.</li> <li>set_concentration(concentration, concentration_units): Set the     concentration of the gas species in the mixture, in kg/m^3.</li> <li><code>-</code> set_parameters(params) - Set the parameters of the GasSpecies object from     a dictionary including optional units.</li> <li><code>-</code> build() - Validate and return the GasSpecies object.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species_builder/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If any required key is missing. During check_keys and     pre_build_check. Or if trying to set an invalid parameter.</li> <li><code>-</code> Warning - If using default units for any parameter.</li> </ul>"},{"location":"Source-Code/particula/next/gas/species_builder/#signature","title":"Signature","text":"<pre><code>class GasSpeciesBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species_builder/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"Source-Code/particula/next/gas/species_builder/#gasspeciesbuilderbuild","title":"GasSpeciesBuilder().build","text":"<p>Show source in species_builder.py:114</p> <p>Validate and return the GasSpecies object.</p>"},{"location":"Source-Code/particula/next/gas/species_builder/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; GasSpecies: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species_builder/#see-also_1","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"Source-Code/particula/next/gas/species_builder/#gasspeciesbuilderset_concentration","title":"GasSpeciesBuilder().set_concentration","text":"<p>Show source in species_builder.py:99</p> <p>Set the concentration of the gas species in the mixture, in kg/m^3.</p>"},{"location":"Source-Code/particula/next/gas/species_builder/#signature_2","title":"Signature","text":"<pre><code>def set_concentration(\n    self,\n    concentration: Union[float, NDArray[np.float_]],\n    concentration_units: str = \"kg/m^3\",\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species_builder/#gasspeciesbuilderset_condensable","title":"GasSpeciesBuilder().set_condensable","text":"<p>Show source in species_builder.py:91</p> <p>Set the condensable bool of the gas species.</p>"},{"location":"Source-Code/particula/next/gas/species_builder/#signature_3","title":"Signature","text":"<pre><code>def set_condensable(self, condensable: Union[bool, NDArray[np.bool_]]): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species_builder/#gasspeciesbuilderset_molar_mass","title":"GasSpeciesBuilder().set_molar_mass","text":"<p>Show source in species_builder.py:70</p> <p>Set the molar mass of the gas species. Units in kg/mol.</p>"},{"location":"Source-Code/particula/next/gas/species_builder/#signature_4","title":"Signature","text":"<pre><code>def set_molar_mass(\n    self, molar_mass: Union[float, NDArray[np.float_]], molar_mass_units: str = \"kg/mol\"\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species_builder/#gasspeciesbuilderset_name","title":"GasSpeciesBuilder().set_name","text":"<p>Show source in species_builder.py:65</p> <p>Set the name of the gas species.</p>"},{"location":"Source-Code/particula/next/gas/species_builder/#signature_5","title":"Signature","text":"<pre><code>def set_name(self, name: Union[str, NDArray[np.str_]]): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species_builder/#gasspeciesbuilderset_vapor_pressure_strategy","title":"GasSpeciesBuilder().set_vapor_pressure_strategy","text":"<p>Show source in species_builder.py:83</p> <p>Set the vapor pressure strategy for the gas species.</p>"},{"location":"Source-Code/particula/next/gas/species_builder/#signature_6","title":"Signature","text":"<pre><code>def set_vapor_pressure_strategy(\n    self, strategy: Union[VaporPressureStrategy, list[VaporPressureStrategy]]\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/species_builder/#see-also_2","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/","title":"Vapor Pressure Builders","text":"<p>Particula Index / Particula / Next / Gas / Vapor Pressure Builders</p> <p>Auto-generated documentation for particula.next.gas.vapor_pressure_builders module.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#antoinebuilder","title":"AntoineBuilder","text":"<p>Show source in vapor_pressure_builders.py:17</p> <p>Builder class for AntoineVaporPressureStrategy. It allows setting the coefficients 'a', 'b', and 'c' separately and then building the strategy object.</p> <ul> <li>Equation: log10(P_mmHG) = a - b / (Temperature_K - c)</li> <li>Units: 'a_units' = None, 'b_units' = 'K', 'c_units' = 'K'</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#methods","title":"Methods","text":"<ul> <li>set_a(a, a_units): Set the coefficient 'a' of the Antoine equation.</li> <li>set_b(b, b_units): Set the coefficient 'b' of the Antoine equation.</li> <li>set_c(c, c_units): Set the coefficient 'c' of the Antoine equation.</li> <li><code>-</code> set_parameters(params) - Set coefficients from a dictionary including     optional units.</li> <li><code>-</code> build() - Build the AntoineVaporPressureStrategy object with the set     coefficients.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature","title":"Signature","text":"<pre><code>class AntoineBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#antoinebuilderbuild","title":"AntoineBuilder().build","text":"<p>Show source in vapor_pressure_builders.py:70</p> <p>Build the AntoineVaporPressureStrategy object with the set coefficients.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#antoinebuilderset_a","title":"AntoineBuilder().set_a","text":"<p>Show source in vapor_pressure_builders.py:44</p> <p>Set the coefficient 'a' of the Antoine equation.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_2","title":"Signature","text":"<pre><code>def set_a(self, a: float, a_units: Optional[str] = None): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#antoinebuilderset_b","title":"AntoineBuilder().set_b","text":"<p>Show source in vapor_pressure_builders.py:54</p> <p>Set the coefficient 'b' of the Antoine equation.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_3","title":"Signature","text":"<pre><code>def set_b(self, b: float, b_units: str = \"K\"): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#antoinebuilderset_c","title":"AntoineBuilder().set_c","text":"<p>Show source in vapor_pressure_builders.py:62</p> <p>Set the coefficient 'c' of the Antoine equation.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_4","title":"Signature","text":"<pre><code>def set_c(self, c: float, c_units: str = \"K\"): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#clausiusclapeyronbuilder","title":"ClausiusClapeyronBuilder","text":"<p>Show source in vapor_pressure_builders.py:78</p> <p>Builder class for ClausiusClapeyronStrategy. This class facilitates setting the latent heat of vaporization, initial temperature, and initial pressure with unit handling and then builds the strategy object.</p> <ul> <li>Equation: dP/dT = L / (R * T^2)</li> <li>Units: 'latent_heat_units' = 'J/kg', 'temperature_initial_units' = 'K',     'pressure_initial_units' = 'Pa'</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#methods_1","title":"Methods","text":"<ul> <li>set_latent_heat(latent_heat, latent_heat_units): Set the latent heat of     vaporization.</li> <li>set_temperature_initial(temperature_initial, temperature_initial_units):     Set the initial temperature.</li> <li>set_pressure_initial(pressure_initial, pressure_initial_units): Set the     initial pressure.</li> <li><code>-</code> set_parameters(parameters) - Set parameters from a dictionary including     optional units.</li> <li><code>-</code> build() - Build the ClausiusClapeyronStrategy object with the set     parameters.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_5","title":"Signature","text":"<pre><code>class ClausiusClapeyronBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#see-also_1","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#clausiusclapeyronbuilderbuild","title":"ClausiusClapeyronBuilder().build","text":"<p>Show source in vapor_pressure_builders.py:149</p> <p>Build and return a ClausiusClapeyronStrategy object with the set parameters.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_6","title":"Signature","text":"<pre><code>def build(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#clausiusclapeyronbuilderset_latent_heat","title":"ClausiusClapeyronBuilder().set_latent_heat","text":"<p>Show source in vapor_pressure_builders.py:111</p> <p>Set the latent heat of vaporization: Default units J/kg.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_7","title":"Signature","text":"<pre><code>def set_latent_heat(self, latent_heat: float, latent_heat_units: str = \"J/kg\"): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#clausiusclapeyronbuilderset_pressure_initial","title":"ClausiusClapeyronBuilder().set_pressure_initial","text":"<p>Show source in vapor_pressure_builders.py:136</p> <p>Set the initial pressure. Default units: Pa.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_8","title":"Signature","text":"<pre><code>def set_pressure_initial(\n    self, pressure_initial: float, pressure_initial_units: str = \"Pa\"\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#clausiusclapeyronbuilderset_temperature_initial","title":"ClausiusClapeyronBuilder().set_temperature_initial","text":"<p>Show source in vapor_pressure_builders.py:123</p> <p>Set the initial temperature. Default units: K.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_9","title":"Signature","text":"<pre><code>def set_temperature_initial(\n    self, temperature_initial: float, temperature_initial_units: str = \"K\"\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#constantbuilder","title":"ConstantBuilder","text":"<p>Show source in vapor_pressure_builders.py:160</p> <p>Builder class for ConstantVaporPressureStrategy. This class facilitates setting the constant vapor pressure and then building the strategy object.</p> <ul> <li>Equation: P = vapor_pressure</li> <li>Units: 'vapor_pressure_units' = 'Pa'</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#methods_2","title":"Methods","text":"<ul> <li>set_vapor_pressure(constant, constant_units): Set the constant vapor pressure.</li> <li><code>-</code> set_parameters(parameters) - Set parameters from a dictionary including     optional units.</li> <li><code>-</code> build() - Build the ConstantVaporPressureStrategy object with the set     parameters.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_10","title":"Signature","text":"<pre><code>class ConstantBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#constantbuilderbuild","title":"ConstantBuilder().build","text":"<p>Show source in vapor_pressure_builders.py:194</p> <p>Build and return a ConstantVaporPressureStrategy object with the set parameters.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_11","title":"Signature","text":"<pre><code>def build(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#constantbuilderset_vapor_pressure","title":"ConstantBuilder().set_vapor_pressure","text":"<p>Show source in vapor_pressure_builders.py:182</p> <p>Set the constant vapor pressure.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_12","title":"Signature","text":"<pre><code>def set_vapor_pressure(\n    self, vapor_pressure: float, vapor_pressure_units: str = \"Pa\"\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#waterbuckbuilder","title":"WaterBuckBuilder","text":"<p>Show source in vapor_pressure_builders.py:201</p> <p>Builder class for WaterBuckStrategy. This class facilitates the building of the WaterBuckStrategy object. Which as of now has no additional parameters to set. But could be extended in the future for ice only calculations. We keep the builder for consistency.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#methods_3","title":"Methods","text":"<ul> <li><code>-</code> build() - Build the WaterBuckStrategy object.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_13","title":"Signature","text":"<pre><code>class WaterBuckBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#see-also_3","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#waterbuckbuilderbuild","title":"WaterBuckBuilder().build","text":"<p>Show source in vapor_pressure_builders.py:215</p> <p>Build and return a WaterBuckStrategy object.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_builders/#signature_14","title":"Signature","text":"<pre><code>def build(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_factories/","title":"Vapor Pressure Factories","text":"<p>Particula Index / Particula / Next / Gas / Vapor Pressure Factories</p> <p>Auto-generated documentation for particula.next.gas.vapor_pressure_factories module.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_factories/#vapor_pressure_factory","title":"vapor_pressure_factory","text":"<p>Show source in vapor_pressure_factories.py:9</p> <p>Factory method to create a concrete VaporPressureStrategy object using builders.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_factories/#arguments","title":"Arguments","text":"<ul> <li>strategy (str): The strategy to use for vapor pressure calculations.</li> <li><code>Options</code> - \"constant\", \"antoine\", \"clausius_clapeyron\", \"water_buck\".</li> <li>parameters (dict): A dictionary containing the necessary parameters for     the strategy. If no parameters are needed, this can be left as None.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_factories/#returns","title":"Returns","text":"<ul> <li>vapor_pressure_strategy (VaporPressureStrategy): A concrete   implementation of the VaporPressureStrategy built using the appropriate   builder.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_factories/#signature","title":"Signature","text":"<pre><code>def vapor_pressure_factory(\n    strategy: str, parameters: ignore = None\n) -&gt; VaporPressureStrategy: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_factories/#see-also","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/","title":"Vapor Pressure Strategies","text":"<p>Particula Index / Particula / Next / Gas / Vapor Pressure Strategies</p> <p>Auto-generated documentation for particula.next.gas.vapor_pressure_strategies module.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#antoinevaporpressurestrategy","title":"AntoineVaporPressureStrategy","text":"<p>Show source in vapor_pressure_strategies.py:201</p> <p>Concrete implementation of the VaporPressureStrategy using the Antoine equation for vapor pressure calculations.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature","title":"Signature","text":"<pre><code>class AntoineVaporPressureStrategy(VaporPressureStrategy):\n    def __init__(\n        self,\n        a: Union[float, NDArray[np.float_]] = 0.0,\n        b: Union[float, NDArray[np.float_]] = 0.0,\n        c: Union[float, NDArray[np.float_]] = 0.0,\n    ): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#see-also","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#antoinevaporpressurestrategypure_vapor_pressure","title":"AntoineVaporPressureStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:216</p> <p>Calculate the pure (saturation) vapor pressure using the Antoine equation.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#arguments","title":"Arguments","text":"<ul> <li>temperature (float or NDArray[np.float_]): Temperature in Kelvin.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#returns","title":"Returns","text":"<ul> <li>vapor_pressure (float or NDArray[np.float_]): The vapor pressure in Pascals.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#references","title":"References","text":"<ul> <li><code>-</code> Equation - log10(P) = a - b / (T - c)</li> <li>https://en.wikipedia.org/wiki/Antoine_equation (but in Kelvin)</li> <li>Kelvin form: https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118135341.app1</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_1","title":"Signature","text":"<pre><code>def pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#clausiusclapeyronstrategy","title":"ClausiusClapeyronStrategy","text":"<p>Show source in vapor_pressure_strategies.py:247</p> <p>Concrete implementation of the VaporPressureStrategy using the Clausius-Clapeyron equation for vapor pressure calculations.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_2","title":"Signature","text":"<pre><code>class ClausiusClapeyronStrategy(VaporPressureStrategy):\n    def __init__(\n        self,\n        latent_heat: Union[float, NDArray[np.float_]],\n        temperature_initial: Union[float, NDArray[np.float_]],\n        pressure_initial: Union[float, NDArray[np.float_]],\n    ): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#see-also_1","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#clausiusclapeyronstrategypure_vapor_pressure","title":"ClausiusClapeyronStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:274</p> <p>Calculate the vapor pressure at a new temperature using the Clausius-Clapeyron equation. For ideal gases at low temperatures.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#arguments_1","title":"Arguments","text":"<ul> <li>temperature_initial (float or NDArray[np.float_]): Initial temperature in Kelvin.</li> <li>pressure_initial (float or NDArray[np.float_]): Initial vapor pressure in Pascals.</li> <li>temperature_final (float or NDArray[np.float_]): Final temperature in Kelvin.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#returns_1","title":"Returns","text":"<ul> <li>vapor_pressure_final (float or NDArray[np.float_]): Final vapor pressure in Pascals.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#references_1","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Clausius%E2%80%93Clapeyron_relation Ideal_gas_approximation_at_low_temperatures</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_3","title":"Signature","text":"<pre><code>def pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#constantvaporpressurestrategy","title":"ConstantVaporPressureStrategy","text":"<p>Show source in vapor_pressure_strategies.py:175</p> <p>Concrete implementation of the VaporPressureStrategy using a constant vapor pressure value.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_4","title":"Signature","text":"<pre><code>class ConstantVaporPressureStrategy(VaporPressureStrategy):\n    def __init__(self, vapor_pressure: Union[float, NDArray[np.float_]]): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#see-also_2","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#constantvaporpressurestrategypure_vapor_pressure","title":"ConstantVaporPressureStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:182</p> <p>Return the constant vapor pressure value.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#arguments_2","title":"Arguments","text":"<ul> <li>temperature (float or NDArray[np.float_]): Not used.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#returns_2","title":"Returns","text":"<ul> <li>vapor_pressure (float or NDArray[np.float_]): The constant vapor pressure value in Pascals.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_5","title":"Signature","text":"<pre><code>def pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#vaporpressurestrategy","title":"VaporPressureStrategy","text":"<p>Show source in vapor_pressure_strategies.py:63</p> <p>Abstract class for vapor pressure calculations. The methods defined here must be implemented by subclasses below.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_6","title":"Signature","text":"<pre><code>class VaporPressureStrategy(ABC): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#vaporpressurestrategyconcentration","title":"VaporPressureStrategy().concentration","text":"<p>Show source in vapor_pressure_strategies.py:92</p> <p>Calculate the concentration of the gas at a given pressure and temperature.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#arguments_3","title":"Arguments","text":"<ul> <li>partial_pressure (float or NDArray[np.float_]): Pressure in Pascals.</li> <li>molar_mass (float or NDArray[np.float_]): Molar mass of the gas in kg/mol.</li> <li>temperature (float or NDArray[np.float_]): Temperature in Kelvin.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#returns_3","title":"Returns","text":"<ul> <li>concentration (float or NDArray[np.float_]): The concentration of the gas in kg/m^3.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_7","title":"Signature","text":"<pre><code>def concentration(\n    self,\n    partial_pressure: Union[float, NDArray[np.float_]],\n    molar_mass: Union[float, NDArray[np.float_]],\n    temperature: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#vaporpressurestrategypartial_pressure","title":"VaporPressureStrategy().partial_pressure","text":"<p>Show source in vapor_pressure_strategies.py:67</p> <p>Calculate the partial pressure of the gas from its concentration, molar mass, and temperature.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#arguments_4","title":"Arguments","text":"<ul> <li>concentration (float or NDArray[np.float_]): Concentration of the gas in kg/m^3.</li> <li>molar_mass (float or NDArray[np.float_]): Molar mass of the gas in kg/mol.</li> <li>temperature (float or NDArray[np.float_]): Temperature in Kelvin.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#returns_4","title":"Returns","text":"<ul> <li>partial_pressure (float or NDArray[np.float_]): Partial pressure of the gas in Pascals.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_8","title":"Signature","text":"<pre><code>def partial_pressure(\n    self,\n    concentration: Union[float, NDArray[np.float_]],\n    molar_mass: Union[float, NDArray[np.float_]],\n    temperature: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#vaporpressurestrategypure_vapor_pressure","title":"VaporPressureStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:163</p> <p>Calculate the pure (saturation) vapor pressure at a given temperature. Units are in Pascals Pa=kg/(m\u00b7s\u00b2).</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#arguments_5","title":"Arguments","text":"<p>temperature (float or NDArray[np.float_]): Temperature in Kelvin.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_9","title":"Signature","text":"<pre><code>@abstractmethod\ndef pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#vaporpressurestrategysaturation_concentration","title":"VaporPressureStrategy().saturation_concentration","text":"<p>Show source in vapor_pressure_strategies.py:139</p> <p>Calculate the saturation concentration of the gas at a given temperature.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#arguments_6","title":"Arguments","text":"<ul> <li>molar_mass (float or NDArray[np.float_]): Molar mass of the gas in kg/mol.</li> <li>temperature (float or NDArray[np.float_]): Temperature in Kelvin.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#returns_5","title":"Returns","text":"<ul> <li>saturation_concentration (float or NDArray[np.float_]): The saturation concentration of the gas in kg/m^3.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_10","title":"Signature","text":"<pre><code>def saturation_concentration(\n    self,\n    molar_mass: Union[float, NDArray[np.float_]],\n    temperature: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#vaporpressurestrategysaturation_ratio","title":"VaporPressureStrategy().saturation_ratio","text":"<p>Show source in vapor_pressure_strategies.py:116</p> <p>Calculate the saturation ratio of the gas at a given pressure and temperature.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#arguments_7","title":"Arguments","text":"<ul> <li>pressure (float or NDArray[np.float_]): Pressure in Pascals.</li> <li>temperature (float or NDArray[np.float_]): Temperature in Kelvin.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#returns_6","title":"Returns","text":"<ul> <li>saturation_ratio (float or NDArray[np.float_]): The saturation ratio of the gas.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_11","title":"Signature","text":"<pre><code>def saturation_ratio(\n    self,\n    concentration: Union[float, NDArray[np.float_]],\n    molar_mass: Union[float, NDArray[np.float_]],\n    temperature: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#waterbuckstrategy","title":"WaterBuckStrategy","text":"<p>Show source in vapor_pressure_strategies.py:304</p> <p>Concrete implementation of the VaporPressureStrategy using the Buck equation for water vapor pressure calculations.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_12","title":"Signature","text":"<pre><code>class WaterBuckStrategy(VaporPressureStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#see-also_3","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#waterbuckstrategypure_vapor_pressure","title":"WaterBuckStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:308</p> <p>Calculate the pure (saturation) vapor pressure using the Buck equation for water vapor.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#arguments_8","title":"Arguments","text":"<ul> <li>temperature (float or NDArray[np.float_]): Temperature in Kelvin.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#returns_7","title":"Returns","text":"<ul> <li>vapor_pressure (float or NDArray[np.float_]): The vapor pressure in Pascals.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#references_2","title":"References","text":"<p>Buck, A. L., 1981: New Equations for Computing Vapor Pressure and Enhancement Factor. J. Appl. Meteor. Climatol., 20, 1527-1532, https://doi.org/10.1175/1520-0450(1981)020&lt;1527:NEFCVP&gt;2.0.CO;2.</p> <p>https://en.wikipedia.org/wiki/Arden_Buck_equation</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_13","title":"Signature","text":"<pre><code>def pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#calculate_concentration","title":"calculate_concentration","text":"<p>Show source in vapor_pressure_strategies.py:40</p> <p>Calculate the concentration of a gas from its partial pressure, molar mass, and temperature using the ideal gas law.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#arguments_9","title":"Arguments","text":"<ul> <li>pressure (float or NDArray[np.float_]): Partial pressure of the gas in Pascals (Pa).</li> <li>molar_mass (float or NDArray[np.float_]): Molar mass of the gas in kg/mol</li> <li>temperature (float or NDArray[np.float_]): Temperature in Kelvin.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#returns_8","title":"Returns","text":"<ul> <li>concentration (float or NDArray[np.float_]): Concentration of the gas in kg/m^3.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_14","title":"Signature","text":"<pre><code>def calculate_concentration(\n    partial_pressure: Union[float, NDArray[np.float_]],\n    molar_mass: Union[float, NDArray[np.float_]],\n    temperature: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#calculate_partial_pressure","title":"calculate_partial_pressure","text":"<p>Show source in vapor_pressure_strategies.py:18</p> <p>Calculate the partial pressure of a gas from its concentration, molar mass, and temperature.</p>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#arguments_10","title":"Arguments","text":"<ul> <li>concentration (float): Concentration of the gas in kg/m^3.</li> <li>molar_mass (float): Molar mass of the gas in kg/mol.</li> <li>temperature (float): Temperature in Kelvin.</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#returns_9","title":"Returns","text":"<ul> <li><code>-</code> float - Partial pressure of the gas in Pascals (Pa).</li> </ul>"},{"location":"Source-Code/particula/next/gas/vapor_pressure_strategies/#signature_15","title":"Signature","text":"<pre><code>def calculate_partial_pressure(\n    concentration: Union[float, NDArray[np.float_]],\n    molar_mass: Union[float, NDArray[np.float_]],\n    temperature: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/properties/","title":"Properties","text":"<p>Particula Index / Particula / Next / Gas / Properties</p> <p>Auto-generated documentation for particula.next.gas.properties module.</p>"},{"location":"Source-Code/particula/next/gas/properties/#modules","title":"Modules","text":"<ul> <li>Dynamic Viscosity</li> <li>Mean Free Path</li> <li>Thermal Conductivity</li> </ul>"},{"location":"Source-Code/particula/next/gas/properties/dynamic_viscosity/","title":"Dynamic Viscosity","text":"<p>Particula Index / Particula / Next / Gas / Properties / Dynamic Viscosity</p> <p>Auto-generated documentation for particula.next.gas.properties.dynamic_viscosity module.</p>"},{"location":"Source-Code/particula/next/gas/properties/dynamic_viscosity/#get_dynamic_viscosity","title":"get_dynamic_viscosity","text":"<p>Show source in dynamic_viscosity.py:22</p> <p>Calculates the dynamic viscosity of air via Sutherland's formula, which is a common method in fluid dynamics for gases that involves temperature adjustments.</p>"},{"location":"Source-Code/particula/next/gas/properties/dynamic_viscosity/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> temperature - Desired air temperature [K]. Must be greater than 0.</li> <li><code>-</code> reference_viscosity - Gas viscosity [Pa*s] at the reference temperature (default is STP).</li> <li><code>-</code> reference_temperature - Gas temperature [K] for the reference viscosity (default is STP).</li> </ul>"},{"location":"Source-Code/particula/next/gas/properties/dynamic_viscosity/#returns","title":"Returns","text":"<ul> <li><code>-</code> float - The dynamic viscosity of air at the given temperature [Pa*s].</li> </ul>"},{"location":"Source-Code/particula/next/gas/properties/dynamic_viscosity/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the temperature is less than or equal to 0.</li> </ul>"},{"location":"Source-Code/particula/next/gas/properties/dynamic_viscosity/#references","title":"References","text":"<p>https://resources.wolframcloud.com/FormulaRepository/resources/Sutherlands-Formula</p>"},{"location":"Source-Code/particula/next/gas/properties/dynamic_viscosity/#signature","title":"Signature","text":"<pre><code>def get_dynamic_viscosity(\n    temperature: float,\n    reference_viscosity: float = REF_VISCOSITY_AIR_STP.m,\n    reference_temperature: float = REF_TEMPERATURE_STP.m,\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/properties/mean_free_path/","title":"Mean Free Path","text":"<p>Particula Index / Particula / Next / Gas / Properties / Mean Free Path</p> <p>Auto-generated documentation for particula.next.gas.properties.mean_free_path module.</p>"},{"location":"Source-Code/particula/next/gas/properties/mean_free_path/#molecule_mean_free_path","title":"molecule_mean_free_path","text":"<p>Show source in mean_free_path.py:24</p> <p>Calculate the mean free path of a gas molecule in air based on the temperature, pressure, and molar mass of the gas. The mean free path is the average distance traveled by a molecule between collisions with other molecules present in a medium (air).</p>"},{"location":"Source-Code/particula/next/gas/properties/mean_free_path/#arguments","title":"Arguments","text":"<ul> <li>molar_mass (Union[float, NDArray[np.float_]]): The molar mass of the gas molecule [kg/mol]. Default is the molecular weight of air.</li> <li>temperature (float): The temperature of the gas [K]. Default is 298.15 K.</li> <li>pressure (float): The pressure of the gas [Pa]. Default is 101325 Pa.</li> <li>dynamic_viscosity (Optional[float]): The dynamic viscosity of the gas [Pa*s]. If not provided, it will be calculated based on the temperature.</li> </ul>"},{"location":"Source-Code/particula/next/gas/properties/mean_free_path/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The mean free path of the gas molecule in meters (m).</li> </ul>"},{"location":"Source-Code/particula/next/gas/properties/mean_free_path/#references","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Mean_free_path</li> </ul>"},{"location":"Source-Code/particula/next/gas/properties/mean_free_path/#signature","title":"Signature","text":"<pre><code>def molecule_mean_free_path(\n    molar_mass: ignore = MOLECULAR_WEIGHT_AIR.m,\n    temperature: float = 298.15,\n    pressure: float = 101325,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/gas/properties/thermal_conductivity/","title":"Thermal Conductivity","text":"<p>Particula Index / Particula / Next / Gas / Properties / Thermal Conductivity</p> <p>Auto-generated documentation for particula.next.gas.properties.thermal_conductivity module.</p>"},{"location":"Source-Code/particula/next/gas/properties/thermal_conductivity/#get_thermal_conductivity","title":"get_thermal_conductivity","text":"<p>Show source in thermal_conductivity.py:11</p> <p>Calculate the thermal conductivity of air as a function of temperature. Based on a simplified linear relation from atmospheric science literature. Only valid for temperatures within the range typically found on Earth's surface.</p>"},{"location":"Source-Code/particula/next/gas/properties/thermal_conductivity/#arguments","title":"Arguments","text":"<ul> <li>temperature (Union[float, NDArray[np.float_]]): The temperature at which the thermal conductivity of air is to be calculated, in Kelvin (K).</li> </ul>"},{"location":"Source-Code/particula/next/gas/properties/thermal_conductivity/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The thermal conductivity of air at the specified temperature in Watts per meter-Kelvin (W/m\u00b7K) or J/(m s K).</li> </ul>"},{"location":"Source-Code/particula/next/gas/properties/thermal_conductivity/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the temperature is below absolute zero (0 K).</li> </ul>"},{"location":"Source-Code/particula/next/gas/properties/thermal_conductivity/#references","title":"References","text":"<ul> <li>Seinfeld and Pandis, \"Atmospheric Chemistry and Physics\", Equation 17.54.</li> </ul>"},{"location":"Source-Code/particula/next/gas/properties/thermal_conductivity/#signature","title":"Signature","text":"<pre><code>def get_thermal_conductivity(\n    temperature: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/","title":"Particles","text":"<p>Particula Index / Particula / Next / Particles</p> <p>Auto-generated documentation for particula.next.particles module.</p>"},{"location":"Source-Code/particula/next/particles/#modules","title":"Modules","text":"<ul> <li>Activity Builders</li> <li>Activity Factories</li> <li>Activity Strategies</li> <li>Distribution Builders</li> <li>Distribution Factories</li> <li>Distribution Strategies</li> <li>Properties</li> <li>Representation</li> <li>Surface Builders</li> <li>Surface Factories</li> <li>Surface Strategies</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/","title":"Activity Builders","text":"<p>Particula Index / Particula / Next / Particles / Activity Builders</p> <p>Auto-generated documentation for particula.next.particles.activity_builders module.</p>"},{"location":"Source-Code/particula/next/particles/activity_builders/#idealactivitymassbuilder","title":"IdealActivityMassBuilder","text":"<p>Show source in activity_builders.py:20</p> <p>Builder class for IdealActivityMass objects. No parameters are required to be set.</p>"},{"location":"Source-Code/particula/next/particles/activity_builders/#methods","title":"Methods","text":"<ul> <li><code>-</code> build() - Validate and return the IdealActivityMass object.</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#signature","title":"Signature","text":"<pre><code>class IdealActivityMassBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#idealactivitymassbuilderbuild","title":"IdealActivityMassBuilder().build","text":"<p>Show source in activity_builders.py:33</p> <p>Validate and return the IdealActivityMass object.</p>"},{"location":"Source-Code/particula/next/particles/activity_builders/#returns","title":"Returns","text":"<ul> <li><code>-</code> IdealActivityMass - The validated IdealActivityMass object.</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; ActivityStrategy: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_builders/#see-also_1","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#idealactivitymolarbuilder","title":"IdealActivityMolarBuilder","text":"<p>Show source in activity_builders.py:43</p> <p>Builder class for IdealActivityMolar objects.</p>"},{"location":"Source-Code/particula/next/particles/activity_builders/#methods_1","title":"Methods","text":"<ul> <li>set_molar_mass(molar_mass, molar_mass_units): Set the molar mass of the     particle in kg/mol. Default units are 'kg/mol'.</li> <li><code>-</code> set_parameters(params) - Set the parameters of the IdealActivityMolar     object from a dictionary including optional units.</li> <li><code>-</code> build() - Validate and return the IdealActivityMolar object.</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#signature_2","title":"Signature","text":"<pre><code>class IdealActivityMolarBuilder(BuilderABC, BuilderMolarMassMixin):\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderMolarMassMixin</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#idealactivitymolarbuilderbuild","title":"IdealActivityMolarBuilder().build","text":"<p>Show source in activity_builders.py:63</p> <p>Validate and return the IdealActivityMolar object.</p>"},{"location":"Source-Code/particula/next/particles/activity_builders/#returns_1","title":"Returns","text":"<ul> <li><code>-</code> IdealActivityMolar - The validated IdealActivityMolar object.</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#signature_3","title":"Signature","text":"<pre><code>def build(self) -&gt; ActivityStrategy: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_builders/#see-also_3","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#kappaparameteractivitybuilder","title":"KappaParameterActivityBuilder","text":"<p>Show source in activity_builders.py:74</p> <p>Builder class for KappaParameterActivity objects.</p>"},{"location":"Source-Code/particula/next/particles/activity_builders/#methods_2","title":"Methods","text":"<ul> <li><code>-</code> set_kappa(kappa) - Set the kappa parameter for the activity calculation.</li> <li>set_density(density, density_units): Set the density of the species in     kg/m^3. Default units are 'kg/m^3'.</li> <li>set_molar_mass(molar_mass, molar_mass_units): Set the molar mass of the     species in kg/mol. Default units are 'kg/mol'.</li> <li><code>-</code> set_water_index(water_index) - Set the array index of the species.</li> <li><code>-</code> set_parameters(dict) - Set the parameters of the KappaParameterActivity     object from a dictionary including optional units.</li> <li><code>-</code> build() - Validate and return the KappaParameterActivity object.</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#signature_4","title":"Signature","text":"<pre><code>class KappaParameterActivityBuilder(\n    BuilderABC, BuilderDensityMixin, BuilderMolarMassMixin\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_builders/#see-also_4","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderDensityMixin</li> <li>BuilderMolarMassMixin</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#kappaparameteractivitybuilderbuild","title":"KappaParameterActivityBuilder().build","text":"<p>Show source in activity_builders.py:145</p> <p>Validate and return the KappaParameterActivity object.</p>"},{"location":"Source-Code/particula/next/particles/activity_builders/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> KappaParameterActivity - The validated KappaParameterActivity object.</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#signature_5","title":"Signature","text":"<pre><code>def build(self) -&gt; ActivityStrategy: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_builders/#see-also_5","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#kappaparameteractivitybuilderset_kappa","title":"KappaParameterActivityBuilder().set_kappa","text":"<p>Show source in activity_builders.py:103</p> <p>Set the kappa parameter for the activity calculation.</p>"},{"location":"Source-Code/particula/next/particles/activity_builders/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> kappa - The kappa parameter for the activity calculation.</li> <li><code>-</code> kappa_units - Not used. (for interface consistency)</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#signature_6","title":"Signature","text":"<pre><code>def set_kappa(\n    self, kappa: Union[float, NDArray[np.float_]], kappa_units: Optional[str] = None\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_builders/#kappaparameteractivitybuilderset_water_index","title":"KappaParameterActivityBuilder().set_water_index","text":"<p>Show source in activity_builders.py:124</p> <p>Set the array index of the species.</p>"},{"location":"Source-Code/particula/next/particles/activity_builders/#arguments_1","title":"Arguments","text":"<ul> <li>water_index (int): The array index of the species.</li> <li>water_index_units (str): Not used. (for interface consistency)</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_builders/#signature_7","title":"Signature","text":"<pre><code>def set_water_index(self, water_index: int, water_index_units: Optional[str] = None): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_factories/","title":"Activity Factories","text":"<p>Particula Index / Particula / Next / Particles / Activity Factories</p> <p>Auto-generated documentation for particula.next.particles.activity_factories module.</p>"},{"location":"Source-Code/particula/next/particles/activity_factories/#activityfactory","title":"ActivityFactory","text":"<p>Show source in activity_factories.py:19</p> <p>Factory class to create activity strategy builders for calculating activity and partial pressure of species in a mixture of liquids.</p>"},{"location":"Source-Code/particula/next/particles/activity_factories/#methods","title":"Methods","text":"<ul> <li>get_builders(): Returns the mapping of strategy types to builder instances.</li> <li>get_strategy(strategy_type, parameters): Gets the strategy instance for the specified strategy type.<ul> <li>strategy_type: Type of activity strategy to use, can be 'mass_ideal' (default), 'molar_ideal', or 'kappa_parameter'.</li> <li>parameters(Dict[str, Any], optional): Parameters required for the builder, dependent on the chosen strategy type.<ul> <li>mass_ideal: No parameters are required.</li> <li>molar_ideal: molar_mass</li> <li>kappa | kappa_parameter: kappa, density, molar_mass, water_index</li> </ul> </li> </ul> </li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_factories/#returns","title":"Returns","text":"<ul> <li><code>-</code> ActivityStrategy - An instance of the specified ActivityStrategy.</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_factories/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If an unknown strategy type is provided.</li> <li><code>-</code> ValueError - If any required key is missing during check_keys or     pre_build_check, or if trying to set an invalid parameter.</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_factories/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; strategy_is = ActivityFactory().get_strategy(\"mass_ideal\")\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_factories/#signature","title":"Signature","text":"<pre><code>class ActivityFactory(\n    StrategyFactory[\n        Union[\n            IdealActivityMassBuilder,\n            IdealActivityMolarBuilder,\n            KappaParameterActivityBuilder,\n        ],\n        Union[IdealActivityMass, IdealActivityMolar, KappaParameterActivity],\n    ]\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_factories/#see-also","title":"See also","text":"<ul> <li>IdealActivityMassBuilder</li> <li>IdealActivityMass</li> <li>IdealActivityMolarBuilder</li> <li>IdealActivityMolar</li> <li>KappaParameterActivityBuilder</li> <li>KappaParameterActivity</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_factories/#activityfactoryget_builders","title":"ActivityFactory().get_builders","text":"<p>Show source in activity_factories.py:65</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"Source-Code/particula/next/particles/activity_factories/#returns_1","title":"Returns","text":"<ul> <li>Dict[str, Any]: A dictionary mapping strategy types to builder     instances.<ul> <li><code>-</code> mass_ideal - IdealActivityMassBuilder</li> <li><code>-</code> molar_ideal - IdealActivityMolarBuilder</li> <li><code>-</code> kappa_parameter - KappaParameterActivityBuilder</li> </ul> </li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_strategies/","title":"Activity Strategies","text":"<p>Particula Index / Particula / Next / Particles / Activity Strategies</p> <p>Auto-generated documentation for particula.next.particles.activity_strategies module.</p>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#activitystrategy","title":"ActivityStrategy","text":"<p>Show source in activity_strategies.py:19</p> <p>Abstract base class for implementing vapor pressure strategies based on particle activity calculations.</p>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#signature","title":"Signature","text":"<pre><code>class ActivityStrategy(ABC): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#activitystrategyactivity","title":"ActivityStrategy().activity","text":"<p>Show source in activity_strategies.py:25</p> <p>Calculate the activity of a species based on its mass concentration.</p>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#arguments","title":"Arguments","text":"<ul> <li>mass_concentration (float or NDArray[float]): Concentration of the species [kg/m^3]</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#returns","title":"Returns","text":"<ul> <li>float or NDArray[float]: Activity of the particle, unitless.</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef activity(\n    self, mass_concentration: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#activitystrategypartial_pressure","title":"ActivityStrategy().partial_pressure","text":"<p>Show source in activity_strategies.py:40</p> <p>Calculate the vapor pressure of species in the particle phase based on activity.</p>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#arguments_1","title":"Arguments","text":"<ul> <li>pure_vapor_pressure (float or NDArray[float]): Pure vapor pressure of the species [Pa]</li> <li>mass_concentration (float or NDArray[float]): Concentration of the species [kg/m^3]</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#returns_1","title":"Returns","text":"<ul> <li>float or NDArray[float]: Vapor pressure of the particle [Pa].</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#signature_2","title":"Signature","text":"<pre><code>def partial_pressure(\n    self,\n    pure_vapor_pressure: Union[float, NDArray[np.float_]],\n    mass_concentration: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#idealactivitymass","title":"IdealActivityMass","text":"<p>Show source in activity_strategies.py:105</p> <p>Ideal activity strategy, based on mass fractions.</p>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#arguments_2","title":"Arguments","text":"<ul> <li>None needed</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#references","title":"References","text":"<ul> <li>Mass Based Raoult's Law https://en.wikipedia.org/wiki/Raoult%27s_law</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#signature_3","title":"Signature","text":"<pre><code>class IdealActivityMass(ActivityStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#see-also","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#idealactivitymassactivity","title":"IdealActivityMass().activity","text":"<p>Show source in activity_strategies.py:117</p> <p>Calculate the activity of a species.</p>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#arguments_3","title":"Arguments","text":"<ul> <li>mass_concentration (float): Concentration of the species [kg/m^3]</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> float - Activity of the particle [unitless].</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#signature_4","title":"Signature","text":"<pre><code>def activity(\n    self, mass_concentration: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#idealactivitymolar","title":"IdealActivityMolar","text":"<p>Show source in activity_strategies.py:62</p> <p>Ideal activity strategy, based on mole fractions.</p>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#arguments_4","title":"Arguments","text":"<ul> <li>molar_mass (Union[float, NDArray[np.float_]]): Molar mass of the species [kg/mol]. If a single value is provided, it will be used for all species.</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#references_1","title":"References","text":"<ul> <li>Molar Based Raoult's Law https://en.wikipedia.org/wiki/Raoult%27s_law</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#signature_5","title":"Signature","text":"<pre><code>class IdealActivityMolar(ActivityStrategy):\n    def __init__(self, molar_mass: Union[float, NDArray[np.float_]] = 0.0): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#see-also_1","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#idealactivitymolaractivity","title":"IdealActivityMolar().activity","text":"<p>Show source in activity_strategies.py:81</p> <p>Calculate the activity of a species.</p>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#arguments_5","title":"Arguments","text":"<ul> <li>mass_concentration (float): Concentration of the species [kg/m^3]</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#returns_3","title":"Returns","text":"<ul> <li><code>-</code> float - Activity of the particle [unitless].</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#signature_6","title":"Signature","text":"<pre><code>def activity(\n    self, mass_concentration: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#kappaparameteractivity","title":"KappaParameterActivity","text":"<p>Show source in activity_strategies.py:138</p> <p>Non-ideal activity strategy, based on kappa hygroscopic parameter for non-ideal water, and mole fraction for other species.</p>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#arguments_6","title":"Arguments","text":"<ul> <li>kappa (NDArray[np.float_]): Kappa hygroscopic parameter [unitless], include a value for water (that will be removed in the calculation).</li> <li>density (NDArray[np.float_]): Density of the species [kg/m^3].</li> <li>molar_mass (NDArray[np.float_]): Molar mass of the species [kg/mol].</li> <li>water_index (int): Index of water in the mass_concentration array.</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#signature_7","title":"Signature","text":"<pre><code>class KappaParameterActivity(ActivityStrategy):\n    def __init__(\n        self,\n        kappa: NDArray[np.float_] = np.array([0.0], dtype=np.float_),\n        density: NDArray[np.float_] = np.array([0.0], dtype=np.float_),\n        molar_mass: NDArray[np.float_] = np.array([0.0], dtype=np.float_),\n        water_index: int = 0,\n    ): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#see-also_2","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#kappaparameteractivityactivity","title":"KappaParameterActivity().activity","text":"<p>Show source in activity_strategies.py:163</p> <p>Calculate the activity of a species.</p>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#arguments_7","title":"Arguments","text":"<ul> <li>mass_concentration (float): Concentration of the species [kg/m^3]</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#returns_4","title":"Returns","text":"<ul> <li><code>-</code> float - Activity of the particle [unitless].</li> </ul>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#references_2","title":"References","text":"<p>Petters, M. D., &amp; Kreidenweis, S. M. (2007). A single parameter representation of hygroscopic growth and cloud condensation nucleus activity. Atmospheric Chemistry and Physics, 7(8), 1961-1971. https://doi.org/10.5194/acp-7-1961-2007 EQ 2 and 7</p>"},{"location":"Source-Code/particula/next/particles/activity_strategies/#signature_8","title":"Signature","text":"<pre><code>def activity(\n    self, mass_concentration: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_builders/","title":"Distribution Builders","text":"<p>Particula Index / Particula / Next / Particles / Distribution Builders</p> <p>Auto-generated documentation for particula.next.particles.distribution_builders module.</p>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#massbasedmovingbinbuilder","title":"MassBasedMovingBinBuilder","text":"<p>Show source in distribution_builders.py:14</p> <p>Builds a MassBasedMovingBin instance.</p>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#signature","title":"Signature","text":"<pre><code>class MassBasedMovingBinBuilder(BuilderABC):\n    def __init__(self) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#massbasedmovingbinbuilderbuild","title":"MassBasedMovingBinBuilder().build","text":"<p>Show source in distribution_builders.py:21</p> <p>Builds a MassBasedMovingBin instance.</p>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; MassBasedMovingBin: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#see-also_1","title":"See also","text":"<ul> <li>MassBasedMovingBin</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#radiibasedmovingbinbuilder","title":"RadiiBasedMovingBinBuilder","text":"<p>Show source in distribution_builders.py:26</p> <p>Builds a RadiiBasedMovingBin instance.</p>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#signature_2","title":"Signature","text":"<pre><code>class RadiiBasedMovingBinBuilder(BuilderABC):\n    def __init__(self) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#radiibasedmovingbinbuilderbuild","title":"RadiiBasedMovingBinBuilder().build","text":"<p>Show source in distribution_builders.py:33</p> <p>Builds a RadiiBasedMovingBin instance.</p>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#signature_3","title":"Signature","text":"<pre><code>def build(self) -&gt; RadiiBasedMovingBin: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#see-also_3","title":"See also","text":"<ul> <li>RadiiBasedMovingBin</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#speciatedmassmovingbinbuilder","title":"SpeciatedMassMovingBinBuilder","text":"<p>Show source in distribution_builders.py:38</p> <p>Builds a SpeciatedMassMovingBin instance.</p>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#signature_4","title":"Signature","text":"<pre><code>class SpeciatedMassMovingBinBuilder(BuilderABC):\n    def __init__(self) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#see-also_4","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#speciatedmassmovingbinbuilderbuild","title":"SpeciatedMassMovingBinBuilder().build","text":"<p>Show source in distribution_builders.py:45</p> <p>Builds a SpeciatedMassMovingBin instance.</p>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#signature_5","title":"Signature","text":"<pre><code>def build(self) -&gt; SpeciatedMassMovingBin: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_builders/#see-also_5","title":"See also","text":"<ul> <li>SpeciatedMassMovingBin</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_factories/","title":"Distribution Factories","text":"<p>Particula Index / Particula / Next / Particles / Distribution Factories</p> <p>Auto-generated documentation for particula.next.particles.distribution_factories module.</p>"},{"location":"Source-Code/particula/next/particles/distribution_factories/#distributionfactory","title":"DistributionFactory","text":"<p>Show source in distribution_factories.py:15</p> <p>Factory class to create distribution strategy builders for calculating particle distributions based on the specified representation type.</p>"},{"location":"Source-Code/particula/next/particles/distribution_factories/#methods","title":"Methods","text":"<ul> <li>get_builders(): Returns the mapping of strategy types to builder instances.</li> <li>get_strategy(strategy_type, parameters): Gets the strategy instance for the specified strategy type.<ul> <li>strategy_type: Type of distribution strategy to use, can be 'mass_based_moving_bin', 'radii_based_moving_bin', or 'speciated_mass_moving_bin'.</li> <li>parameters(Dict[str, Any], optional): Parameters required for the builder, dependent on the chosen strategy type.<ul> <li>mass_based_moving_bin: None</li> <li>radii_based_moving_bin: None</li> <li>speciated_mass_moving_bin: None</li> </ul> </li> </ul> </li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_factories/#returns","title":"Returns","text":"<ul> <li><code>-</code> DistributionStrategy - An instance of the specified DistributionStrategy.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_factories/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If an unknown strategy type is provided.</li> <li><code>-</code> ValueError - If any required key is missing during check_keys or     pre_build_check, or if trying to set an invalid parameter.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_factories/#signature","title":"Signature","text":"<pre><code>class DistributionFactory(\n    StrategyFactory[\n        Union[\n            MassBasedMovingBinBuilder,\n            RadiiBasedMovingBinBuilder,\n            SpeciatedMassMovingBinBuilder,\n        ],\n        Union[MassBasedMovingBin, RadiiBasedMovingBin, SpeciatedMassMovingBin],\n    ]\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_factories/#see-also","title":"See also","text":"<ul> <li>MassBasedMovingBinBuilder</li> <li>MassBasedMovingBin</li> <li>RadiiBasedMovingBinBuilder</li> <li>RadiiBasedMovingBin</li> <li>SpeciatedMassMovingBinBuilder</li> <li>SpeciatedMassMovingBin</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_factories/#distributionfactoryget_builders","title":"DistributionFactory().get_builders","text":"<p>Show source in distribution_factories.py:59</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"Source-Code/particula/next/particles/distribution_factories/#returns_1","title":"Returns","text":"<ul> <li>Dict[str, BuilderABC]: Mapping of strategy types to builder instances.<ul> <li><code>-</code> 'mass_based_moving_bin' - MassBasedMovingBinBuilder</li> <li><code>-</code> 'radii_based_moving_bin' - RadiiBasedMovingBinBuilder</li> <li><code>-</code> 'speciated_mass_moving_bin' - SpeciatedMassMovingBinBuilder</li> </ul> </li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/","title":"Distribution Strategies","text":"<p>Particula Index / Particula / Next / Particles / Distribution Strategies</p> <p>Auto-generated documentation for particula.next.particles.distribution_strategies module.</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#distributionstrategy","title":"DistributionStrategy","text":"<p>Show source in distribution_strategies.py:11</p> <p>Abstract base class for particle strategy, defining the common interface for mass, radius, and total mass calculations for different particle representations.</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature","title":"Signature","text":"<pre><code>class DistributionStrategy(ABC): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#distributionstrategyadd_mass","title":"DistributionStrategy().add_mass","text":"<p>Show source in distribution_strategies.py:78</p> <p>Adds mass to the distribution of particles based on their distribution, concentration, and density.</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#arguments","title":"Arguments","text":"<ul> <li>distribution (NDArray[np.float_]): The distribution representation of particles</li> <li>concentration (NDArray[np.float_]): The concentration of each particle in the distribution.</li> <li>density (NDArray[np.float_]): The density of the particles.</li> <li>added_mass (NDArray[np.float_]): The mass to be added per distribution bin.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#returns","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - The new concentration array.</li> <li><code>-</code> NDArray[np.float_] - The new distribution array.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef add_mass(\n    self,\n    distribution: NDArray[np.float_],\n    concentration: NDArray[np.float_],\n    density: NDArray[np.float_],\n    added_mass: NDArray[np.float_],\n) -&gt; tuple[NDArray[np.float_], NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#distributionstrategyget_mass","title":"DistributionStrategy().get_mass","text":"<p>Show source in distribution_strategies.py:18</p> <p>Calculates the mass of particles based on their distribution and density.</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#arguments_1","title":"Arguments","text":"<ul> <li>distribution (NDArray[np.float_]): The distribution of particle     sizes or masses.</li> <li>density (NDArray[np.float_]): The density of the particles.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#returns_1","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - The mass of the particles.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_2","title":"Signature","text":"<pre><code>@abstractmethod\ndef get_mass(\n    self, distribution: NDArray[np.float_], density: NDArray[np.float_]\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#distributionstrategyget_radius","title":"DistributionStrategy().get_radius","text":"<p>Show source in distribution_strategies.py:37</p> <p>Calculates the radius of particles based on their distribution and density.</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#arguments_2","title":"Arguments","text":"<ul> <li>distribution (NDArray[np.float_]): The distribution of particle     sizes or masses.</li> <li>density (NDArray[np.float_]): The density of the particles.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - The radius of the particles.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_3","title":"Signature","text":"<pre><code>@abstractmethod\ndef get_radius(\n    self, distribution: NDArray[np.float_], density: NDArray[np.float_]\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#distributionstrategyget_total_mass","title":"DistributionStrategy().get_total_mass","text":"<p>Show source in distribution_strategies.py:56</p> <p>Calculates the total mass of particles based on their distribution, concentration, and density.</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#arguments_3","title":"Arguments","text":"<ul> <li>distribution (NDArray[np.float_]): The distribution of particle     sizes or masses.</li> <li>concentration (NDArray[np.float_]): The concentration of each     particle size or mass in the distribution.</li> <li>density (NDArray[np.float_]): The density of the particles.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#returns_3","title":"Returns","text":"<ul> <li><code>-</code> np.float_ - The total mass of the particles.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_4","title":"Signature","text":"<pre><code>@abstractmethod\ndef get_total_mass(\n    self,\n    distribution: NDArray[np.float_],\n    concentration: NDArray[np.float_],\n    density: NDArray[np.float_],\n) -&gt; np.float_: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#massbasedmovingbin","title":"MassBasedMovingBin","text":"<p>Show source in distribution_strategies.py:105</p> <p>A strategy for particles represented by their mass distribution, and particle number concentration. Moving the bins when adding mass.</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_5","title":"Signature","text":"<pre><code>class MassBasedMovingBin(DistributionStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#see-also","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#massbasedmovingbinadd_mass","title":"MassBasedMovingBin().add_mass","text":"<p>Show source in distribution_strategies.py:139</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_6","title":"Signature","text":"<pre><code>def add_mass(\n    self,\n    distribution: NDArray[np.float_],\n    concentration: NDArray[np.float_],\n    density: NDArray[np.float_],\n    added_mass: NDArray[np.float_],\n) -&gt; tuple[NDArray[np.float_], NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#massbasedmovingbinget_mass","title":"MassBasedMovingBin().get_mass","text":"<p>Show source in distribution_strategies.py:111</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_7","title":"Signature","text":"<pre><code>def get_mass(\n    self, distribution: NDArray[np.float_], density: NDArray[np.float_]\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#massbasedmovingbinget_radius","title":"MassBasedMovingBin().get_radius","text":"<p>Show source in distribution_strategies.py:119</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_8","title":"Signature","text":"<pre><code>def get_radius(\n    self, distribution: NDArray[np.float_], density: NDArray[np.float_]\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#massbasedmovingbinget_total_mass","title":"MassBasedMovingBin().get_total_mass","text":"<p>Show source in distribution_strategies.py:129</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_9","title":"Signature","text":"<pre><code>def get_total_mass(\n    self,\n    distribution: NDArray[np.float_],\n    concentration: NDArray[np.float_],\n    density: NDArray[np.float_],\n) -&gt; np.float_: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#radiibasedmovingbin","title":"RadiiBasedMovingBin","text":"<p>Show source in distribution_strategies.py:150</p> <p>A strategy for particles represented by their radius (distribution), and particle concentration. Implementing the DistributionStrategy interface. This strategy calculates particle mass, radius, and total mass based on the particle's radius, number concentration, and density.</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_10","title":"Signature","text":"<pre><code>class RadiiBasedMovingBin(DistributionStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#see-also_1","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#radiibasedmovingbinadd_mass","title":"RadiiBasedMovingBin().add_mass","text":"<p>Show source in distribution_strategies.py:186</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_11","title":"Signature","text":"<pre><code>def add_mass(\n    self,\n    distribution: NDArray[np.float_],\n    concentration: NDArray[np.float_],\n    density: NDArray[np.float_],\n    added_mass: NDArray[np.float_],\n) -&gt; tuple[NDArray[np.float_], NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#radiibasedmovingbinget_mass","title":"RadiiBasedMovingBin().get_mass","text":"<p>Show source in distribution_strategies.py:159</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_12","title":"Signature","text":"<pre><code>def get_mass(\n    self, distribution: NDArray[np.float_], density: NDArray[np.float_]\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#radiibasedmovingbinget_radius","title":"RadiiBasedMovingBin().get_radius","text":"<p>Show source in distribution_strategies.py:168</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_13","title":"Signature","text":"<pre><code>def get_radius(\n    self, distribution: NDArray[np.float_], density: NDArray[np.float_]\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#radiibasedmovingbinget_total_mass","title":"RadiiBasedMovingBin().get_total_mass","text":"<p>Show source in distribution_strategies.py:175</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_14","title":"Signature","text":"<pre><code>def get_total_mass(\n    self,\n    distribution: NDArray[np.float_],\n    concentration: NDArray[np.float_],\n    density: NDArray[np.float_],\n) -&gt; np.float_: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#speciatedmassmovingbin","title":"SpeciatedMassMovingBin","text":"<p>Show source in distribution_strategies.py:198</p> <p>Strategy for particles with speciated mass distribution. Some particles may have different densities and their mass is distributed across different species. This strategy calculates mass, radius, and total mass based on the species at each mass, density, the particle concentration.</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_15","title":"Signature","text":"<pre><code>class SpeciatedMassMovingBin(DistributionStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#see-also_2","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#speciatedmassmovingbinadd_mass","title":"SpeciatedMassMovingBin().add_mass","text":"<p>Show source in distribution_strategies.py:274</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_16","title":"Signature","text":"<pre><code>def add_mass(\n    self,\n    distribution: NDArray[np.float_],\n    concentration: NDArray[np.float_],\n    density: NDArray[np.float_],\n    added_mass: NDArray[np.float_],\n) -&gt; tuple[NDArray[np.float_], NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#speciatedmassmovingbinget_mass","title":"SpeciatedMassMovingBin().get_mass","text":"<p>Show source in distribution_strategies.py:205</p> <p>Calculates the mass for each mass and species, leveraging densities for adjustment.</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#arguments_4","title":"Arguments","text":"<ul> <li>distribution (NDArray[np.float_]): A 2D array with rows     representing mass bins and columns representing species.</li> <li>densities (NDArray[np.float_]): An array of densities for each     species.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#returns_4","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - A 1D array of calculated masses for each mass     bin. The sum of each column (species) in the distribution matrix.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_17","title":"Signature","text":"<pre><code>def get_mass(\n    self, distribution: NDArray[np.float_], density: NDArray[np.float_]\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#speciatedmassmovingbinget_radius","title":"SpeciatedMassMovingBin().get_radius","text":"<p>Show source in distribution_strategies.py:229</p> <p>Calculates the radius for each mass bin and species, based on the volume derived from mass and density.</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#arguments_5","title":"Arguments","text":"<ul> <li>distribution (NDArray[np.float_]): A 2D array with rows representing     mass bins and columns representing species.</li> <li>density (NDArray[np.float_]): An array of densities for each     species.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#returns_5","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - A 1D array of calculated radii for each mass     bin.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_18","title":"Signature","text":"<pre><code>def get_radius(\n    self, distribution: NDArray[np.float_], density: NDArray[np.float_]\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#speciatedmassmovingbinget_total_mass","title":"SpeciatedMassMovingBin().get_total_mass","text":"<p>Show source in distribution_strategies.py:252</p> <p>Calculates the total mass of all species, incorporating the concentration of particles per species.</p>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#arguments_6","title":"Arguments","text":"<ul> <li>distribution (NDArray[np.float_]): The mass distribution matrix.</li> <li>counts (NDArray[np.float_]): A 1D array with elements representing     the count of particles for each species.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#returns_6","title":"Returns","text":"<ul> <li><code>-</code> np.float_ - The total mass of all particles.</li> </ul>"},{"location":"Source-Code/particula/next/particles/distribution_strategies/#signature_19","title":"Signature","text":"<pre><code>def get_total_mass(\n    self,\n    distribution: NDArray[np.float_],\n    concentration: NDArray[np.float_],\n    density: NDArray[np.float_],\n) -&gt; np.float_: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/representation/","title":"Representation","text":"<p>Particula Index / Particula / Next / Particles / Representation</p> <p>Auto-generated documentation for particula.next.particles.representation module.</p>"},{"location":"Source-Code/particula/next/particles/representation/#particlerepresentation","title":"ParticleRepresentation","text":"<p>Show source in representation.py:14</p> <p>Represents a particle or a collection of particles, encapsulating the strategy for calculating mass, radius, and total mass based on a specified particle distribution, density, and concentration. This class allows for flexibility in representing particles.</p>"},{"location":"Source-Code/particula/next/particles/representation/#attributes","title":"Attributes","text":"<ul> <li>strategy (ParticleStrategy): The computation strategy for particle representations.</li> <li>activity (ParticleActivityStrategy): The activity strategy for the partial pressure calculations.</li> <li>surface (SurfaceStrategy): The surface strategy for surface tension and Kelvin effect.</li> <li>distribution (NDArray[np.float_]): The distribution data for the particles, which could represent sizes, masses, or another relevant metric.</li> <li>density (np.float_): The density of the material from which the particles are made.</li> <li>concentration (NDArray[np.float_]): The concentration of particles within the distribution.</li> </ul>"},{"location":"Source-Code/particula/next/particles/representation/#signature","title":"Signature","text":"<pre><code>class ParticleRepresentation:\n    def __init__(\n        self,\n        strategy: DistributionStrategy,\n        activity: ActivityStrategy,\n        surface: SurfaceStrategy,\n        distribution: NDArray[np.float_],\n        density: NDArray[np.float_],\n        concentration: NDArray[np.float_],\n        charge: NDArray[np.float_],\n    ): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/representation/#see-also","title":"See also","text":"<ul> <li>ActivityStrategy</li> <li>DistributionStrategy</li> <li>SurfaceStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/representation/#particlerepresentationadd_concentration","title":"ParticleRepresentation().add_concentration","text":"<p>Show source in representation.py:117</p> <p>Adds concentration to the particle distribution, updating the concentration array.</p>"},{"location":"Source-Code/particula/next/particles/representation/#arguments","title":"Arguments","text":"<ul> <li>added_concentration (NDArray[np.float_]): The concentration to be     added per distribution bin.</li> </ul>"},{"location":"Source-Code/particula/next/particles/representation/#signature_1","title":"Signature","text":"<pre><code>def add_concentration(self, added_concentration: NDArray[np.float_]) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/representation/#particlerepresentationadd_mass","title":"ParticleRepresentation().add_mass","text":"<p>Show source in representation.py:105</p> <p>Adds mass to the particle distribution, updating the concentration and distribution arrays.</p>"},{"location":"Source-Code/particula/next/particles/representation/#arguments_1","title":"Arguments","text":"<ul> <li>added_mass (NDArray[np.float_]): The mass to be added per     distribution bin.</li> </ul>"},{"location":"Source-Code/particula/next/particles/representation/#signature_2","title":"Signature","text":"<pre><code>def add_mass(self, added_mass: NDArray[np.float_]) -&gt; None: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/representation/#particlerepresentationget_charge","title":"ParticleRepresentation().get_charge","text":"<p>Show source in representation.py:85</p> <p>Returns the charge per particle.</p>"},{"location":"Source-Code/particula/next/particles/representation/#returns","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - The charge of the particles.</li> </ul>"},{"location":"Source-Code/particula/next/particles/representation/#signature_3","title":"Signature","text":"<pre><code>def get_charge(self) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/representation/#particlerepresentationget_mass","title":"ParticleRepresentation().get_mass","text":"<p>Show source in representation.py:67</p> <p>Returns the mass of the particles as calculated by the strategy.</p>"},{"location":"Source-Code/particula/next/particles/representation/#returns_1","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - The mass of the particles.</li> </ul>"},{"location":"Source-Code/particula/next/particles/representation/#signature_4","title":"Signature","text":"<pre><code>def get_mass(self) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/representation/#particlerepresentationget_radius","title":"ParticleRepresentation().get_radius","text":"<p>Show source in representation.py:76</p> <p>Returns the radius of the particles as calculated by the strategy.</p>"},{"location":"Source-Code/particula/next/particles/representation/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> NDArray[np.float_] - The radius of the particles.</li> </ul>"},{"location":"Source-Code/particula/next/particles/representation/#signature_5","title":"Signature","text":"<pre><code>def get_radius(self) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/representation/#particlerepresentationget_total_mass","title":"ParticleRepresentation().get_total_mass","text":"<p>Show source in representation.py:94</p> <p>Returns the total mass of the particles as calculated by the strategy, taking into account the distribution and concentration.</p>"},{"location":"Source-Code/particula/next/particles/representation/#returns_3","title":"Returns","text":"<ul> <li><code>np.float_</code> - The total mass of the particles.</li> </ul>"},{"location":"Source-Code/particula/next/particles/representation/#signature_6","title":"Signature","text":"<pre><code>def get_total_mass(self) -&gt; np.float_: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_builders/","title":"Surface Builders","text":"<p>Particula Index / Particula / Next / Particles / Surface Builders</p> <p>Auto-generated documentation for particula.next.particles.surface_builders module.</p>"},{"location":"Source-Code/particula/next/particles/surface_builders/#surfacestrategymassbuilder","title":"SurfaceStrategyMassBuilder","text":"<p>Show source in surface_builders.py:68</p> <p>Builder class for SurfaceStrategyMass objects.</p>"},{"location":"Source-Code/particula/next/particles/surface_builders/#methods","title":"Methods","text":"<ul> <li>set_surface_tension(surface_tension, surface_tension_units): Set the     surface tension of the particle in N/m. Default units are 'N/m'.</li> <li>set_density(density, density_units): Set the density of the particle in     kg/m^3. Default units are 'kg/m^3'.</li> <li><code>-</code> set_parameters(params) - Set the parameters of the SurfaceStrategyMass     object from a dictionary including optional units.</li> <li><code>-</code> build() - Validate and return the SurfaceStrategyMass object.</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_builders/#signature","title":"Signature","text":"<pre><code>class SurfaceStrategyMassBuilder(\n    BuilderABC, BuilderSurfaceTensionMixin, BuilderDensityMixin\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderDensityMixin</li> <li>BuilderSurfaceTensionMixin</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_builders/#surfacestrategymassbuilderbuild","title":"SurfaceStrategyMassBuilder().build","text":"<p>Show source in surface_builders.py:92</p> <p>Validate and return the SurfaceStrategyMass object.</p>"},{"location":"Source-Code/particula/next/particles/surface_builders/#returns","title":"Returns","text":"<ul> <li><code>-</code> SurfaceStrategyMass - Instance of the SurfaceStrategyMass object.</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; SurfaceStrategyMass: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_builders/#see-also_1","title":"See also","text":"<ul> <li>SurfaceStrategyMass</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_builders/#surfacestrategymolarbuilder","title":"SurfaceStrategyMolarBuilder","text":"<p>Show source in surface_builders.py:25</p> <p>Builder class for SurfaceStrategyMolar objects.</p>"},{"location":"Source-Code/particula/next/particles/surface_builders/#methods_1","title":"Methods","text":"<ul> <li>set_surface_tension(surface_tension, surface_tension_units): Set the     surface tension of the particle in N/m. Default units are 'N/m'.</li> <li>set_density(density, density_units): Set the density of the particle in     kg/m^3. Default units are 'kg/m^3'.</li> <li>set_molar_mass(molar_mass, molar_mass_units): Set the molar mass of the     particle in kg/mol. Default units are 'kg/mol'.</li> <li><code>-</code> set_parameters(params) - Set the parameters of the SurfaceStrategyMolar     object from a dictionary including optional units.</li> <li><code>-</code> build() - Validate and return the SurfaceStrategyMolar object.</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_builders/#signature_2","title":"Signature","text":"<pre><code>class SurfaceStrategyMolarBuilder(\n    BuilderABC, BuilderDensityMixin, BuilderSurfaceTensionMixin, BuilderMolarMassMixin\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderDensityMixin</li> <li>BuilderMolarMassMixin</li> <li>BuilderSurfaceTensionMixin</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_builders/#surfacestrategymolarbuilderbuild","title":"SurfaceStrategyMolarBuilder().build","text":"<p>Show source in surface_builders.py:53</p> <p>Validate and return the SurfaceStrategyMass object.</p>"},{"location":"Source-Code/particula/next/particles/surface_builders/#returns_1","title":"Returns","text":"<ul> <li><code>-</code> SurfaceStrategyMolar - Instance of the SurfaceStrategyMolar object.</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_builders/#signature_3","title":"Signature","text":"<pre><code>def build(self) -&gt; SurfaceStrategyMolar: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_builders/#see-also_3","title":"See also","text":"<ul> <li>SurfaceStrategyMolar</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_builders/#surfacestrategyvolumebuilder","title":"SurfaceStrategyVolumeBuilder","text":"<p>Show source in surface_builders.py:106</p> <p>Builder class for SurfaceStrategyVolume objects.</p>"},{"location":"Source-Code/particula/next/particles/surface_builders/#methods_2","title":"Methods","text":"<ul> <li>set_surface_tension(surface_tension, surface_tension_units): Set the     surface tension of the particle in N/m. Default units are 'N/m'.</li> <li>set_density(density, density_units): Set the density of the particle in     kg/m^3. Default units are 'kg/m^3'.</li> <li><code>-</code> set_parameters(params) - Set the parameters of the SurfaceStrategyVolume     object from a dictionary including optional units.</li> <li><code>-</code> build() - Validate and return the SurfaceStrategyVolume object.</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_builders/#signature_4","title":"Signature","text":"<pre><code>class SurfaceStrategyVolumeBuilder(\n    BuilderABC, BuilderSurfaceTensionMixin, BuilderDensityMixin\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_builders/#see-also_4","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderDensityMixin</li> <li>BuilderSurfaceTensionMixin</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_builders/#surfacestrategyvolumebuilderbuild","title":"SurfaceStrategyVolumeBuilder().build","text":"<p>Show source in surface_builders.py:130</p> <p>Validate and return the SurfaceStrategyVolume object.</p>"},{"location":"Source-Code/particula/next/particles/surface_builders/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> SurfaceStrategyVolume - Instance of the SurfaceStrategyVolume object.</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_builders/#signature_5","title":"Signature","text":"<pre><code>def build(self) -&gt; SurfaceStrategyVolume: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_builders/#see-also_5","title":"See also","text":"<ul> <li>SurfaceStrategyVolume</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_factories/","title":"Surface Factories","text":"<p>Particula Index / Particula / Next / Particles / Surface Factories</p> <p>Auto-generated documentation for particula.next.particles.surface_factories module.</p>"},{"location":"Source-Code/particula/next/particles/surface_factories/#surfacefactory","title":"SurfaceFactory","text":"<p>Show source in surface_factories.py:17</p> <p>Factory class to create surface tension strategy builders for calculating surface tension and the Kelvin effect for species in particulate phases.</p>"},{"location":"Source-Code/particula/next/particles/surface_factories/#methods","title":"Methods","text":"<ul> <li>get_builders(): Returns the mapping of strategy types to builder instances.</li> <li>get_strategy(strategy_type, parameters): Gets the strategy instance for the specified strategy type.<ul> <li>strategy_type: Type of surface tension strategy to use, can be 'volume', 'mass', or 'molar'.</li> <li>parameters(Dict[str, Any], optional): Parameters required for the builder, dependent on the chosen strategy type.<ul> <li>volume: density, surface_tension</li> <li>mass: density, surface_tension</li> <li>molar: molar_mass, density, surface_tension</li> </ul> </li> </ul> </li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_factories/#returns","title":"Returns","text":"<ul> <li><code>-</code> SurfaceStrategy - An instance of the specified SurfaceStrategy.</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_factories/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If an unknown strategy type is provided.</li> <li><code>-</code> ValueError - If any required key is missing during check_keys or     pre_build_check, or if trying to set an invalid parameter.</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_factories/#signature","title":"Signature","text":"<pre><code>class SurfaceFactory(\n    StrategyFactory[\n        Union[\n            SurfaceStrategyVolumeBuilder,\n            SurfaceStrategyMassBuilder,\n            SurfaceStrategyMolarBuilder,\n        ],\n        Union[SurfaceStrategyVolume, SurfaceStrategyMass, SurfaceStrategyMolar],\n    ]\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_factories/#see-also","title":"See also","text":"<ul> <li>SurfaceStrategyMassBuilder</li> <li>SurfaceStrategyMass</li> <li>SurfaceStrategyMolarBuilder</li> <li>SurfaceStrategyMolar</li> <li>SurfaceStrategyVolumeBuilder</li> <li>SurfaceStrategyVolume</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_factories/#surfacefactoryget_builders","title":"SurfaceFactory().get_builders","text":"<p>Show source in surface_factories.py:60</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"Source-Code/particula/next/particles/surface_factories/#returns_1","title":"Returns","text":"<ul> <li>Dict[str, BuilderT]: A dictionary mapping strategy types to     builder instances.<ul> <li><code>-</code> volume - SurfaceStrategyVolumeBuilder</li> <li><code>-</code> mass - SurfaceStrategyMassBuilder</li> <li><code>-</code> molar - SurfaceStrategyMolarBuilder</li> </ul> </li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/","title":"Surface Strategies","text":"<p>Particula Index / Particula / Next / Particles / Surface Strategies</p> <p>Auto-generated documentation for particula.next.particles.surface_strategies module.</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategy","title":"SurfaceStrategy","text":"<p>Show source in surface_strategies.py:16</p> <p>Abstract class for implementing strategies to calculate surface tension and the Kelvin effect for species in particulate phases.</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature","title":"Signature","text":"<pre><code>class SurfaceStrategy(ABC): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategyeffective_density","title":"SurfaceStrategy().effective_density","text":"<p>Show source in surface_strategies.py:41</p> <p>Calculate the effective density of species based on their concentration.</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#arguments","title":"Arguments","text":"<ul> <li>mass_concentration (float or NDArray[float]): Concentration of the species [kg/m^3].</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#returns","title":"Returns","text":"<ul> <li>float or NDArray[float]: Effective density of the species [kg/m^3].</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef effective_density(\n    self, mass_concentration: Union[float, NDArray[np.float_]]\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategyeffective_surface_tension","title":"SurfaceStrategy().effective_surface_tension","text":"<p>Show source in surface_strategies.py:22</p> <p>Calculate the effective surface tension of species based on their concentration.</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#arguments_1","title":"Arguments","text":"<ul> <li>mass_concentration (float or NDArray[float]): Concentration of the species [kg/m^3].</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#returns_1","title":"Returns","text":"<ul> <li>float or NDArray[float]: Effective surface tension [N/m].</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_2","title":"Signature","text":"<pre><code>@abstractmethod\ndef effective_surface_tension(\n    self, mass_concentration: Union[float, NDArray[np.float_]]\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategykelvin_radius","title":"SurfaceStrategy().kelvin_radius","text":"<p>Show source in surface_strategies.py:60</p> <p>Calculate the Kelvin radius which determines the curvature effect on vapor pressure.</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#arguments_2","title":"Arguments","text":"<ul> <li>surface_tension (float or NDArray[float]): Surface tension of the mixture [N/m].</li> <li>molar_mass (float or NDArray[float]): Molar mass of the species [kg/mol].</li> <li>mass_concentration (float or NDArray[float]): Concentration of the species [kg/m^3].</li> <li>temperature (float): Temperature of the system [K].</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#returns_2","title":"Returns","text":"<ul> <li>float or NDArray[float]: Kelvin radius [m].</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#references","title":"References","text":"<ul> <li>Based on Neil Donahue's approach to the Kelvin equation: r = 2 * surface_tension * molar_mass / (R * T * density)</li> <li><code>See</code> more - https://en.wikipedia.org/wiki/Kelvin_equation</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_3","title":"Signature","text":"<pre><code>def kelvin_radius(\n    self,\n    molar_mass: Union[float, NDArray[np.float_]],\n    mass_concentration: Union[float, NDArray[np.float_]],\n    temperature: float,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategykelvin_term","title":"SurfaceStrategy().kelvin_term","text":"<p>Show source in surface_strategies.py:97</p> <p>Calculate the Kelvin term, which quantifies the effect of particle curvature on vapor pressure.</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#arguments_3","title":"Arguments","text":"<ul> <li>radius (float or NDArray[float]): Radius of the particle [m].</li> <li>molar_mass (float or NDArray[float]): Molar mass of the species a [kg/mol].</li> <li>mass_concentration (float or NDArray[float]): Concentration of the species [kg/m^3].</li> <li>temperature (float): Temperature of the system [K].</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#returns_3","title":"Returns","text":"<ul> <li>float or NDArray[float]: The exponential factor adjusting vapor pressure due to curvature.</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#references_1","title":"References","text":"<p>Based on Neil Donahue's approach to the Kelvin equation: exp(kelvin_radius / particle_radius) - <code>See</code> more - https://en.wikipedia.org/wiki/Kelvin_equation</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_4","title":"Signature","text":"<pre><code>def kelvin_term(\n    self,\n    radius: Union[float, NDArray[np.float_]],\n    molar_mass: Union[float, NDArray[np.float_]],\n    mass_concentration: Union[float, NDArray[np.float_]],\n    temperature: float,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategymass","title":"SurfaceStrategyMass","text":"<p>Show source in surface_strategies.py:187</p> <p>Surface tension and density, based on mass fraction weighted values.</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#arguments_4","title":"Arguments","text":"<ul> <li>surface_tension (Union[float, NDArray[np.float_]]): Surface tension of the species [N/m]. If a single value is provided, it will be used for all species.</li> <li>density (Union[float, NDArray[np.float_]]): Density of the species [kg/m^3]. If a single value is provided, it will be used for all species.</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#references_2","title":"References","text":"<ul> <li>Mass Fractions https://en.wikipedia.org/wiki/Mass_fraction_(chemistry)</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_5","title":"Signature","text":"<pre><code>class SurfaceStrategyMass(SurfaceStrategy):\n    def __init__(\n        self,\n        surface_tension: Union[float, NDArray[np.float_]] = 0.072,\n        density: Union[float, NDArray[np.float_]] = 1000,\n    ): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#see-also","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategymasseffective_density","title":"SurfaceStrategyMass().effective_density","text":"<p>Show source in surface_strategies.py:223</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_6","title":"Signature","text":"<pre><code>def effective_density(\n    self, mass_concentration: Union[float, NDArray[np.float_]]\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategymasseffective_surface_tension","title":"SurfaceStrategyMass().effective_surface_tension","text":"<p>Show source in surface_strategies.py:211</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_7","title":"Signature","text":"<pre><code>def effective_surface_tension(\n    self, mass_concentration: Union[float, NDArray[np.float_]]\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategymolar","title":"SurfaceStrategyMolar","text":"<p>Show source in surface_strategies.py:134</p> <p>Surface tension and density, based on mole fraction weighted values.</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#arguments_5","title":"Arguments","text":"<ul> <li>surface_tension (Union[float, NDArray[np.float_]]): Surface tension of the species [N/m]. If a single value is provided, it will be used for all species.</li> <li>density (Union[float, NDArray[np.float_]]): Density of the species [kg/m^3]. If a single value is provided, it will be used for all species.</li> <li>molar_mass (Union[float, NDArray[np.float_]]): Molar mass of the species [kg/mol]. If a single value is provided, it will be used for all species.</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#references_3","title":"References","text":"<ul> <li>Mole Fractions https://en.wikipedia.org/wiki/Mole_fraction</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_8","title":"Signature","text":"<pre><code>class SurfaceStrategyMolar(SurfaceStrategy):\n    def __init__(\n        self,\n        surface_tension: Union[float, NDArray[np.float_]] = 0.072,\n        density: Union[float, NDArray[np.float_]] = 1000,\n        molar_mass: Union[float, NDArray[np.float_]] = 0.01815,\n    ): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#see-also_1","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategymolareffective_density","title":"SurfaceStrategyMolar().effective_density","text":"<p>Show source in surface_strategies.py:173</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_9","title":"Signature","text":"<pre><code>def effective_density(\n    self, mass_concentration: Union[float, NDArray[np.float_]]\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategymolareffective_surface_tension","title":"SurfaceStrategyMolar().effective_surface_tension","text":"<p>Show source in surface_strategies.py:162</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_10","title":"Signature","text":"<pre><code>def effective_surface_tension(\n    self, mass_concentration: Union[float, NDArray[np.float_]]\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategyvolume","title":"SurfaceStrategyVolume","text":"<p>Show source in surface_strategies.py:237</p> <p>Surface tension and density, based on volume fraction weighted values.</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#arguments_6","title":"Arguments","text":"<ul> <li>surface_tension (Union[float, NDArray[np.float_]]): Surface tension of the species [N/m]. If a single value is provided, it will be used for all species.</li> <li>density (Union[float, NDArray[np.float_]]): Density of the species [kg/m^3]. If a single value is provided, it will be used for all species.</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#references_4","title":"References","text":"<ul> <li>Volume Fractions https://en.wikipedia.org/wiki/Volume_fraction</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_11","title":"Signature","text":"<pre><code>class SurfaceStrategyVolume(SurfaceStrategy):\n    def __init__(\n        self,\n        surface_tension: Union[float, NDArray[np.float_]] = 0.072,\n        density: Union[float, NDArray[np.float_]] = 1000,\n    ): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#see-also_2","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategyvolumeeffective_density","title":"SurfaceStrategyVolume().effective_density","text":"<p>Show source in surface_strategies.py:273</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_12","title":"Signature","text":"<pre><code>def effective_density(\n    self, mass_concentration: Union[float, NDArray[np.float_]]\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#surfacestrategyvolumeeffective_surface_tension","title":"SurfaceStrategyVolume().effective_surface_tension","text":"<p>Show source in surface_strategies.py:261</p>"},{"location":"Source-Code/particula/next/particles/surface_strategies/#signature_13","title":"Signature","text":"<pre><code>def effective_surface_tension(\n    self, mass_concentration: Union[float, NDArray[np.float_]]\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/","title":"Properties","text":"<p>Particula Index / Particula / Next / Particles / Properties</p> <p>Auto-generated documentation for particula.next.particles.properties module.</p>"},{"location":"Source-Code/particula/next/particles/properties/#modules","title":"Modules","text":"<ul> <li>Aerodynamic Mobility Module</li> <li>Coulomb Enhancement</li> <li>Diffusive Knudsen Module</li> <li>Friction Factor Module</li> <li>Kelvin Effect Module</li> <li>Knudsen Number Module</li> <li>Mean Thermal Speed Module</li> <li>Partial Pressure Module</li> <li>Slip Correction Module</li> <li>Vapor Correction Module</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/aerodynamic_mobility_module/","title":"Aerodynamic Mobility Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Aerodynamic Mobility Module</p> <p>Auto-generated documentation for particula.next.particles.properties.aerodynamic_mobility_module module.</p>"},{"location":"Source-Code/particula/next/particles/properties/aerodynamic_mobility_module/#particle_aerodynamic_mobility","title":"particle_aerodynamic_mobility","text":"<p>Show source in aerodynamic_mobility_module.py:8</p> <p>Calculate the aerodynamic mobility of a particle, defined as the ratio of the slip correction factor to the product of the dynamic viscosity of the fluid, the particle radius, and a slip correction constant derived.</p> <p>This mobility quantifies the ease with which a particle can move through a fluid.</p>"},{"location":"Source-Code/particula/next/particles/properties/aerodynamic_mobility_module/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> radius - The radius of the particle (m).</li> <li><code>-</code> slip_correction_factor - The slip correction factor for the particle in the fluid (dimensionless).</li> <li><code>-</code> dynamic_viscosity - The dynamic viscosity of the fluid (Pa.s).</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/aerodynamic_mobility_module/#returns","title":"Returns","text":"<ul> <li>The particle aerodynamic mobility (m^2/s).</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/aerodynamic_mobility_module/#signature","title":"Signature","text":"<pre><code>def particle_aerodynamic_mobility(\n    radius: Union[float, NDArray[np.float_]],\n    slip_correction_factor: Union[float, NDArray[np.float_]],\n    dynamic_viscosity: float,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/","title":"Coulomb Enhancement","text":"<p>Particula Index / Particula / Next / Particles / Properties / Coulomb Enhancement</p> <p>Auto-generated documentation for particula.next.particles.properties.coulomb_enhancement module.</p>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#continuum","title":"continuum","text":"<p>Show source in coulomb_enhancement.py:91</p> <p>Calculates the Coulombic enhancement continuum limit. For all particle- particle interactions.</p>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> coulomb_potential - The Coulomb potential ratio [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#returns","title":"Returns","text":"<ul> <li>The Coulomb enhancement for the continuum limit [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#references","title":"References","text":"<p>Equation 6b in: Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</p>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#signature","title":"Signature","text":"<pre><code>def continuum(\n    coulomb_potential: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#kinetic","title":"kinetic","text":"<p>Show source in coulomb_enhancement.py:62</p> <p>Calculates the Coulombic enhancement kinetic limit. For all particle- particle interactions.</p>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> coulomb_potential - The Coulomb potential ratio [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#returns_1","title":"Returns","text":"<ul> <li>The Coulomb enhancement for the kinetic limit [dimensionless].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#references_1","title":"References","text":"<p>Equation 6d and 6e in: Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</p>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#signature_1","title":"Signature","text":"<pre><code>def kinetic(\n    coulomb_potential: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#ratio","title":"ratio","text":"<p>Show source in coulomb_enhancement.py:19</p> <p>Calculates the Coulomb potential ratio, phi_E. For all particle- particle interactions.</p>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> radius - The radius of the particle [m].</li> <li><code>-</code> charge - The number of charges on the particle [dimensionless].</li> <li><code>-</code> temperature - The temperature of the system [K].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#returns_2","title":"Returns","text":"<p>The Coulomb potential ratio [dimensionless].</p>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#references_2","title":"References","text":"<p>Equation 7 in: Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</p>"},{"location":"Source-Code/particula/next/particles/properties/coulomb_enhancement/#signature_2","title":"Signature","text":"<pre><code>def ratio(\n    radius: Union[float, NDArray[np.float_]],\n    charge: Union[int, NDArray[np.float_]] = 0,\n    temperature: float = 298.15,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/diffusive_knudsen_module/","title":"Diffusive Knudsen Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Diffusive Knudsen Module</p> <p>Auto-generated documentation for particula.next.particles.properties.diffusive_knudsen_module module.</p>"},{"location":"Source-Code/particula/next/particles/properties/diffusive_knudsen_module/#diffusive_knudsen_number","title":"diffusive_knudsen_number","text":"<p>Show source in diffusive_knudsen_module.py:12</p> <p>Diffusive Knudsen number. The diffusive Knudsen number is different from Knudsen number. Ratio of: mean persistence of one particle to the effective length scale of particle--particle Coulombic interaction</p>"},{"location":"Source-Code/particula/next/particles/properties/diffusive_knudsen_module/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> radius - The radius of the particle [m].</li> <li><code>-</code> mass_particle - The mass of the particle [kg].</li> <li><code>-</code> friction_factor - The friction factor of the particle [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio, zero if  no charges [dimensionless].</li> <li><code>-</code> temperature - The temperature of the system [K].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/diffusive_knudsen_module/#returns","title":"Returns","text":"<p>The diffusive Knudsen number [dimensionless], as a square matrix, of all particle-particle interactions.</p>"},{"location":"Source-Code/particula/next/particles/properties/diffusive_knudsen_module/#references","title":"References","text":"<ul> <li>Equation 5 in, with charges: Chahl, H. S., &amp; Gopalakrishnan, R. (2019). High potential, near free molecular regime Coulombic collisions in aerosols and dusty plasmas. Aerosol Science and Technology, 53(8), 933-957. https://doi.org/10.1080/02786826.2019.1614522</li> <li>Equation 3b in, no charges: Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/diffusive_knudsen_module/#signature","title":"Signature","text":"<pre><code>def diffusive_knudsen_number(\n    radius: Union[float, NDArray[np.float_]],\n    mass_particle: Union[float, NDArray[np.float_]],\n    friction_factor: Union[float, NDArray[np.float_]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float_]] = 0.0,\n    temperature: float = 298.15,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/friction_factor_module/","title":"Friction Factor Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Friction Factor Module</p> <p>Auto-generated documentation for particula.next.particles.properties.friction_factor_module module.</p>"},{"location":"Source-Code/particula/next/particles/properties/friction_factor_module/#friction_factor","title":"friction_factor","text":"<p>Show source in friction_factor_module.py:15</p> <p>Returns a particle's friction factor. Property of the particle's size and surrounding medium. Multiplying the friction factor by the fluid velocity yields the drag force on the particle.</p>"},{"location":"Source-Code/particula/next/particles/properties/friction_factor_module/#arguments","title":"Arguments","text":"<ul> <li>radius : The radius of the particle [m].</li> <li>dynamic_viscosity : The dynamic viscosity of the fluid [Pa s].</li> <li>slip_correction : The slip correction factor [unitless].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/friction_factor_module/#returns","title":"Returns","text":"<p>The friction factor of the particle [N s/m].</p>"},{"location":"Source-Code/particula/next/particles/properties/friction_factor_module/#references","title":"References","text":"<p>It is best thought of as an inverse of mobility or the ratio between thermal energy and diffusion coefficient. The modified Stoke's diffusion coefficient is defined as kT / (6 * np.pi * dyn_vis_air * radius / slip_corr) and thus the friction factor can be defined as (6 * np.pi * dyn_vis_air * radius / slip_corr).</p> <p>In the continuum limit (Kn -&gt; 0; Cc -&gt; 1): 6 * np.pi * dyn_vis_air * radius</p> <p>In the kinetic limit (Kn -&gt; inf): 8.39 * (dyn_vis_air/mfp_air) * const * radius**2</p> <p>Zhang, C., Thajudeen, T., Larriba, C., Schwartzentruber, T. E., &amp; Hogan, C. J. (2012). Determination of the Scalar Friction Factor for Nonspherical Particles and Aggregates Across the Entire Knudsen Number Range by Direct Simulation Monte Carlo (DSMC). Aerosol Science and Technology, 46(10), 1065-1078. https://doi.org/10.1080/02786826.2012.690543</p>"},{"location":"Source-Code/particula/next/particles/properties/friction_factor_module/#signature","title":"Signature","text":"<pre><code>def friction_factor(\n    radius: Union[float, NDArray[np.float_]],\n    dynamic_viscosity: float,\n    slip_correction: Union[float, NDArray[np.float_]],\n): ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/kelvin_effect_module/","title":"Kelvin Effect Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Kelvin Effect Module</p> <p>Auto-generated documentation for particula.next.particles.properties.kelvin_effect_module module.</p>"},{"location":"Source-Code/particula/next/particles/properties/kelvin_effect_module/#kelvin_radius","title":"kelvin_radius","text":"<p>Show source in kelvin_effect_module.py:10</p> <p>Calculate the Kelvin radius which determines the curvature effect on vapor pressure.</p>"},{"location":"Source-Code/particula/next/particles/properties/kelvin_effect_module/#arguments","title":"Arguments","text":"<ul> <li>surface_tension (float or NDArray[float]): Surface tension of the mixture [N/m].</li> <li>molar_mass (float or NDArray[float]): Molar mass of the species [kg/mol].</li> <li>mass_concentration (float or NDArray[float]): Concentration of the species [kg/m^3].</li> <li>temperature (float): Temperature of the system [K].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/kelvin_effect_module/#returns","title":"Returns","text":"<ul> <li>float or NDArray[float]: Kelvin radius [m].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/kelvin_effect_module/#references","title":"References","text":"<ul> <li>Based on Neil Donahue's approach to the Kelvin equation: r = 2 * surface_tension * molar_mass / (R * T * density)</li> <li><code>See</code> more - https://en.wikipedia.org/wiki/Kelvin_equation</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/kelvin_effect_module/#signature","title":"Signature","text":"<pre><code>def kelvin_radius(\n    effective_surface_tension: Union[float, NDArray[np.float_]],\n    effective_density: Union[float, NDArray[np.float_]],\n    molar_mass: Union[float, NDArray[np.float_]],\n    temperature: float,\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/kelvin_effect_module/#kelvin_term","title":"kelvin_term","text":"<p>Show source in kelvin_effect_module.py:46</p> <p>Calculate the Kelvin term, which quantifies the effect of particle curvature on vapor pressure.</p>"},{"location":"Source-Code/particula/next/particles/properties/kelvin_effect_module/#arguments_1","title":"Arguments","text":"<ul> <li>radius (float or NDArray[float]): Radius of the particle [m].</li> <li>kelvin_radius (float or NDArray[float]): Kelvin radius [m].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/kelvin_effect_module/#returns_1","title":"Returns","text":"<ul> <li>float or NDArray[float]: The exponential factor adjusting vapor pressure due to curvature.</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/kelvin_effect_module/#references_1","title":"References","text":"<p>Based on Neil Donahue's collection of terms in the Kelvin equation: exp(kelvin_radius / particle_radius) - <code>See</code> more - https://en.wikipedia.org/wiki/Kelvin_equation</p>"},{"location":"Source-Code/particula/next/particles/properties/kelvin_effect_module/#signature_1","title":"Signature","text":"<pre><code>def kelvin_term(\n    radius: Union[float, NDArray[np.float_]],\n    kelvin_radius_value: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/knudsen_number_module/","title":"Knudsen Number Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Knudsen Number Module</p> <p>Auto-generated documentation for particula.next.particles.properties.knudsen_number_module module.</p>"},{"location":"Source-Code/particula/next/particles/properties/knudsen_number_module/#calculate_knudsen_number","title":"calculate_knudsen_number","text":"<p>Show source in knudsen_number_module.py:9</p> <p>Calculate the Knudsen number using the mean free path of the gas and the radius of the particle. The Knudsen number is a dimensionless number that indicates the regime of gas flow relative to the size of particles.</p>"},{"location":"Source-Code/particula/next/particles/properties/knudsen_number_module/#arguments","title":"Arguments","text":"<ul> <li>mean_free_path (Union[float, NDArray[np.float_]]): The mean free path of the gas molecules [meters (m)].</li> <li>particle_radius (Union[float, NDArray[np.float_]]): The radius of the particle [meters (m)].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/knudsen_number_module/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The Knudsen number, which is the ratio of the mean free path to the particle radius.</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/knudsen_number_module/#references","title":"References","text":"<ul> <li>For more information at https://en.wikipedia.org/wiki/Knudsen_number</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/knudsen_number_module/#signature","title":"Signature","text":"<pre><code>def calculate_knudsen_number(\n    mean_free_path: Union[float, NDArray[np.float_]],\n    particle_radius: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/mean_thermal_speed_module/","title":"Mean Thermal Speed Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Mean Thermal Speed Module</p> <p>Auto-generated documentation for particula.next.particles.properties.mean_thermal_speed_module module.</p>"},{"location":"Source-Code/particula/next/particles/properties/mean_thermal_speed_module/#mean_thermal_speed","title":"mean_thermal_speed","text":"<p>Show source in mean_thermal_speed_module.py:11</p> <p>Returns the particles mean thermal speed. Due to the the impact of air molecules on the particles, the particles will have a mean thermal speed.</p>"},{"location":"Source-Code/particula/next/particles/properties/mean_thermal_speed_module/#args","title":"Args","text":"<p>mass : The per particle mass of the particles [kg]. temperature : The temperature of the air [K].</p>"},{"location":"Source-Code/particula/next/particles/properties/mean_thermal_speed_module/#returns","title":"Returns","text":"<p>The mean thermal speed of the particles [m/s].</p>"},{"location":"Source-Code/particula/next/particles/properties/mean_thermal_speed_module/#references","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 9.5.3 Mean Free Path of an Aerosol Particle Equation 9.87.</p>"},{"location":"Source-Code/particula/next/particles/properties/mean_thermal_speed_module/#signature","title":"Signature","text":"<pre><code>def mean_thermal_speed(\n    mass: Union[float, NDArray[np.float_]], temperature: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/partial_pressure_module/","title":"Partial Pressure Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Partial Pressure Module</p> <p>Auto-generated documentation for particula.next.particles.properties.partial_pressure_module module.</p>"},{"location":"Source-Code/particula/next/particles/properties/partial_pressure_module/#partial_pressure_delta","title":"partial_pressure_delta","text":"<p>Show source in partial_pressure_module.py:9</p> <p>Calculate the difference in partial pressure of a species between the gas phase and the particle phase, which is used in the calculation of the rate of change of mass of an aerosol particle.</p>"},{"location":"Source-Code/particula/next/particles/properties/partial_pressure_module/#arguments","title":"Arguments","text":"<ul> <li>partial_pressure_gas (Union[float, NDArray[np.float_]]): The partial pressure of the species in the gas phase.</li> <li>partial_pressure_particle (Union[float, NDArray[np.float_]]): The partial pressure of the species in the particle phase.</li> <li>kelvin_term (Union[float, NDArray[np.float_]]): Kelvin effect to account for the curvature of the particle.</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/partial_pressure_module/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The difference in partial pressure between the gas phase and the particle phase.</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/partial_pressure_module/#signature","title":"Signature","text":"<pre><code>def partial_pressure_delta(\n    partial_pressure_gas: Union[float, NDArray[np.float_]],\n    partial_pressure_particle: Union[float, NDArray[np.float_]],\n    kelvin_term: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/slip_correction_module/","title":"Slip Correction Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Slip Correction Module</p> <p>Auto-generated documentation for particula.next.particles.properties.slip_correction_module module.</p>"},{"location":"Source-Code/particula/next/particles/properties/slip_correction_module/#cunningham_slip_correction","title":"cunningham_slip_correction","text":"<p>Show source in slip_correction_module.py:9</p> <p>Calculate the Cunningham slip correction factor. Accounts for non-continuum effects on small particles.</p>"},{"location":"Source-Code/particula/next/particles/properties/slip_correction_module/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> knudsen_number - Knudsen number [unitless].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/slip_correction_module/#returns","title":"Returns","text":"<ul> <li>Slip correction factor [unitless].</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/slip_correction_module/#reference","title":"Reference:","text":"<ul> <li>Dimensionless quantity accounting for non-continuum effects on small particles. It is a deviation from Stokes' Law. Stokes assumes a no-slip condition that is not correct at high Knudsen numbers. The slip correction factor is used to calculate the friction factor. Thus, the slip correction factor is about unity (1) for larger particles (Kn -&gt; 0). Its behavior on the other end of the spectrum (smaller particles; Kn -&gt; inf) is more nuanced, though it tends to scale linearly on a log-log scale, log Cc vs log Kn.</li> <li>https://en.wikipedia.org/wiki/Cunningham_correction_factor</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/slip_correction_module/#signature","title":"Signature","text":"<pre><code>def cunningham_slip_correction(\n    knudsen_number: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/next/particles/properties/vapor_correction_module/","title":"Vapor Correction Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Vapor Correction Module</p> <p>Auto-generated documentation for particula.next.particles.properties.vapor_correction_module module.</p>"},{"location":"Source-Code/particula/next/particles/properties/vapor_correction_module/#vapor_transition_correction","title":"vapor_transition_correction","text":"<p>Show source in vapor_correction_module.py:11</p> <p>Calculate the transition correction factor, f(Kn, alpha), for a given Knudsen number and mass accommodation coefficient. This function is used to account for the intermediate regime between continuum and free molecular flow. This is the Suchs and Futugin transition function.</p>"},{"location":"Source-Code/particula/next/particles/properties/vapor_correction_module/#arguments","title":"Arguments","text":"<ul> <li>knudsen_number (Union[float, NDArray[np.float_]]): The Knudsen number, which quantifies the relative importance of the mean free path of gas molecules to the size of the particle.</li> <li>mass_accommodation (Union[float, NDArray[np.float_]]): The mass accommodation coefficient, representing the probability of a gas molecule sticking to the particle upon collision.</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/vapor_correction_module/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float_]]: The transition correction value calculated based on the specified inputs.</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/vapor_correction_module/#references","title":"References","text":"<ul> <li>Seinfeld and Pandis, \"Atmospheric Chemistry and Physics\", Chapter 12, equation 12.43.</li> <li><code>Note</code> - There are various formulations for this correction, so further extensions of this function might be necessary depending on specific requirements.</li> <li>Original reference: FUCHS, N. A., &amp; SUTUGIN, A. G. (1971). HIGH-DISPERSED AEROSOLS. In Topics in Current Aerosol Research (p. 1). Elsevier. https://doi.org/10.1016/B978-0-08-016674-2.50006-6</li> </ul>"},{"location":"Source-Code/particula/next/particles/properties/vapor_correction_module/#signature","title":"Signature","text":"<pre><code>def vapor_transition_correction(\n    knudsen_number: Union[float, NDArray[np.float_]],\n    mass_accommodation: Union[float, NDArray[np.float_]],\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/","title":"Util","text":"<p>Particula Index / Particula / Util</p> <p>Auto-generated documentation for particula.util module.</p>"},{"location":"Source-Code/particula/util/#modules","title":"Modules","text":"<ul> <li>Aerodynamic Mobility</li> <li>Approx Coagulation</li> <li>CoagulationRate</li> <li>Colors</li> <li>Condensation Force</li> <li>Convert</li> <li>Converting</li> <li>CoulombEnhancement</li> <li>Debye Function</li> <li>Diffusion Coefficient</li> <li>DiffusiveKnudsen</li> <li>Dilution Loss</li> <li>DimensionlessCoagulation</li> <li>Distribution Discretization</li> <li>Dynamic Viscosity</li> <li>Friction Factor</li> <li>Fuchs Sutugin</li> <li>Input Handling</li> <li>Kelvin Correction</li> <li>Knudsen Number</li> <li>Lf2013 Coagulation</li> <li>Machine Limit</li> <li>Mean Free Path</li> <li>Molecular Enhancement</li> <li>Particle Mass</li> <li>Particle Surface</li> <li>Radius Cutoff</li> <li>Reduced Quantity</li> <li>Rms Speed</li> <li>Settling Velocity</li> <li>SimpleSolver</li> <li>Size Distribution Convert</li> <li>Slip Correction</li> <li>Species Properties</li> <li>Stats</li> <li>Surface Tension</li> <li>Time Manage</li> <li>Vapor Flux</li> <li>Wall Loss</li> </ul>"},{"location":"Source-Code/particula/util/aerodynamic_mobility/","title":"Aerodynamic Mobility","text":"<p>Particula Index / Particula / Util / Aerodynamic Mobility</p> <p>Auto-generated documentation for particula.util.aerodynamic_mobility module.</p>"},{"location":"Source-Code/particula/util/aerodynamic_mobility/#pam","title":"pam","text":"<p>Show source in aerodynamic_mobility.py:10</p> <p>particle aerodynamic mobility</p>"},{"location":"Source-Code/particula/util/aerodynamic_mobility/#signature","title":"Signature","text":"<pre><code>def pam(radius=None, scf_val=None, vis_val=None, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/approx_coagulation/","title":"Approx Coagulation","text":"<p>Particula Index / Particula / Util / Approx Coagulation</p> <p>Auto-generated documentation for particula.util.approx_coagulation module.</p>"},{"location":"Source-Code/particula/util/approx_coagulation/#approx_coag_less","title":"approx_coag_less","text":"<p>Show source in approx_coagulation.py:10</p> <p>dy2007 approx. Dimensionless particle--particle coagulation kernel.</p> <p>gh2012: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.85.026410</p> <p>gk2008: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.78.046402</p> <p>dy2007: https://aip.scitation.org/doi/10.1063/1.2713719</p> <p>cg2019: https://www.tandfonline.com/doi/suppl/10.1080/02786826.2019.1614522</p> <p>todolater: - quick fixes for corner cases - examine better solutions?</p>"},{"location":"Source-Code/particula/util/approx_coagulation/#signature","title":"Signature","text":"<pre><code>def approx_coag_less(diff_knu=None, cpr=None, approx=\"hardsphere\"): ...\n</code></pre>"},{"location":"Source-Code/particula/util/coagulation_rate/","title":"CoagulationRate","text":"<p>Particula Index / Particula / Util / CoagulationRate</p> <p>Auto-generated documentation for particula.util.coagulation_rate module.</p>"},{"location":"Source-Code/particula/util/coagulation_rate/#coagulationrate_1","title":"CoagulationRate","text":"<p>Show source in coagulation_rate.py:8</p> <p>A class to calculate the coagulation rate.</p>"},{"location":"Source-Code/particula/util/coagulation_rate/#arguments","title":"Arguments","text":"<ul> <li><code>distribution</code> float - The distribution of particles.</li> <li><code>radius</code> float - The radius of the particles.</li> <li><code>kernel</code> float - The kernel of the particles.</li> </ul>"},{"location":"Source-Code/particula/util/coagulation_rate/#signature","title":"Signature","text":"<pre><code>class CoagulationRate:\n    def __init__(self, distribution, radius, kernel, lazy=True): ...\n</code></pre>"},{"location":"Source-Code/particula/util/coagulation_rate/#coagulationratecoag_gain","title":"CoagulationRate().coag_gain","text":"<p>Show source in coagulation_rate.py:76</p> <p>Returns the coagulation gain rate</p> <p>Equation:</p> <p>gain_rate(other_radius) = (     other_radius**2 *     integral( # from some_radius=0 to other_radius/2**(\u2153)         kernel(some_radius, (other_radius**3-some_radius**3)(\u2153)         dist(some_radius) *         dist((other_radius**3 - some_radius**3)(\u2153)) /         (other_radius**3 - some_radius**3)(\u2154),         some_radius     ) )</p> <p>Units:     m**-4/s</p> <p>This equation necessitates the use of a for-loop due to the convoluted use of different radii at different stages. This is the costliest step of all coagulation calculations. Note, to estimate the kernel and distribution at (other_radius**3 - some_radius**3)*(\u2153) we use interporlation techniques.</p> <p>Using <code>RectBivariateSpline</code> accelerates this significantly.</p>"},{"location":"Source-Code/particula/util/coagulation_rate/#signature_1","title":"Signature","text":"<pre><code>def coag_gain(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/coagulation_rate/#coagulationratecoag_loss","title":"CoagulationRate().coag_loss","text":"<p>Show source in coagulation_rate.py:54</p> <p>Returns the coagulation loss rate</p> <p>Equation:</p> <p>loss_rate(other_radius) = (     dist(other_radius) *     integral( # over all space         kernel(radius, other_radius) *         dist(radius),         radius     )</p> <p>Units:</p> <p>m**-4/s</p>"},{"location":"Source-Code/particula/util/coagulation_rate/#signature_2","title":"Signature","text":"<pre><code>def coag_loss(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/coagulation_rate/#coagulationratecoag_prep","title":"CoagulationRate().coag_prep","text":"<p>Show source in coagulation_rate.py:44</p> <p>Repackage the parameters</p>"},{"location":"Source-Code/particula/util/coagulation_rate/#signature_3","title":"Signature","text":"<pre><code>def coag_prep(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/colors/","title":"Colors","text":"<p>Particula Index / Particula / Util / Colors</p> <p>Auto-generated documentation for particula.util.colors module.</p>"},{"location":"Source-Code/particula/util/condensation_force/","title":"Condensation Force","text":"<p>Particula Index / Particula / Util / Condensation Force</p> <p>Auto-generated documentation for particula.util.condensation_force module.</p>"},{"location":"Source-Code/particula/util/condensation_force/#condensation_force","title":"condensation_force","text":"<p>Show source in condensation_force.py:9</p> <p>calculate the condensation driving force</p> <p>Equation (9) in https://www.nature.com/articles/nature18271</p>"},{"location":"Source-Code/particula/util/condensation_force/#signature","title":"Signature","text":"<pre><code>def condensation_force(\n    vapor_concentraton, sat_vapor_concentration, particle_activity=None, **kwargs\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/condensation_force/#particle_activity_fun","title":"particle_activity_fun","text":"<p>Show source in condensation_force.py:29</p> <p>calculate the particle activity</p> <p>Equation (9--10) in https://www.nature.com/articles/nature18271</p>"},{"location":"Source-Code/particula/util/condensation_force/#signature_1","title":"Signature","text":"<pre><code>def particle_activity_fun(\n    mass_fraction, activity_coefficient, kelvin_term=None, **kwargs\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/","title":"Convert","text":"<p>Particula Index / Particula / Util / Convert</p> <p>Auto-generated documentation for particula.util.convert module.</p>"},{"location":"Source-Code/particula/util/convert/#coerce_type","title":"coerce_type","text":"<p>Show source in convert.py:9</p> <p>Coerces data to dtype if it is not already of that type.</p>"},{"location":"Source-Code/particula/util/convert/#signature","title":"Signature","text":"<pre><code>def coerce_type(data, dtype): ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#convert_sizer_dn","title":"convert_sizer_dn","text":"<p>Show source in convert.py:451</p> <p>Converts the sizer data from dn/dlogdp to d_num.</p> <p>The bin width is defined as the  difference between the upper and lower diameter limits of each bin. This function calculates the bin widths based on the input diameter array. Assumes a log10 scale for dp edges.</p>"},{"location":"Source-Code/particula/util/convert/#arguments","title":"Arguments","text":"<pre><code>- `diameter` *np.ndarray* - Array of particle diameters.\n- `dn_dlogdp` *np.ndarray* - Array of number concentration of particles per\nunit logarithmic diameter.\n- `inverse` *bool* - If True, converts from d_num to dn/dlogdp.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns","title":"Returns","text":"<pre><code>- `np.ndarray` - Array of number concentration of particles\nper unit diameter.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#references","title":"References","text":"<ul> <li> <p><code>Eq</code> - dN/dlogD_p = dN/( log(D_{p-upper}) - log(D_{p-lower}) ) https://tsi.com/getmedia/1621329b-f410-4dce-992b-e21e1584481a/ PR-001-RevA_Aerosol-Statistics-AppNote?ext=.pdf</p> </li> <li> <p><code>#</code> future - Address potential over-counting in last/first bin</p> </li> </ul>"},{"location":"Source-Code/particula/util/convert/#signature_1","title":"Signature","text":"<pre><code>def convert_sizer_dn(\n    diameter: np.ndarray, dn_dlogdp: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#data_shape_check","title":"data_shape_check","text":"<p>Show source in convert.py:570</p> <p>Check the shape of the input data and header list, and reshape the data if necessary. The data array can be 1D or 2D. If the data array is 2D, the time array must match the last dimensions of the data array. If the data array is 1D, the header list must be a single entry.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_1","title":"Arguments","text":"<pre><code>- `time` *np.ndarray* - 1D array of time values.\n- `data` *np.ndarray* - 1D or 2D array of data values.\n- `header` *list* - List of header values.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_1","title":"Returns","text":"<pre><code>- `np.ndarray` - Reshaped data array.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#raises","title":"Raises","text":"<pre><code>- `ValueError` - If the length of the header list does not match the first\ndimension of the data array.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_2","title":"Signature","text":"<pre><code>def data_shape_check(time: np.ndarray, data: np.ndarray, header: list) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#distribution_convert_pdf_pms","title":"distribution_convert_pdf_pms","text":"<p>Show source in convert.py:626</p> <p>Convert between a probability density function (PDF) and a probability mass spectrum (PMS) based on the specified direction.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_2","title":"Arguments","text":"<p>x_array     An array of radii corresponding to the bins of the distribution,     shape (m). distribution     The concentration values of the distribution (either PDF or PMS)     at the given radii. Supports broadcasting across x_array (n,m). to_PDF     Direction of conversion. If True, converts PMS to PDF. If False,     converts PDF to PMS.</p>"},{"location":"Source-Code/particula/util/convert/#returns_2","title":"Returns","text":"<p>converted_distribution     The converted distribution array (either PDF or PMS).</p>"},{"location":"Source-Code/particula/util/convert/#signature_3","title":"Signature","text":"<pre><code>def distribution_convert_pdf_pms(\n    x_array: np.ndarray, distribution: np.ndarray, to_pdf: bool = True\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#effective_refractive_index","title":"effective_refractive_index","text":"<p>Show source in convert.py:411</p> <p>Calculate the effective refractive index of a mixture of two solutes, given the refractive index of each solute and the volume of each solute. The mixing is based on volume-weighted molar refraction.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_3","title":"Arguments","text":"<pre><code>m_zero (float or complex): The refractive index of solute 0.\nm_one (float or complex): The refractive index of solute 1.\n- `volume_zero` *float* - The volume of solute 0.\n- `volume_one` *float* - The volume of solute 1.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_3","title":"Returns","text":"<pre><code>The effective refractive index of the mixture.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#reference","title":"Reference:","text":"<pre><code>Liu, Y., &amp;#38; Daum, P. H. (2008).\nRelationship of refractive index to mass density and self-consistency\nmixing rules for multicomponent mixtures like ambient aerosols.\nJournal of Aerosol Science, 39(11), 974-986.\nhttps://doi.org/10.1016/j.jaerosci.2008.06.006\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_4","title":"Signature","text":"<pre><code>def effective_refractive_index(\n    m_zero: Union[float, complex],\n    m_one: Union[float, complex],\n    volume_zero: float,\n    volume_one: float,\n) -&gt; Union[float, complex]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#get_values_in_dict","title":"get_values_in_dict","text":"<p>Show source in convert.py:528</p> <p>Returns a list of values for keys in a dictionary.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_4","title":"Arguments","text":"<p>key_list : List[str]     List of keys to check in the dictionary. dict_to_check : Dict[str, Any]     The dictionary to check for the given keys.</p>"},{"location":"Source-Code/particula/util/convert/#returns_4","title":"Returns","text":"<p>List[Any]     A list of values for keys in the dictionary.</p>"},{"location":"Source-Code/particula/util/convert/#raises_1","title":"Raises","text":"<p>KeyError:     If any of the keys in the <code>key_list</code> are not present in the dictionary.</p>"},{"location":"Source-Code/particula/util/convert/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; my_dict = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; get_values_in_dict(['a', 'c'], my_dict)\n[1, 3]\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_5","title":"Signature","text":"<pre><code>def get_values_in_dict(\n    key_list: List[str], dict_to_check: Dict[str, Any]\n) -&gt; List[Any]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#kappa_from_volume","title":"kappa_from_volume","text":"<p>Show source in convert.py:200</p> <p>Calculate the kappa parameter from the volume of solute and water, given the water activity.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_5","title":"Arguments","text":"<pre><code>- `volume_solute` - The volume of solute.\n- `volume_water` - The volume of water.\n- `water_activity` - The water activity.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_5","title":"Returns","text":"<pre><code>The kappa parameter as a float.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_6","title":"Signature","text":"<pre><code>def kappa_from_volume(\n    volume_solute: Union[float, np.ndarray],\n    volume_water: Union[float, np.ndarray],\n    water_activity: Union[float, np.ndarray],\n) -&gt; Union[float, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#kappa_volume_solute","title":"kappa_volume_solute","text":"<p>Show source in convert.py:142</p> <p>Calculate the volume of solute in a volume of total solution, given the kappa parameter and water activity.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_6","title":"Arguments","text":"<pre><code>- `volume_total` - The volume of the total solution.\n- `kappa` - The kappa parameter.\n- `water_activity` - The water activity.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_6","title":"Returns","text":"<pre><code>The volume of solute as a numpy array.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_7","title":"Signature","text":"<pre><code>def kappa_volume_solute(\n    volume_total: Union[float, np.ndarray],\n    kappa: Union[float, np.ndarray],\n    water_activity: Union[float, np.ndarray],\n) -&gt; Union[float, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#kappa_volume_water","title":"kappa_volume_water","text":"<p>Show source in convert.py:172</p> <p>Calculate the volume of water given volume of solute, kappa parameter, and water activity.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_7","title":"Arguments","text":"<pre><code>- `volume_solute` - The volume of solute.\n- `kappa` - The kappa parameter.\n- `water_activity` - The water activity.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_7","title":"Returns","text":"<pre><code>The volume of water as a float.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_8","title":"Signature","text":"<pre><code>def kappa_volume_water(\n    volume_solute: Union[float, NDArray[np.float64]],\n    kappa: Union[float, NDArray[np.float64]],\n    water_activity: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#length_to_volume","title":"length_to_volume","text":"<p>Show source in convert.py:120</p> <p>Convert radius or diameter to volume.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_8","title":"Arguments","text":"<pre><code>- `length` - The length to be converted.\n- `length_type` - The type of length ('radius' or 'diameter').\n    Default is 'radius'.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_8","title":"Returns","text":"<pre><code>The volume.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_9","title":"Signature","text":"<pre><code>def length_to_volume(\n    length: Union[float, np.ndarray], length_type: str = \"radius\"\n) -&gt; Union[float, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#list_to_dict","title":"list_to_dict","text":"<p>Show source in convert.py:505</p> <p>Converts a list of strings to a dictionary. The keys are the strings and the values are the index of the string in the list.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_9","title":"Arguments","text":"<pre><code>- `list_of_str` *list* - A non-empty list of strings.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_9","title":"Returns","text":"<pre><code>- `dict` - A dictionary where the keys are the strings and the values are\n    the index of the string in the list.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_10","title":"Signature","text":"<pre><code>def list_to_dict(list_of_str: list) -&gt; dict: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#mass_concentration_to_mole_fraction","title":"mass_concentration_to_mole_fraction","text":"<p>Show source in convert.py:282</p> <p>Convert mass concentrations to mole fractions for N components.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_10","title":"Arguments","text":"<ul> <li><code>-</code> mass_concentrations - A list or ndarray of mass concentrations (e.g., kg/m^3).</li> <li><code>-</code> molar_masses - A list or ndarray of molecular weights (e.g., g/mol).</li> </ul>"},{"location":"Source-Code/particula/util/convert/#returns_10","title":"Returns","text":"<ul> <li>An ndarray of mole fractions.</li> </ul>"},{"location":"Source-Code/particula/util/convert/#notes","title":"Notes","text":"<p>The mole fraction of a component is given by the ratio of its molar concentration to the total molar concentration of all components.</p>"},{"location":"Source-Code/particula/util/convert/#signature_11","title":"Signature","text":"<pre><code>def mass_concentration_to_mole_fraction(\n    mass_concentrations: NDArray[np.float_], molar_masses: NDArray[np.float_]\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#mass_concentration_to_volume_fraction","title":"mass_concentration_to_volume_fraction","text":"<p>Show source in convert.py:312</p> <p>Convert mass concentrations to volume fractions for N components.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_11","title":"Arguments","text":"<ul> <li><code>-</code> mass_concentrations - A list or ndarray of mass concentrations (e.g., kg/m^3).</li> <li><code>-</code> densities - A list or ndarray of densities of each component (e.g., kg/m^3).</li> </ul>"},{"location":"Source-Code/particula/util/convert/#returns_11","title":"Returns","text":"<ul> <li>An ndarray of volume fractions.</li> </ul>"},{"location":"Source-Code/particula/util/convert/#notes_1","title":"Notes","text":"<p>The volume fraction of a component is calculated by dividing the volume of that component (derived from mass concentration and density) by the total volume of all components.</p>"},{"location":"Source-Code/particula/util/convert/#signature_12","title":"Signature","text":"<pre><code>def mass_concentration_to_volume_fraction(\n    mass_concentrations: NDArray[np.float_], densities: NDArray[np.float_]\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#mass_fraction_to_volume_fraction","title":"mass_fraction_to_volume_fraction","text":"<p>Show source in convert.py:346</p> <p>Converts the mass fraction of a solute to the volume fraction in a binary mixture.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_12","title":"Arguments","text":"<pre><code>- `mass_fraction` *float* - The mass fraction of the solute in the mixture.\n- `density_solute` *float* - The density of the solute.\n- `density_solvent` *float* - The density of the solvent.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_12","title":"Returns","text":"<pre><code>- `Tuple[float,` *float]* - A tuple containing the volume fraction of the\n    solute and solvent in the mixture.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#examples_1","title":"Examples","text":"<pre><code>If `mass_fraction` is 0.5, `density_solute` is 1.5 g/cm^3, and\n`density_solvent` is 2 g/cm^3, this function returns (0.5714, 0.4285),\nindicating that the solute and solvent occupy 57% and 42% of the\nmixture's volume, respectively.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_13","title":"Signature","text":"<pre><code>def mass_fraction_to_volume_fraction(\n    mass_fraction: float, density_solute: float, density_solvent: float\n) -&gt; Tuple[float, float]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#mole_fraction_to_mass_fraction","title":"mole_fraction_to_mass_fraction","text":"<p>Show source in convert.py:228</p> <p>Convert mole fraction to mass fraction.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_13","title":"Arguments","text":"<pre><code>- `mole_fraction0` - The mole fraction of the first component.\n- `molecular_weight0` - The molecular weight of the first component.\n- `molecular_weight1` - The molecular weight of the second component.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_13","title":"Returns","text":"<pre><code>A tuple containing the mass fractions of the two components as floats.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_14","title":"Signature","text":"<pre><code>def mole_fraction_to_mass_fraction(\n    mole_fraction0: float, molecular_weight0: float, molecular_weight1: float\n) -&gt; Tuple[float, float]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#mole_fraction_to_mass_fraction_multi","title":"mole_fraction_to_mass_fraction_multi","text":"<p>Show source in convert.py:254</p> <p>Convert mole fractions to mass fractions for N components. Assumes that sum(mole_fractions) == 1.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_14","title":"Arguments","text":"<pre><code>- `mole_fractions` - A list of mole fractions.\n- `molecular_weights` - A list of molecular weights.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_14","title":"Returns","text":"<pre><code>A list of mass fractions.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_15","title":"Signature","text":"<pre><code>def mole_fraction_to_mass_fraction_multi(\n    mole_fractions: list[float], molecular_weights: list[float]\n) -&gt; list[float]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#radius_diameter","title":"radius_diameter","text":"<p>Show source in convert.py:77</p> <p>Convert a radius to a diameter, or vice versa.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_15","title":"Arguments","text":"<pre><code>- `value` - The value to be converted.\n- `to_diameter` - If True, convert from radius to diameter.\nIf False, convert from diameter to radius.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_15","title":"Returns","text":"<pre><code>The converted value.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_16","title":"Signature","text":"<pre><code>def radius_diameter(value: float, to_diameter: bool = True) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#round_arbitrary","title":"round_arbitrary","text":"<p>Show source in convert.py:21</p> <p>Rounds the input values to the nearest multiple of the base.</p> <p>For values exactly halfway between rounded decimal values, \"Bankers rounding applies\" rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_16","title":"Arguments","text":"<pre><code>- `values` - The values to be rounded.\n- `base` - The base to which the values should be rounded.\n- `mode` - The rounding mode: 'round', 'floor', 'ceil'\n- `nonzero_edge` - If true the zero values are replaced\nby the original values.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_16","title":"Returns","text":"<pre><code>- `rounded` - The rounded values.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_17","title":"Signature","text":"<pre><code>def round_arbitrary(\n    values: Union[float, list[float], np.ndarray],\n    base: Union[float, np.float64] = 1.0,\n    mode: str = \"round\",\n    nonzero_edge: bool = False,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#volume_to_length","title":"volume_to_length","text":"<p>Show source in convert.py:94</p> <p>Convert a volume to a radius or diameter.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_17","title":"Arguments","text":"<pre><code>- `volume` - The volume to be converted.\n- `length_type` - The type of length to convert to ('radius' or 'diameter')\nDefault is 'radius'.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_17","title":"Returns","text":"<pre><code>The converted length.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_18","title":"Signature","text":"<pre><code>def volume_to_length(\n    volume: Union[float, NDArray[np.float64]], length_type: str = \"radius\"\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#volume_water_from_volume_fraction","title":"volume_water_from_volume_fraction","text":"<p>Show source in convert.py:381</p> <p>Calculates the volume of water in a volume of solute, given the volume fraction of water in the mixture.</p>"},{"location":"Source-Code/particula/util/convert/#arguments_18","title":"Arguments","text":"<pre><code>- `volume_solute_dry` *float* - The volume of the solute, excluding water.\n- `volume_fraction_water` *float* - The volume fraction of water in the\n                    mixture, expressed as a decimal between 0 and 1.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#returns_18","title":"Returns","text":"<pre><code>- `float` - The volume of water in the mixture, in the same units as\n    `volume_solute_dry`.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#examples_2","title":"Examples","text":"<pre><code>If `volume_solute_dry` is 100 mL and `volume_fraction_water` is 0.8,\nthis function returns 400 mL, indicating that there are 400 mL of water\nin the total 100 mL + 400 mL mixture.\n</code></pre>"},{"location":"Source-Code/particula/util/convert/#signature_19","title":"Signature","text":"<pre><code>def volume_water_from_volume_fraction(\n    volume_solute_dry: float, volume_fraction_water: float\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/util/coulomb_enhancement/","title":"CoulombEnhancement","text":"<p>Particula Index / Particula / Util / CoulombEnhancement</p> <p>Auto-generated documentation for particula.util.coulomb_enhancement module.</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#coulombenhancement_1","title":"CoulombEnhancement","text":"<p>Show source in coulomb_enhancement.py:17</p> <p>Calculate coulomb-related enhancements</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#attributes","title":"Attributes","text":"<p>radius          (float) [m] other_radius    (float) [m]             (default: radius) charge          (float) [dimensionless] (default: 0) other_charge    (float) [dimensionless] (default: 0) temperature     (float) [K]             (default: 298)</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#signature","title":"Signature","text":"<pre><code>class CoulombEnhancement:\n    def __init__(\n        self,\n        radius=None,\n        other_radius=None,\n        charge=0,\n        other_charge=0,\n        temperature=298,\n        elementary_charge_value=ELEMENTARY_CHARGE_VALUE,\n        electric_permittivity=ELECTRIC_PERMITTIVITY,\n        boltzmann_constant=BOLTZMANN_CONSTANT,\n        **kwargs\n    ): ...\n</code></pre>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#see-also","title":"See also","text":"<ul> <li>BOLTZMANN_CONSTANT</li> <li>ELECTRIC_PERMITTIVITY</li> <li>ELEMENTARY_CHARGE_VALUE</li> </ul>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#coulombenhancementcoulomb_enhancement_continuum_limit","title":"CoulombEnhancement().coulomb_enhancement_continuum_limit","text":"<p>Show source in coulomb_enhancement.py:124</p> <p>Coulombic coagulation enhancement continuum limit.</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#arguments","title":"Arguments","text":"<p>radius          (float) [m] other_radius    (float) [m]             (default: radius) charge          (float) [dimensionless] (default: 0) other_charge    (float) [dimensionless] (default: 0) temperature     (float) [K]             (default: 298)</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#returns","title":"Returns","text":"<p>(float) [dimensionless]</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#signature_1","title":"Signature","text":"<pre><code>def coulomb_enhancement_continuum_limit(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#coulombenhancementcoulomb_enhancement_kinetic_limit","title":"CoulombEnhancement().coulomb_enhancement_kinetic_limit","text":"<p>Show source in coulomb_enhancement.py:103</p> <p>Coulombic coagulation enhancement kinetic limit.</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#arguments_1","title":"Arguments","text":"<p>radius          (float) [m] other_radius    (float) [m]             (default: radius) charge          (float) [dimensionless] (default: 0) other_charge    (float) [dimensionless] (default: 0) temperature     (float) [K]             (default: 298)</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#returns_1","title":"Returns","text":"<p>(float) [dimensionless]</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#signature_2","title":"Signature","text":"<pre><code>def coulomb_enhancement_kinetic_limit(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#coulombenhancementcoulomb_potential_ratio","title":"CoulombEnhancement().coulomb_potential_ratio","text":"<p>Show source in coulomb_enhancement.py:77</p> <p>Calculates the Coulomb potential ratio.</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#arguments_2","title":"Arguments","text":"<p>radius          (float) [m] other_radius    (float) [m]             (default: radius) charge          (int)   [dimensionless] (default: 0) other_charge    (int)   [dimensionless] (default: 0) temperature     (float) [K]             (default: 298)</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#returns_2","title":"Returns","text":"<p>(float) [dimensionless]</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#signature_3","title":"Signature","text":"<pre><code>def coulomb_potential_ratio(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#cecl","title":"cecl","text":"<p>Show source in coulomb_enhancement.py:159</p> <p>Calculate coulombic enhancement continuum limit</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#signature_4","title":"Signature","text":"<pre><code>def cecl(**kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#cekl","title":"cekl","text":"<p>Show source in coulomb_enhancement.py:153</p> <p>Calculate coulombic enhancement kinetic limit</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#signature_5","title":"Signature","text":"<pre><code>def cekl(**kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#coulomb_enhancement_all","title":"coulomb_enhancement_all","text":"<p>Show source in coulomb_enhancement.py:165</p> <p>Return all the values above in one call</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#signature_6","title":"Signature","text":"<pre><code>def coulomb_enhancement_all(**kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#cpr","title":"cpr","text":"<p>Show source in coulomb_enhancement.py:147</p> <p>Calculate coulomb potential ratio</p>"},{"location":"Source-Code/particula/util/coulomb_enhancement/#signature_7","title":"Signature","text":"<pre><code>def cpr(**kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/debye_function/","title":"Debye Function","text":"<p>Particula Index / Particula / Util / Debye Function</p> <p>Auto-generated documentation for particula.util.debye_function module.</p>"},{"location":"Source-Code/particula/util/debye_function/#df1","title":"df1","text":"<p>Show source in debye_function.py:8</p> <p>debye function</p>"},{"location":"Source-Code/particula/util/debye_function/#signature","title":"Signature","text":"<pre><code>def df1(var): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusion_coefficient/","title":"Diffusion Coefficient","text":"<p>Particula Index / Particula / Util / Diffusion Coefficient</p> <p>Auto-generated documentation for particula.util.diffusion_coefficient module.</p>"},{"location":"Source-Code/particula/util/diffusion_coefficient/#pdc","title":"pdc","text":"<p>Show source in diffusion_coefficient.py:11</p> <p>particle diffusion coefficient</p>"},{"location":"Source-Code/particula/util/diffusion_coefficient/#signature","title":"Signature","text":"<pre><code>def pdc(temperature=298.15, bolk=BOLTZMANN_CONSTANT, pam_val=None, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusion_coefficient/#see-also","title":"See also","text":"<ul> <li>BOLTZMANN_CONSTANT</li> </ul>"},{"location":"Source-Code/particula/util/diffusive_knudsen/","title":"DiffusiveKnudsen","text":"<p>Particula Index / Particula / Util / DiffusiveKnudsen</p> <p>Auto-generated documentation for particula.util.diffusive_knudsen module.</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#diffusiveknudsen_1","title":"DiffusiveKnudsen","text":"<p>Show source in diffusive_knudsen.py:14</p> <p>A class for Diff..Knu</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature","title":"Signature","text":"<pre><code>class DiffusiveKnudsen(CoulombEnhancement):\n    def __init__(self, density=1000, other_density=None, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#see-also","title":"See also","text":"<ul> <li>CoulombEnhancement</li> </ul>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#diffusiveknudsenget_celimits","title":"DiffusiveKnudsen().get_celimits","text":"<p>Show source in diffusive_knudsen.py:73</p> <p>get coag enh limits</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature_1","title":"Signature","text":"<pre><code>def get_celimits(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#diffusiveknudsenget_ces","title":"DiffusiveKnudsen().get_ces","text":"<p>Show source in diffusive_knudsen.py:67</p> <p>get coulomb enhancement parameters</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature_2","title":"Signature","text":"<pre><code>def get_ces(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#diffusiveknudsenget_diff_knu","title":"DiffusiveKnudsen().get_diff_knu","text":"<p>Show source in diffusive_knudsen.py:80</p> <p>calculate it</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature_3","title":"Signature","text":"<pre><code>def get_diff_knu(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#diffusiveknudsenget_red_frifac","title":"DiffusiveKnudsen().get_red_frifac","text":"<p>Show source in diffusive_knudsen.py:51</p> <p>get the reduced friction factor</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature_4","title":"Signature","text":"<pre><code>def get_red_frifac(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#diffusiveknudsenget_red_mass","title":"DiffusiveKnudsen().get_red_mass","text":"<p>Show source in diffusive_knudsen.py:34</p> <p>get the reduced mass</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature_5","title":"Signature","text":"<pre><code>def get_red_mass(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#diffusiveknudsenget_rxr","title":"DiffusiveKnudsen().get_rxr","text":"<p>Show source in diffusive_knudsen.py:45</p> <p>add two radii</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature_6","title":"Signature","text":"<pre><code>def get_rxr(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#celimits","title":"celimits","text":"<p>Show source in diffusive_knudsen.py:163</p> <p>get coag enh limits</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature_7","title":"Signature","text":"<pre><code>def celimits(**kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#ces","title":"ces","text":"<p>Show source in diffusive_knudsen.py:156</p> <p>get the coulomb enhancement limits</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature_8","title":"Signature","text":"<pre><code>def ces(**kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#diff_knu","title":"diff_knu","text":"<p>Show source in diffusive_knudsen.py:94</p> <p>Diffusive Knudsen number.</p> <p>The diffusive Knudsen number is different from Knudsen number. Ratio of:     - numerator: mean persistence of one particle     - denominator: effective length scale of         particle--particle Coulombic interaction</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.diffusive_knudsen import diff_knu\n&gt;&gt;&gt; # with only one radius\n&gt;&gt;&gt; diff_knu(radius=1e-9)\n&lt;Quantity(29.6799, 'dimensionless')&gt;\n&gt;&gt;&gt; # with two radii\n&gt;&gt;&gt; diff_knu(radius=1e-9, other_radius=1e-8)\n&lt;Quantity(3.85387845, 'dimensionless')&gt;\n&gt;&gt;&gt; # with radii and charges\n&gt;&gt;&gt; diff_knu(radius=1e-9, other_radius=1e-8, charge=-1, other_charge=1)\n&lt;Quantity(4.58204028, 'dimensionless')&gt;\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#arguments","title":"Arguments","text":"<p>radius          (float) [m] other_radius    (float) [m]             (default: radius) density         (float) [kg/m^3]        (default: 1000) other_density   (float) [kg/m^3]        (default: density) charge          (int)   [dimensionless] (default: 0) other_charge    (int)   [dimensionless] (default: 0) temperature     (float) [K]             (default: 298)</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#returns","title":"Returns","text":"<p>(float) [dimensionless]</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#notes","title":"Notes","text":"<p>this function uses the friction factor and the coulomb enhancement calculations; for more information, please see the documentation of the respective functions:     - particula.util.friction_factor.frifac(**kwargs)     - particula.util.coulomb_enhancement.cekl(**kwargs)     - particula.util.coulomb_enhancement.cecl(**kwargs)</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature_9","title":"Signature","text":"<pre><code>def diff_knu(**kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#red_frifac","title":"red_frifac","text":"<p>Show source in diffusive_knudsen.py:149</p> <p>get the reduced friction factor</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature_10","title":"Signature","text":"<pre><code>def red_frifac(**kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#red_mass","title":"red_mass","text":"<p>Show source in diffusive_knudsen.py:142</p> <p>get the reduced mass</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature_11","title":"Signature","text":"<pre><code>def red_mass(**kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#rxr","title":"rxr","text":"<p>Show source in diffusive_knudsen.py:170</p> <p>add two radii</p>"},{"location":"Source-Code/particula/util/diffusive_knudsen/#signature_12","title":"Signature","text":"<pre><code>def rxr(**kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/dilution_loss/","title":"Dilution Loss","text":"<p>Particula Index / Particula / Util / Dilution Loss</p> <p>Auto-generated documentation for particula.util.dilution_loss module.</p>"},{"location":"Source-Code/particula/util/dilution_loss/#drc","title":"drc","text":"<p>Show source in dilution_loss.py:5</p> <p>calculate the dilution loss coefficient</p>"},{"location":"Source-Code/particula/util/dilution_loss/#signature","title":"Signature","text":"<pre><code>def drc(value=0.0): ...\n</code></pre>"},{"location":"Source-Code/particula/util/dimensionless_coagulation/","title":"DimensionlessCoagulation","text":"<p>Particula Index / Particula / Util / DimensionlessCoagulation</p> <p>Auto-generated documentation for particula.util.dimensionless_coagulation module.</p>"},{"location":"Source-Code/particula/util/dimensionless_coagulation/#dimensionlesscoagulation_1","title":"DimensionlessCoagulation","text":"<p>Show source in dimensionless_coagulation.py:12</p> <p>dimensionless coagulation</p>"},{"location":"Source-Code/particula/util/dimensionless_coagulation/#signature","title":"Signature","text":"<pre><code>class DimensionlessCoagulation(DKn):\n    def __init__(self, dkn_val=None, coag_approx=\"hardsphere\", **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/dimensionless_coagulation/#see-also","title":"See also","text":"<ul> <li>DiffusiveKnudsen</li> </ul>"},{"location":"Source-Code/particula/util/dimensionless_coagulation/#dimensionlesscoagulationcoag_full","title":"DimensionlessCoagulation().coag_full","text":"<p>Show source in dimensionless_coagulation.py:58</p> <p>Retrun the dimensioned coagulation kernel</p>"},{"location":"Source-Code/particula/util/dimensionless_coagulation/#signature_1","title":"Signature","text":"<pre><code>def coag_full(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/dimensionless_coagulation/#dimensionlesscoagulationcoag_less","title":"DimensionlessCoagulation().coag_less","text":"<p>Show source in dimensionless_coagulation.py:43</p> <p>Return the dimensionless coagulation kernel.</p>"},{"location":"Source-Code/particula/util/dimensionless_coagulation/#signature_2","title":"Signature","text":"<pre><code>def coag_less(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/dimensionless_coagulation/#full_coag","title":"full_coag","text":"<p>Show source in dimensionless_coagulation.py:102</p> <p>Return the dimensioned coagulation kernel</p>"},{"location":"Source-Code/particula/util/dimensionless_coagulation/#signature_3","title":"Signature","text":"<pre><code>def full_coag(**kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/dimensionless_coagulation/#less_coag","title":"less_coag","text":"<p>Show source in dimensionless_coagulation.py:73</p> <p>Return the dimensionless coagulation kernel.</p> <p>The dimensionless coagulation kernel is defined as a function of the diffusive knudsen number; for more info, please see the documentation of the respective function:     - particula.util.diffusive_knudsen.diff_knu(**kwargs)</p>"},{"location":"Source-Code/particula/util/dimensionless_coagulation/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.dimensionless_coagulation import less_coag\n&gt;&gt;&gt; # only for hardsphere coagulation for now\n&gt;&gt;&gt; # with only one radius\n&gt;&gt;&gt; less_coag(radius=1e-9)\n&lt;Quantity(147.877572, 'dimensionless')&gt;\n&gt;&gt;&gt; # with two radii\n&gt;&gt;&gt; less_coag(radius=1e-9, other_radius=1e-8)\n&lt;Quantity(18.4245966, 'dimensionless')&gt;\n&gt;&gt;&gt; # with two radii and charges\n&gt;&gt;&gt; less_coag(\n... radius=1e-9, other_radius=1e-8, charge=1, other_charge=-1\n... )\n&lt;Quantity(22.0727435, 'dimensionless')&gt;\n\n#### Signature\n\n```python\ndef less_coag(**kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/distribution_discretization/","title":"Distribution Discretization","text":"<p>Particula Index / Particula / Util / Distribution Discretization</p> <p>Auto-generated documentation for particula.util.distribution_discretization module.</p>"},{"location":"Source-Code/particula/util/distribution_discretization/#discretize","title":"discretize","text":"<p>Show source in distribution_discretization.py:9</p> <p>discretize the distribution of the particles</p>"},{"location":"Source-Code/particula/util/distribution_discretization/#arguments","title":"Arguments","text":"<p>interval    (float) the size interval of the distribution distype     (str)   the type of distribution, \"lognormal\" for now gsigma      (float) geometric standard deviation of distribution mode        (float) pdf scale (corresponds to mode in lognormal)</p>"},{"location":"Source-Code/particula/util/distribution_discretization/#signature","title":"Signature","text":"<pre><code>def discretize(\n    interval=None,\n    disttype=\"lognormal\",\n    gsigma=in_scalar(1.25).m,\n    mode=in_radius(1e-07),\n    nparticles=in_scalar(100000.0).m,\n    **kwargs\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/dynamic_viscosity/","title":"Dynamic Viscosity","text":"<p>Particula Index / Particula / Util / Dynamic Viscosity</p> <p>Auto-generated documentation for particula.util.dynamic_viscosity module.</p>"},{"location":"Source-Code/particula/util/dynamic_viscosity/#dyn_vis","title":"dyn_vis","text":"<p>Show source in dynamic_viscosity.py:21</p> <p>The dynamic viscosity of air via Sutherland formula. This formula depends on temperature (temp) and the reference temperature (t_ref) as well as the reference viscosity (mu_ref).</p>"},{"location":"Source-Code/particula/util/dynamic_viscosity/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.dynamic_viscosity import dyn_vis\n&gt;&gt;&gt; # with units\n&gt;&gt;&gt; dyn_vis(\n... temperature=298.15*u.K,\n... reference_viscosity=1.716e-5*u.Pa*u.s\n... )\n&lt;Quantity(1.83714937e-05, 'kilogram / meter / second')&gt;\n&gt;&gt;&gt; # without units and taking magnitude\n&gt;&gt;&gt; dyn_vis(\n... temperature=298.15,\n... reference_viscosity=1.716e-5\n... ).magnitude\n1.8371493734583912e-05\n&gt;&gt;&gt; # without units, all keyword arguments\n&gt;&gt;&gt; dyn_vis(\n... temperature=298.15,\n... reference_viscosity=1.716e-5,\n... reference_temperature=273.15\n... )\n&lt;Quantity(1.83714937e-05, 'kilogram / meter / second')&gt;\n&gt;&gt;&gt; # for a list of temperatures\n&gt;&gt;&gt; dyn_vis(temperature=[200, 250, 300, 400]).m\narray([1.32849751e-05, 1.59905239e-05, 1.84591625e-05, 2.28516090e-05])\n</code></pre> <p>Inputs:     temperature             (float) [K]     (default: 298.15)     reference_viscosity     (float) [Pa*s]  (default: constants)     reference_temperature   (float) [K]     (default: constants)     sutherland_constant     (float) [K]     (default: constants)</p>"},{"location":"Source-Code/particula/util/dynamic_viscosity/#returns","title":"Returns","text":"<p>(float) [Pa*s]</p> <p>Using particula.constants:     REF_VISCOSITY_AIR_STP   (float) [Pa*s]     REF_TEMPERATURE_STP     (float) [K]     SUTHERLAND_CONSTANT     (float) [K]</p>"},{"location":"Source-Code/particula/util/dynamic_viscosity/#signature","title":"Signature","text":"<pre><code>def dyn_vis(\n    temperature=298.15 * u.K,\n    reference_viscosity=REF_VISCOSITY_AIR_STP,\n    reference_temperature=REF_TEMPERATURE_STP,\n    sutherland_constant=SUTHERLAND_CONSTANT,\n    **kwargs\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/dynamic_viscosity/#see-also","title":"See also","text":"<ul> <li>REF_TEMPERATURE_STP</li> <li>REF_VISCOSITY_AIR_STP</li> <li>SUTHERLAND_CONSTANT</li> </ul>"},{"location":"Source-Code/particula/util/friction_factor/","title":"Friction Factor","text":"<p>Particula Index / Particula / Util / Friction Factor</p> <p>Auto-generated documentation for particula.util.friction_factor module.</p>"},{"location":"Source-Code/particula/util/friction_factor/#frifac","title":"frifac","text":"<p>Show source in friction_factor.py:10</p> <p>Returns a particle's friction factor.</p> <p>Property of the particle's size and surrounding medium. Multiplying the friction factor by the fluid velocity yields the drag force on the particle.</p> <p>It is best thought of as an inverse of mobility or the ratio between thermal energy and diffusion coefficient. The modified Stoke's diffusion coefficient is defined as kT / (6 * np.pi * dyn_vis_air * radius / slip_corr) and thus the friction factor can be defined as (6 * np.pi * dyn_vis_air * radius / slip_corr).</p> <p>In the continuum limit (Kn -&gt; 0; Cc -&gt; 1):     6 * np.pi * dyn_vis_air * radius</p> <p>In the kinetic limit (Kn -&gt; inf):     8.39 * (dyn_vis_air/mfp_air) * const * radius**2</p> <p>See more: DOI: 10.1080/02786826.2012.690543 (const=1.36)</p>"},{"location":"Source-Code/particula/util/friction_factor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.friction_factor import frifac\n&gt;&gt;&gt; # with 1e-9 m radius\n&gt;&gt;&gt; frifac(radius=1e-9)\n&lt;Quantity(3.12763919e-15, 'kilogram / second')&gt;\n&gt;&gt;&gt; # with 1e-9 m radius and 1e-5 N/m^2 dynamic viscosity\n&gt;&gt;&gt; frifac(radius=1e-9, dynamic_viscosity=1e-5)\n&lt;Quantity(3.114213e-15, 'kilogram / second')&gt;\n&gt;&gt;&gt; # using dyn_vis(**kwargs)\n&gt;&gt;&gt; frifac(\n... radius=1e-9,\n... temperature=298.15,\n... reference_viscosity=1.716e-5,\n... reference_temperature=273.15\n)\n&lt;Quantity(3.12763919e-15, 'kilogram / second')&gt;\n&gt;&gt;&gt; # overriding sfc(**kwargs)\n&gt;&gt;&gt; frifac(radius=1e-9, slip_correction=1.5)\n&lt;Quantity(3.12763919e-15, 'kilogram / second')&gt;\n</code></pre>"},{"location":"Source-Code/particula/util/friction_factor/#arguments","title":"Arguments","text":"<p>radius            (float) [m] dynamic_viscosity (float) [kg/m/s]  (default: util) slip_corr_factor  (float) [ ]       (default: util)</p>"},{"location":"Source-Code/particula/util/friction_factor/#returns","title":"Returns","text":"<p>(float) [N*s/m]</p>"},{"location":"Source-Code/particula/util/friction_factor/#notes","title":"Notes","text":"<p>dynamic_viscosity can be calculated using the utility function particula.util.dynamic_viscosity.dyn_vis(**kwargs) and slip_corr_factor can be calculated using the utility function particula.util.slip_correction.scf(**kwargs); see respective documentation for more information.</p>"},{"location":"Source-Code/particula/util/friction_factor/#signature","title":"Signature","text":"<pre><code>def frifac(radius=None, dynamic_viscosity=None, scf_val=None, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/fuchs_sutugin/","title":"Fuchs Sutugin","text":"<p>Particula Index / Particula / Util / Fuchs Sutugin</p> <p>Auto-generated documentation for particula.util.fuchs_sutugin module.</p>"},{"location":"Source-Code/particula/util/fuchs_sutugin/#fsc","title":"fsc","text":"<p>Show source in fuchs_sutugin.py:9</p> <p>Returns the Fuchs-Sutugin model transition regime correction.</p>"},{"location":"Source-Code/particula/util/fuchs_sutugin/#arguments","title":"Arguments","text":"<p>knu     (float)  [ ] (default: util) alpha   (float)  [ ] (default: 1)</p>"},{"location":"Source-Code/particula/util/fuchs_sutugin/#returns","title":"Returns","text":"<p>(float)  [ ]</p>"},{"location":"Source-Code/particula/util/fuchs_sutugin/#notes","title":"Notes","text":"<p>knu can be calculated using knu(**kwargs); refer to particula.util.knudsen_number.knu for more info.</p>"},{"location":"Source-Code/particula/util/fuchs_sutugin/#signature","title":"Signature","text":"<pre><code>def fsc(knu_val=None, alpha=1, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/","title":"Input Handling","text":"<p>Particula Index / Particula / Util / Input Handling</p> <p>Auto-generated documentation for particula.util.input_handling module.</p>"},{"location":"Source-Code/particula/util/input_handling/#convert_units","title":"convert_units","text":"<p>Show source in input_handling.py:77</p> <p>generic pint function to convert units</p>"},{"location":"Source-Code/particula/util/input_handling/#arguments","title":"Arguments","text":"<p>old     [str | u.Quantity] new     [str | u.Quantity] value   (float) [optional]</p>"},{"location":"Source-Code/particula/util/input_handling/#returns","title":"Returns","text":"<p>multiplier     (float)</p>"},{"location":"Source-Code/particula/util/input_handling/#notes","title":"Notes","text":"<ul> <li>If unit is correct, take to base units</li> <li>Throws ValueError if unit is wrong</li> <li>Assigning default base units to scalar input</li> </ul>"},{"location":"Source-Code/particula/util/input_handling/#signature","title":"Signature","text":"<pre><code>def convert_units(\n    old: Union[str, u.Quantity],\n    new: Union[str, u.Quantity],\n    value: Optional[float] = None,\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_acceleration","title":"in_acceleration","text":"<p>Show source in input_handling.py:128</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_1","title":"Signature","text":"<pre><code>def in_acceleration(acc): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_area","title":"in_area","text":"<p>Show source in input_handling.py:133</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_2","title":"Signature","text":"<pre><code>def in_area(area): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_concentration","title":"in_concentration","text":"<p>Show source in input_handling.py:135</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_3","title":"Signature","text":"<pre><code>def in_concentration(conc): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_density","title":"in_density","text":"<p>Show source in input_handling.py:130</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_4","title":"Signature","text":"<pre><code>def in_density(density): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_gas_constant","title":"in_gas_constant","text":"<p>Show source in input_handling.py:134</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_5","title":"Signature","text":"<pre><code>def in_gas_constant(con): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_handling","title":"in_handling","text":"<p>Show source in input_handling.py:44</p> <p>generic function to handle inputs</p>"},{"location":"Source-Code/particula/util/input_handling/#arguments_1","title":"Arguments","text":"<p>value     (float)       [u.Quantity | dimensionless] units     (u.Quantity)</p>"},{"location":"Source-Code/particula/util/input_handling/#returns_1","title":"Returns","text":"<p>value     (float)       [u.Quantity]</p>"},{"location":"Source-Code/particula/util/input_handling/#notes_1","title":"Notes","text":"<ul> <li>If unit is correct, take to base units</li> <li>Throws ValueError if unit is wrong</li> <li>Assigning default base units to scalar input</li> </ul>"},{"location":"Source-Code/particula/util/input_handling/#signature_6","title":"Signature","text":"<pre><code>def in_handling(value, units: u.Quantity): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_latent_heat","title":"in_latent_heat","text":"<p>Show source in input_handling.py:137</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_7","title":"Signature","text":"<pre><code>def in_latent_heat(latheat): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_length","title":"in_length","text":"<p>Show source in input_handling.py:132</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_8","title":"Signature","text":"<pre><code>def in_length(length): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_mass","title":"in_mass","text":"<p>Show source in input_handling.py:124</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_9","title":"Signature","text":"<pre><code>def in_mass(mass): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_molecular_weight","title":"in_molecular_weight","text":"<p>Show source in input_handling.py:129</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_10","title":"Signature","text":"<pre><code>def in_molecular_weight(molw): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_pressure","title":"in_pressure","text":"<p>Show source in input_handling.py:123</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_11","title":"Signature","text":"<pre><code>def in_pressure(pres): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_radius","title":"in_radius","text":"<p>Show source in input_handling.py:8</p> <p>Handles radius input</p>"},{"location":"Source-Code/particula/util/input_handling/#arguments_2","title":"Arguments","text":"<p>radius    (float) [m | dimensionless]</p>"},{"location":"Source-Code/particula/util/input_handling/#returns_2","title":"Returns","text":"<p>radius    (float) [m]</p>"},{"location":"Source-Code/particula/util/input_handling/#notes_2","title":"Notes","text":"<ul> <li>If unit is correct, take to base units in m</li> <li>Throws ValueError if unit is wrong</li> <li>Assigning m units to scalar input</li> </ul>"},{"location":"Source-Code/particula/util/input_handling/#signature_12","title":"Signature","text":"<pre><code>def in_radius(radius): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_scalar","title":"in_scalar","text":"<p>Show source in input_handling.py:131</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_13","title":"Signature","text":"<pre><code>def in_scalar(scalar): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_surface_tension","title":"in_surface_tension","text":"<p>Show source in input_handling.py:136</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_14","title":"Signature","text":"<pre><code>def in_surface_tension(surften): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_temperature","title":"in_temperature","text":"<p>Show source in input_handling.py:121</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_15","title":"Signature","text":"<pre><code>def in_temperature(temp): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_time","title":"in_time","text":"<p>Show source in input_handling.py:126</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_16","title":"Signature","text":"<pre><code>def in_time(time): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_velocity","title":"in_velocity","text":"<p>Show source in input_handling.py:127</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_17","title":"Signature","text":"<pre><code>def in_velocity(vel): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_viscosity","title":"in_viscosity","text":"<p>Show source in input_handling.py:122</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_18","title":"Signature","text":"<pre><code>def in_viscosity(vis): ...\n</code></pre>"},{"location":"Source-Code/particula/util/input_handling/#in_volume","title":"in_volume","text":"<p>Show source in input_handling.py:125</p>"},{"location":"Source-Code/particula/util/input_handling/#signature_19","title":"Signature","text":"<pre><code>def in_volume(vol): ...\n</code></pre>"},{"location":"Source-Code/particula/util/kelvin_correction/","title":"Kelvin Correction","text":"<p>Particula Index / Particula / Util / Kelvin Correction</p> <p>Auto-generated documentation for particula.util.kelvin_correction module.</p>"},{"location":"Source-Code/particula/util/kelvin_correction/#kelvin_radius","title":"kelvin_radius","text":"<p>Show source in kelvin_correction.py:11</p> <p>Kelvin radius (Neil's definition) https://en.wikipedia.org/wiki/Kelvin_equation</p>"},{"location":"Source-Code/particula/util/kelvin_correction/#signature","title":"Signature","text":"<pre><code>def kelvin_radius(\n    surface_tension=0.072 * u.N / u.m,\n    molecular_weight=0.01815 * u.kg / u.mol,\n    density=1000 * u.kg / u.m**3,\n    temperature=298.15 * u.K,\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/kelvin_correction/#kelvin_term","title":"kelvin_term","text":"<p>Show source in kelvin_correction.py:31</p> <p>Kelvin term (Neil's definition) https://en.wikipedia.org/wiki/Kelvin_equation</p>"},{"location":"Source-Code/particula/util/kelvin_correction/#signature_1","title":"Signature","text":"<pre><code>def kelvin_term(radius=None, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/knudsen_number/","title":"Knudsen Number","text":"<p>Particula Index / Particula / Util / Knudsen Number</p> <p>Auto-generated documentation for particula.util.knudsen_number module.</p>"},{"location":"Source-Code/particula/util/knudsen_number/#knu","title":"knu","text":"<p>Show source in knudsen_number.py:18</p> <p>Returns particle's Knudsen number.</p> <p>The Knudsen number reflects the relative length scales of the particle and the suspending fluid (air, water, etc.). This is calculated by the mean free path of the medium divided by the particle radius.</p> <p>The Knudsen number is a measure of continuum effects and deviation thereof. For larger particles, the Knudsen number goes towards 0. For smaller particles, the Knudsen number goes towards infinity.</p>"},{"location":"Source-Code/particula/util/knudsen_number/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.knudsen_number import knu\n&gt;&gt;&gt; # with radius 1e-9 m\n&gt;&gt;&gt; knu(radius=1e-9)\n&lt;Quantity(66.4798498, 'dimensionless')&gt;\n&gt;&gt;&gt; # with radius 1e-9 m and mfp 60 nm\n&gt;&gt;&gt; knu(radius=1e-9*u.m, mfp=60*u.nm).m\n60.00000000000001\n&gt;&gt;&gt; calculating via mfp(**kwargs)\n&gt;&gt;&gt; knu(\n... radius=1e-9*u.m,\n... temperature=300,\n... pressure=1e5,\n... molecular_weight=0.03,\n... )\n&lt;Quantity(66.7097062, 'dimensionless')&gt;\n</code></pre>"},{"location":"Source-Code/particula/util/knudsen_number/#arguments","title":"Arguments","text":"<p>radius  (float) [m] mfp     (float) [m] (default: util)</p>"},{"location":"Source-Code/particula/util/knudsen_number/#returns","title":"Returns","text":"<p>(float) [dimensionless]</p>"},{"location":"Source-Code/particula/util/knudsen_number/#notes","title":"Notes","text":"<p>mfp can be calculated using mfp(**kwargs); refer to particula.util.mean_free_path.mfp for more info.</p>"},{"location":"Source-Code/particula/util/knudsen_number/#signature","title":"Signature","text":"<pre><code>def knu(radius=None, mfp=None, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/machine_limit/","title":"Machine Limit","text":"<p>Particula Index / Particula / Util / Machine Limit</p> <p>Auto-generated documentation for particula.util.machine_limit module.</p>"},{"location":"Source-Code/particula/util/machine_limit/#safe_exp","title":"safe_exp","text":"<p>Show source in machine_limit.py:7</p> <p>Compute the exponential of each element in the input array, with limits to prevent overflow based on machine precision.</p>"},{"location":"Source-Code/particula/util/machine_limit/#arguments","title":"Arguments","text":"<ul> <li><code>value</code> ArrayLike - Input array.</li> </ul>"},{"location":"Source-Code/particula/util/machine_limit/#returns","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Exponential of the input array with overflow protection.</li> </ul>"},{"location":"Source-Code/particula/util/machine_limit/#signature","title":"Signature","text":"<pre><code>def safe_exp(value: ArrayLike) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/machine_limit/#safe_log","title":"safe_log","text":"<p>Show source in machine_limit.py:23</p> <p>Compute the natural logarithm of each element in the input array, with limits to prevent underflow based on machine precision.</p>"},{"location":"Source-Code/particula/util/machine_limit/#arguments_1","title":"Arguments","text":"<ul> <li><code>value</code> ArrayLike - Input array.</li> </ul>"},{"location":"Source-Code/particula/util/machine_limit/#returns_1","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Natural logarithm of the input array with underflow protection.</li> </ul>"},{"location":"Source-Code/particula/util/machine_limit/#signature_1","title":"Signature","text":"<pre><code>def safe_log(value: ArrayLike) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/machine_limit/#safe_log10","title":"safe_log10","text":"<p>Show source in machine_limit.py:40</p> <p>Compute the base 10 logarithm of each element in the input array, with limits to prevent underflow based on machine precision.</p>"},{"location":"Source-Code/particula/util/machine_limit/#arguments_2","title":"Arguments","text":"<ul> <li><code>value</code> ArrayLike - Input array.</li> </ul>"},{"location":"Source-Code/particula/util/machine_limit/#returns_2","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Base 10 logarithm of the input array with underflow protection.</li> </ul>"},{"location":"Source-Code/particula/util/machine_limit/#signature_2","title":"Signature","text":"<pre><code>def safe_log10(value: ArrayLike) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/mean_free_path/","title":"Mean Free Path","text":"<p>Particula Index / Particula / Util / Mean Free Path</p> <p>Auto-generated documentation for particula.util.mean_free_path module.</p>"},{"location":"Source-Code/particula/util/mean_free_path/#mfp","title":"mfp","text":"<p>Show source in mean_free_path.py:22</p> <p>Returns the mean free path of in air.</p> <p>The mean free path is the average distance traveled by a molecule between collisions with other molecules present in a medium (air).</p> <p>The expeected mean free path of air is approx. 65 nm at 298 K and 101325 Pa.</p>"},{"location":"Source-Code/particula/util/mean_free_path/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.mean_free_path import mfp\n&gt;&gt;&gt; # with no inputs, it defaults to 298 K and 101325 Pa\n&gt;&gt;&gt; mfp()\n&lt;Quantity(6.64373669e-08, 'meter')&gt;\n&gt;&gt;&gt; # specifying a temperature of 300 K\n&gt;&gt;&gt; mfp(temperature=300*u.K).magnitude\n6.700400687925813e-08\n&gt;&gt;&gt; # specifying 300 K and  pressure of 1e5 Pa\n&gt;&gt;&gt; mfp(temperature=300*u.K, pressure=1e5*u.Pa)\n&lt;Quantity(6.789181e-08, 'meter')&gt;\n&gt;&gt;&gt; mfp(\n... temperature=300,\n... pressure=1e5,\n... molecular_weight=0.03\n... )\n&lt;Quantity(6.67097062e-08, 'meter')&gt;\n&gt;&gt;&gt; # specifying explicit value for dynamic viscosity\n&gt;&gt;&gt; mfp(dynamic_viscosity=1e-5)\n&lt;Quantity(3.61864151e-08, 'meter')&gt;\n&gt;&gt;&gt; # specifying implicit value for dynamic viscosity\n&gt;&gt;&gt; mfp(\n... temperature=300,\n... reference_viscosity=1e-5,\n... reference_temperature=273.15\n... )\n&lt;Quantity(3.90466241e-08, 'meter')&gt;\n&gt;&gt;&gt; # specifying a list of temperatures\n&gt;&gt;&gt; mfp(temperature=[200, 250, 300, 400]).m\narray([3.93734886e-08, 5.29859655e-08, 6.70040069e-08, 9.57800224e-08])\n&gt;&gt;&gt; # specifying a list of pressures\n&gt;&gt;&gt; mfp(pressure=[1.0e5, 1.1e5, 1.2e5, 1.3e5]).m\narray([6.73607078e-08, 6.12370071e-08, 5.61339232e-08, 5.18159291e-08])\n&gt;&gt;&gt; # specifying a list of pressures and temperatures\n&gt;&gt;&gt; mfp(temperature=[300,310], pressure=[1e5, 1.1e5])\n&lt;Quantity([6.78918100e-08 6.43354325e-08], 'meter')&gt;\n</code></pre> <ul> <li><code>Args</code> - (either # or $)     temperature           (float) [K]      (default: 298)     pressure              (float) [Pa]     (default: 101325)     molecular_weight      (float) [kg/mol] (default: constants)</li> </ul>"},{"location":"Source-Code/particula/util/mean_free_path/#dynamic_viscosity-float-pas-default-util","title":"dynamic_viscosity     (float) [Pa*s]   (default: util)","text":"<p>$   reference_viscosity   (float) [Pa*s]   (default: constants) $   reference_temperature (float) [K]      (default: constants)</p>"},{"location":"Source-Code/particula/util/mean_free_path/#returns","title":"Returns","text":"<p>(float) [m]</p> <p>Using particula.constants:     GAS_CONSTANT            (float) [J/mol/K]     MOLECULAR_WEIGHT_AIR    (float) [kg/mol]</p> <p>REF_VISCOSITY_AIR_STP   (float) [Pa*s] REF_TEMPERATURE_STP     (float) [K] SUTHERLAND_CONSTANT     (float) [K]</p>"},{"location":"Source-Code/particula/util/mean_free_path/#notes","title":"Notes","text":"<p>dynamic_viscosity can be calculated independently via particula.util.dynamic_viscosity.dyn_vis(**kwargs), but if the value of dynamic_viscosity is provided directly, it overrides the calculated value.</p>"},{"location":"Source-Code/particula/util/mean_free_path/#signature","title":"Signature","text":"<pre><code>def mfp(\n    temperature=298.15 * u.K,\n    pressure=101325 * u.Pa,\n    molecular_weight=MOLECULAR_WEIGHT_AIR,\n    dynamic_viscosity=None,\n    gas_constant=GAS_CONSTANT,\n    **kwargs\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/mean_free_path/#see-also","title":"See also","text":"<ul> <li>GAS_CONSTANT</li> <li>MOLECULAR_WEIGHT_AIR</li> </ul>"},{"location":"Source-Code/particula/util/molecular_enhancement/","title":"Molecular Enhancement","text":"<p>Particula Index / Particula / Util / Molecular Enhancement</p> <p>Auto-generated documentation for particula.util.molecular_enhancement module.</p>"},{"location":"Source-Code/particula/util/molecular_enhancement/#mol_enh","title":"mol_enh","text":"<p>Show source in molecular_enhancement.py:12</p> <p>Returns the molecular enhancement.</p>"},{"location":"Source-Code/particula/util/molecular_enhancement/#arguments","title":"Arguments","text":"<p>vapor_size      (float)  [m] particle_size   (float)  [m]</p>"},{"location":"Source-Code/particula/util/molecular_enhancement/#returns","title":"Returns","text":"<p>(float)  [ ]</p> <p>TODO:     - Add explanation of molecular enhancement.</p>"},{"location":"Source-Code/particula/util/molecular_enhancement/#signature","title":"Signature","text":"<pre><code>def mol_enh(vapor_size, particle_size): ...\n</code></pre>"},{"location":"Source-Code/particula/util/particle_mass/","title":"Particle Mass","text":"<p>Particula Index / Particula / Util / Particle Mass</p> <p>Auto-generated documentation for particula.util.particle_mass module.</p>"},{"location":"Source-Code/particula/util/particle_mass/#mass","title":"mass","text":"<p>Show source in particle_mass.py:8</p> <p>Returns particle's mass: 4/3 pi r^3 * density.</p>"},{"location":"Source-Code/particula/util/particle_mass/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; particle_mass(1*u.m)\n&lt;Quantity(4188.7902, 'kilogram')&gt;\n&gt;&gt;&gt; particle_mass(1*u.nm, 1000*u.kg/u.m**3).m\n4.188790204786392e-24\n&gt;&gt;&gt; particle_mass(1*u.nm, 1000*u.kg/u.m**3).m_as(u.g)\n4.188790204786392e-21\n&gt;&gt;&gt; particle_mass([1, 2, 3]*u.nm, 1000*u.kg/u.m**3).m\narray([4.18879020e-24, 3.35103216e-23, 1.13097336e-22])\n&gt;&gt;&gt; particle_mass([1, 2]*u.nm, [1, 2]*u.g/u.cm**3).m\narray([4.18879020e-24, 6.70206433e-23])\n&gt;&gt;&gt; particle_mass(2*u.nm, 2*u.g/u.cm**3).m\n6.702064327658225e-23\n</code></pre>"},{"location":"Source-Code/particula/util/particle_mass/#arguments","title":"Arguments","text":"<p>radius       (float) [m] density      (float) [kg/m^3] (default: 1000) shape_factor (float) [ ]      (default: 1) volume_void  (float) [ ]      (default: 0)</p>"},{"location":"Source-Code/particula/util/particle_mass/#returns","title":"Returns","text":"<p>(float) [kg]</p>"},{"location":"Source-Code/particula/util/particle_mass/#signature","title":"Signature","text":"<pre><code>def mass(radius=None, density=1000, shape_factor=1, volume_void=0, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/particle_surface/","title":"Particle Surface","text":"<p>Particula Index / Particula / Util / Particle Surface</p> <p>Auto-generated documentation for particula.util.particle_surface module.</p>"},{"location":"Source-Code/particula/util/particle_surface/#area","title":"area","text":"<p>Show source in particle_surface.py:8</p> <p>Returns particle's surface area: 4 pi r^2 .</p>"},{"location":"Source-Code/particula/util/particle_surface/#arguments","title":"Arguments","text":"<p>radius       (float) [m] area_factor  (float) [ ]      (default: 1)</p>"},{"location":"Source-Code/particula/util/particle_surface/#returns","title":"Returns","text":"<p>(float) [m^2]</p>"},{"location":"Source-Code/particula/util/particle_surface/#signature","title":"Signature","text":"<pre><code>def area(radius=None, area_factor=1): ...\n</code></pre>"},{"location":"Source-Code/particula/util/radius_cutoff/","title":"Radius Cutoff","text":"<p>Particula Index / Particula / Util / Radius Cutoff</p> <p>Auto-generated documentation for particula.util.radius_cutoff module.</p>"},{"location":"Source-Code/particula/util/radius_cutoff/#cut_rad","title":"cut_rad","text":"<p>Show source in radius_cutoff.py:11</p> <p>This routine determins the radius cutoff for the particle distribution</p> <p>Inputs:     cutoff  (float) coverage cutoff (default: .9999)     gsigma  (float) geometric standard deviation (default: 1.25)     mode    (float) mean radius of the particles (default: 1e-7)</p>"},{"location":"Source-Code/particula/util/radius_cutoff/#returns","title":"Returns","text":"<p>(starting radius, ending radius) float tuple</p>"},{"location":"Source-Code/particula/util/radius_cutoff/#signature","title":"Signature","text":"<pre><code>def cut_rad(\n    cutoff=in_scalar(0.9999).m,\n    gsigma=in_scalar(1.25).m,\n    mode=in_radius(1e-07),\n    force_radius_start=None,\n    force_radius_end=None,\n    **kwargs\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/reduced_quantity/","title":"Reduced Quantity","text":"<p>Particula Index / Particula / Util / Reduced Quantity</p> <p>Auto-generated documentation for particula.util.reduced_quantity module.</p>"},{"location":"Source-Code/particula/util/reduced_quantity/#reduced_quantity","title":"reduced_quantity","text":"<p>Show source in reduced_quantity.py:17</p> <p>Returns the reduced mass of two particles.</p>"},{"location":"Source-Code/particula/util/reduced_quantity/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; reduced_quantity(1*u.kg, 1*u.kg)\n&lt;Quantity(0.5, 'kilogram')&gt;\n&gt;&gt;&gt; reduced_quantity(1*u.kg, 20*u.kg).m\n0.9523809523809523\n&gt;&gt;&gt; reduced_quantity(1, 200)\n0.9950248756218906\n&gt;&gt;&gt; reduced_quantity([1, 2, 3], 200)\narray([0.99502488, 1.98019802, 2.95566502])\n&gt;&gt;&gt; reduced_quantity([1, 2], [200, 300])\narray([0.99502488, 1.98675497])\n</code></pre>"},{"location":"Source-Code/particula/util/reduced_quantity/#arguments","title":"Arguments","text":"<p>a_quantity  (float)  [arbitrary units] b_quantity  (float)  [arbitrary units]</p>"},{"location":"Source-Code/particula/util/reduced_quantity/#returns","title":"Returns","text":"<p>(float)  [arbitrary units]</p> <p>A reduced quantity is an \"effective inertial\" quantity, allowing two-body problems to be solved as one-body problems.</p>"},{"location":"Source-Code/particula/util/reduced_quantity/#signature","title":"Signature","text":"<pre><code>def reduced_quantity(a_quantity, b_quantity): ...\n</code></pre>"},{"location":"Source-Code/particula/util/reduced_quantity/#reduced_self_broadcast","title":"reduced_self_broadcast","text":"<p>Show source in reduced_quantity.py:131</p> <p>Returns the reduced value of an array with itself, broadcasting the array into a matrix and calculating the reduced value of each element pair. reduced_value = alpha_matrix * alpha_matrix_Transpose                 / (alpha_matrix + alpha_matrix_Transpose)</p>"},{"location":"Source-Code/particula/util/reduced_quantity/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> alpha_array - The array to be broadcast and reduced.</li> </ul>"},{"location":"Source-Code/particula/util/reduced_quantity/#returns_1","title":"Returns","text":"<ul> <li>A square matrix of the reduced values.</li> </ul>"},{"location":"Source-Code/particula/util/reduced_quantity/#signature_1","title":"Signature","text":"<pre><code>def reduced_self_broadcast(alpha_array: NDArray[np.float_]) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/reduced_quantity/#reduced_value","title":"reduced_value","text":"<p>Show source in reduced_quantity.py:90</p> <p>Returns the reduced value of two parameters, calculated as: reduced_value = alpha * beta / (alpha + beta)</p> <p>This formula calculates an \"effective inertial\" quantity, allowing two-body problems to be solved as if they were one-body problems.</p>"},{"location":"Source-Code/particula/util/reduced_quantity/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> alpha - The first parameter (scalar or array).</li> <li><code>-</code> beta - The second parameter (scalar or array).</li> </ul>"},{"location":"Source-Code/particula/util/reduced_quantity/#returns_2","title":"Returns","text":"<ul> <li>A value or array of the same dimension as the input parameters. Returns   zero where alpha + beta equals zero to handle division by zero   gracefully.</li> </ul>"},{"location":"Source-Code/particula/util/reduced_quantity/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If alpha and beta are arrays and their shapes do not match.</li> </ul>"},{"location":"Source-Code/particula/util/reduced_quantity/#signature_2","title":"Signature","text":"<pre><code>def reduced_value(\n    alpha: Union[float, NDArray[np.float_]], beta: Union[float, NDArray[np.float_]]\n) -&gt; Union[float, NDArray[np.float_]]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/rms_speed/","title":"Rms Speed","text":"<p>Particula Index / Particula / Util / Rms Speed</p> <p>Auto-generated documentation for particula.util.rms_speed module.</p>"},{"location":"Source-Code/particula/util/rms_speed/#cbar","title":"cbar","text":"<p>Show source in rms_speed.py:10</p> <p>Returns the mean speed of molecules in an ideal gas.</p>"},{"location":"Source-Code/particula/util/rms_speed/#arguments","title":"Arguments","text":"<p>temperature           (float) [K]      (default: 298.15) molecular_weight      (float) [kg/mol] (default: constants)</p>"},{"location":"Source-Code/particula/util/rms_speed/#returns","title":"Returns","text":"<p>(float) [m/s]</p> <p>Using particula.constants:     GAS_CONSTANT            (float) [J/mol/K]     MOLECULAR_WEIGHT_AIR    (float) [kg/mol]</p>"},{"location":"Source-Code/particula/util/rms_speed/#signature","title":"Signature","text":"<pre><code>def cbar(\n    temperature=298.15, molecular_weight=MOLECULAR_WEIGHT_AIR, gas_constant=GAS_CONSTANT\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/rms_speed/#see-also","title":"See also","text":"<ul> <li>GAS_CONSTANT</li> <li>MOLECULAR_WEIGHT_AIR</li> </ul>"},{"location":"Source-Code/particula/util/settling_velocity/","title":"Settling Velocity","text":"<p>Particula Index / Particula / Util / Settling Velocity</p> <p>Auto-generated documentation for particula.util.settling_velocity module.</p>"},{"location":"Source-Code/particula/util/settling_velocity/#psv","title":"psv","text":"<p>Show source in settling_velocity.py:8</p> <p>calculate the settling velocity</p>"},{"location":"Source-Code/particula/util/settling_velocity/#signature","title":"Signature","text":"<pre><code>def psv(\n    rad=None, den=None, scf_val=None, sgc=STANDARD_GRAVITY, vis_val=None, **kwargs\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/settling_velocity/#see-also","title":"See also","text":"<ul> <li>STANDARD_GRAVITY</li> </ul>"},{"location":"Source-Code/particula/util/simple_solver/","title":"SimpleSolver","text":"<p>Particula Index / Particula / Util / SimpleSolver</p> <p>Auto-generated documentation for particula.util.simple_solver module.</p>"},{"location":"Source-Code/particula/util/simple_solver/#simplesolver_1","title":"SimpleSolver","text":"<p>Show source in simple_solver.py:33</p> <p>a class to solve the ODE:</p> <p>Need: 1. initial distribution 2. associated radius 3. associated coagulation kernel</p> <p>Also: 1. desired time span in seconds (given unitless)</p>"},{"location":"Source-Code/particula/util/simple_solver/#signature","title":"Signature","text":"<pre><code>class SimpleSolver:\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/simple_solver/#simplesolverprep_inputs","title":"SimpleSolver().prep_inputs","text":"<p>Show source in simple_solver.py:66</p> <p>strip units, etc.</p>"},{"location":"Source-Code/particula/util/simple_solver/#signature_1","title":"Signature","text":"<pre><code>def prep_inputs(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/simple_solver/#simplesolversolution","title":"SimpleSolver().solution","text":"<p>Show source in simple_solver.py:77</p> <p>utilize scipy.integrate.odeint</p>"},{"location":"Source-Code/particula/util/simple_solver/#signature_2","title":"Signature","text":"<pre><code>def solution(self): ...\n</code></pre>"},{"location":"Source-Code/particula/util/simple_solver/#ode_func","title":"ode_func","text":"<p>Show source in simple_solver.py:21</p> <p>function to integrate</p>"},{"location":"Source-Code/particula/util/simple_solver/#signature_3","title":"Signature","text":"<pre><code>def ode_func(_nums, _, _rads, _coag): ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/","title":"Size Distribution Convert","text":"<p>Particula Index / Particula / Util / Size Distribution Convert</p> <p>Auto-generated documentation for particula.util.size_distribution_convert module.</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#conversionstrategy","title":"ConversionStrategy","text":"<p>Show source in size_distribution_convert.py:23</p> <p>Defines an interface for conversion strategies between particle size distribution formats.</p> <p>Subclasses must implement the convert method to perform specific conversion logic.</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature","title":"Signature","text":"<pre><code>class ConversionStrategy: ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#conversionstrategyconvert","title":"ConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:31</p> <p>Converter method common interface, for subclasses.</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#arguments","title":"Arguments","text":"<ul> <li><code>diameters</code> np.ndarray - The particle diameters.</li> <li><code>concentration</code> np.ndarray - The concentration values.</li> <li><code>inverse</code> bool - Flag to perform the inverse conversion.</li> </ul>"},{"location":"Source-Code/particula/util/size_distribution_convert/#returns","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - The concentration values converted.</li> </ul>"},{"location":"Source-Code/particula/util/size_distribution_convert/#raises","title":"Raises","text":"<ul> <li><code>NotImplementedError</code> - If the subclass does not implement this.</li> </ul>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature_1","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#dndlogdptopdfconversionstrategy","title":"DNdlogDPtoPDFConversionStrategy","text":"<p>Show source in size_distribution_convert.py:83</p> <p>Implements conversion between dn/dlogdp and PDF formats through an intermediate PMS format.</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature_2","title":"Signature","text":"<pre><code>class DNdlogDPtoPDFConversionStrategy(ConversionStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#see-also","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"Source-Code/particula/util/size_distribution_convert/#dndlogdptopdfconversionstrategyconvert","title":"DNdlogDPtoPDFConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:87</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature_3","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#dndlogdptopmsconversionstrategy","title":"DNdlogDPtoPMSConversionStrategy","text":"<p>Show source in size_distribution_convert.py:61</p> <p>Implements conversion between dn/dlogdp and PMS formats using the convert_sizer_dn method.</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature_4","title":"Signature","text":"<pre><code>class DNdlogDPtoPMSConversionStrategy(ConversionStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#see-also_1","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"Source-Code/particula/util/size_distribution_convert/#dndlogdptopmsconversionstrategyconvert","title":"DNdlogDPtoPMSConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:65</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature_5","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#pmstopdfconversionstrategy","title":"PMStoPDFConversionStrategy","text":"<p>Show source in size_distribution_convert.py:73</p> <p>Implements conversion between PMS and PDF formats.</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature_6","title":"Signature","text":"<pre><code>class PMStoPDFConversionStrategy(ConversionStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#see-also_2","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"Source-Code/particula/util/size_distribution_convert/#pmstopdfconversionstrategyconvert","title":"PMStoPDFConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:76</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature_7","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#samescaleconversionstrategy","title":"SameScaleConversionStrategy","text":"<p>Show source in size_distribution_convert.py:52</p> <p>Implements conversion between the same scales, which is a no-op.</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature_8","title":"Signature","text":"<pre><code>class SameScaleConversionStrategy(ConversionStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#see-also_3","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"Source-Code/particula/util/size_distribution_convert/#samescaleconversionstrategyconvert","title":"SameScaleConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:55</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature_9","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#sizerconverter","title":"SizerConverter","text":"<p>Show source in size_distribution_convert.py:102</p> <p>A converter that uses a specified ConversionStrategy to convert particle size distribution data between different formats.</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature_10","title":"Signature","text":"<pre><code>class SizerConverter:\n    def __init__(self, strategy: ConversionStrategy): ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#see-also_4","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"Source-Code/particula/util/size_distribution_convert/#sizerconverterconvert","title":"SizerConverter().convert","text":"<p>Show source in size_distribution_convert.py:114</p> <p>Converts particle size distribution data using the specified strategy.</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#arguments_1","title":"Arguments","text":"<ul> <li><code>diameters</code> np.ndarray - The particle diameters.</li> <li><code>concentration</code> np.ndarray - The concentration values.</li> <li><code>inverse</code> bool - Flag to perform the inverse conversion.</li> </ul>"},{"location":"Source-Code/particula/util/size_distribution_convert/#returns_1","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - The converted concentration values.</li> </ul>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature_11","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#get_conversion_strategy","title":"get_conversion_strategy","text":"<p>Show source in size_distribution_convert.py:130</p> <p>Factory function to create and return an appropriate conversion strategy based on input and output scales. Use the inverse flag in the converter to invert the directions of the input and output scales.</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#arguments_2","title":"Arguments","text":"<ul> <li><code>input_scale</code> str - The scale of the input concentration values.     Either 'dn/dlogdp' or 'pms'.</li> <li><code>output_scale</code> str - The desired scale of the output concentration values. Either 'pms' or 'pdf'. Use inverse flag to invert the input and output scales.</li> </ul>"},{"location":"Source-Code/particula/util/size_distribution_convert/#returns_2","title":"Returns","text":"<ul> <li>ConversionStrategy - A strategy object capable of converting between the specified scales.</li> </ul>"},{"location":"Source-Code/particula/util/size_distribution_convert/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the input_scale or output_scale is not supported, or if the specified conversion is unsupported.</li> </ul> <p>Example usage:     strategy = get_conversion_strategy('dn/dlogdp', 'pms')     converter = Converter(strategy)     converted_concentration = converter.convert(         diameters, concentration, inverse=False)</p>"},{"location":"Source-Code/particula/util/size_distribution_convert/#signature_12","title":"Signature","text":"<pre><code>def get_conversion_strategy(\n    input_scale: str, output_scale: str\n) -&gt; ConversionStrategy: ...\n</code></pre>"},{"location":"Source-Code/particula/util/size_distribution_convert/#see-also_5","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"Source-Code/particula/util/slip_correction/","title":"Slip Correction","text":"<p>Particula Index / Particula / Util / Slip Correction</p> <p>Auto-generated documentation for particula.util.slip_correction module.</p>"},{"location":"Source-Code/particula/util/slip_correction/#scf","title":"scf","text":"<p>Show source in slip_correction.py:9</p> <p>Returns particle's Cunningham slip correction factor.</p> <p>Dimensionless quantity accounting for non-continuum effects on small particles. It is a deviation from Stokes' Law. Stokes assumes a no-slip condition that is not correct at high Knudsen numbers. The slip correction factor is used to calculate the friction factor.</p> <p>Thus, the slip correction factor is about unity (1) for larger particles (Kn -&gt; 0). Its behavior on the other end of the spectrum (smaller particles; Kn -&gt; inf) is more nuanced, though it tends to scale linearly on a log-log scale, log Cc vs log Kn.</p>"},{"location":"Source-Code/particula/util/slip_correction/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.slip_correction import scf\n&gt;&gt;&gt; # with radius 1e-9 m\n&gt;&gt;&gt; scf(radius=1e-9)\n&lt;Quantity(110.720731, 'dimensionless')&gt;\n&gt;&gt;&gt; # with radius 1e-9 m and knu=1\n&gt;&gt;&gt; scf(radius=1e-9*u.m, knu=1)\n&lt;Quantity(2.39014843, 'dimensionless')&gt;\n&gt;&gt;&gt; # using knu(**kwargs)\n&gt;&gt;&gt; scf(radius=1e-9*u.m, mfp=60*u.nm)\n&lt;Quantity(99.9840088, 'dimensionless')&gt;\n&gt;&gt;&gt; # using mfp(**kwargs)\n&gt;&gt;&gt; scf(\n... radius=1e-9*u.m,\n... temperature=300,\n... pressure=1e5,\n... molecular_weight=0.03\n... )\n&lt;Quantity(111.101591, 'dimensionless')&gt;\n</code></pre>"},{"location":"Source-Code/particula/util/slip_correction/#arguments","title":"Arguments","text":"<p>radius  (float) [m] knu     (float) [ ] (default: util)</p>"},{"location":"Source-Code/particula/util/slip_correction/#returns","title":"Returns","text":"<p>(float) [dimensionless]</p>"},{"location":"Source-Code/particula/util/slip_correction/#notes","title":"Notes","text":"<p>knu can be calculated using knu(**kwargs); refer to particula.util.knudsen_number.knu for more info.</p>"},{"location":"Source-Code/particula/util/slip_correction/#signature","title":"Signature","text":"<pre><code>def scf(radius=None, knu=None, **kwargs): ...\n</code></pre>"},{"location":"Source-Code/particula/util/species_properties/","title":"Species Properties","text":"<p>Particula Index / Particula / Util / Species Properties</p> <p>Auto-generated documentation for particula.util.species_properties module.</p>"},{"location":"Source-Code/particula/util/species_properties/#attributes","title":"Attributes","text":"<ul> <li><code>species_properties</code> - maybe this should be loaded from a file, or for an option of the user to   add their own species or load files with species properties: {'generic': {'molecular_weight': 200.0 * u.g / u.mol, 'surface_tension': 0.072 * u.N / u.m, 'density': 1000.0 * u.kg / u.m ** 3, 'vapor_radius': 1e-14 * u.Pa, 'vapor_attachment': 1.0 * u.dimensionless, 'saturation_pressure': 1.0 * u.Pa, 'latent_heat': 1.0 * u.J / u.g, 'heat_vaporization': 1.0 * u.J / u.kg, 'kappa': 0.2 * u.dimensionless}, 'water': {'molecular_weight': 18.01528 * u.g / u.mol, 'surface_tension': 0.072 * u.N / u.m, 'density': 1000.0 * u.kg / u.m ** 3, 'vapor_radius': 1.6e-09 * u.m, 'vapor_attachment': 1.0 * u.dimensionless, 'saturation_pressure': water_buck_psat, 'latent_heat': lambda T,: 2500.8 - 2.36 * T.m_as('degC') + 0.0016 * T.m_as('degC') ** 2 - 6e-05 * T.m_as('degC') ** 3 * u.J / u.g, 'heat_vaporization': 2257000.0 * u.J / u.kg, 'kappa': 0.2 * u.dimensionless}, 'ammonium sulfate': {'molecular_weight': 132.14 * u.g / u.mol, 'surface_tension': 0.072 * u.N / u.m, 'density': 1770.0 * u.kg / u.m ** 3, 'vapor_radius': 1.6e-09 * u.m, 'vapor_attachment': 1.0 * u.dimensionless, 'saturation_pressure': 1e-14 * u.Pa, 'latent_heat': 0.0 * u.J / u.g, 'heat_vaporization': 0.0 * u.J / u.kg, 'kappa': 0.53 * u.dimensionless}}</li> </ul>"},{"location":"Source-Code/particula/util/species_properties/#materialproperties","title":"MaterialProperties","text":"<p>Show source in species_properties.py:17</p>"},{"location":"Source-Code/particula/util/species_properties/#signature","title":"Signature","text":"<pre><code>class MaterialProperties:\n    def __init__(self, species_properties): ...\n</code></pre>"},{"location":"Source-Code/particula/util/species_properties/#materialpropertieslatent_heat","title":"MaterialProperties().latent_heat","text":"<p>Show source in species_properties.py:34</p>"},{"location":"Source-Code/particula/util/species_properties/#signature_1","title":"Signature","text":"<pre><code>def latent_heat(self, temperature, species): ...\n</code></pre>"},{"location":"Source-Code/particula/util/species_properties/#materialpropertiessaturation_pressure","title":"MaterialProperties().saturation_pressure","text":"<p>Show source in species_properties.py:24</p>"},{"location":"Source-Code/particula/util/species_properties/#signature_2","title":"Signature","text":"<pre><code>def saturation_pressure(self, temperature, species): ...\n</code></pre>"},{"location":"Source-Code/particula/util/species_properties/#clausius_clapeyron","title":"clausius_clapeyron","text":"<p>Show source in species_properties.py:63</p> <p>Calculates the vapor pressure of a substance at a given temperature using the Clausius-Clapeyron equation.</p>"},{"location":"Source-Code/particula/util/species_properties/#args","title":"Args","text":"<pre><code>temperature (float): Temperature reference in Kelvin\nvapor_pressure (float): Vapor pressure reference in Pa\ntemperature_new (float): Temperature new in Kelvin\nheat_vaporization (float): Heat of vaporization in J/kg\n</code></pre>"},{"location":"Source-Code/particula/util/species_properties/#returns","title":"Returns","text":"<pre><code>vapor_pressure_new: Vapor pressure in Pa\n</code></pre>"},{"location":"Source-Code/particula/util/species_properties/#signature_3","title":"Signature","text":"<pre><code>def clausius_clapeyron(\n    temperature, vapor_pressure, temperature_new, heat_vaporization\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/species_properties/#material_properties","title":"material_properties","text":"<p>Show source in species_properties.py:140</p> <p>Return the material properties for a given species.</p>"},{"location":"Source-Code/particula/util/species_properties/#args_1","title":"Args","text":"<p>property : str     Property to return. Options are: 'all', 'molecular_weight',     'surface_tension', 'density', 'vapor_radius', 'vapor_attachment',     'kappa'. species : str     Species for which to return the material properties. temperature : K     Temperature of the material.</p>"},{"location":"Source-Code/particula/util/species_properties/#returns_1","title":"Returns","text":"<p>material_properties : value     The material property for the given species.</p>"},{"location":"Source-Code/particula/util/species_properties/#signature_4","title":"Signature","text":"<pre><code>def material_properties(property, species=\"water\", temperature=298.15 * u.K): ...\n</code></pre>"},{"location":"Source-Code/particula/util/species_properties/#vapor_concentration","title":"vapor_concentration","text":"<p>Show source in species_properties.py:177</p> <p>Convert saturation ratio to mass concentration at a given temperature.</p>"},{"location":"Source-Code/particula/util/species_properties/#args_2","title":"Args","text":"<p>sat_ratio : float     saturation ratio. temperature : K     Air temperature. species : str, optional     Species for which to calculate the saturation vapor pressure.     Default is \"water\".</p>"},{"location":"Source-Code/particula/util/species_properties/#returns_2","title":"Returns","text":"<p>concentration : concentration units     Concentration vapor.</p> <p>TODO: check values for different species</p>"},{"location":"Source-Code/particula/util/species_properties/#signature_5","title":"Signature","text":"<pre><code>def vapor_concentration(saturation_ratio, temperature=298.15 * u.K, species=\"water\"): ...\n</code></pre>"},{"location":"Source-Code/particula/util/species_properties/#water_buck_psat","title":"water_buck_psat","text":"<p>Show source in species_properties.py:47</p> <p>Buck equation for water vapor pressure https://en.wikipedia.org/wiki/Arden_Buck_equation</p>"},{"location":"Source-Code/particula/util/species_properties/#signature_6","title":"Signature","text":"<pre><code>def water_buck_psat(temperature): ...\n</code></pre>"},{"location":"Source-Code/particula/util/stats/","title":"Stats","text":"<p>Particula Index / Particula / Util / Stats</p> <p>Auto-generated documentation for particula.util.stats module.</p>"},{"location":"Source-Code/particula/util/stats/#average_to_interval","title":"average_to_interval","text":"<p>Show source in stats.py:114</p> <p>Calculate the average of the data stream over the specified time intervals.</p> <p>This function calculates the average of the data stream over a series of time intervals specified by <code>average_interval_array</code>. The average and standard deviation of the data are calculated for each interval, and the results are returned as two arrays.</p>"},{"location":"Source-Code/particula/util/stats/#arguments","title":"Arguments","text":"<pre><code>- `time_raw` *np.ndarray* - An array of timestamps, sorted in ascending\n    order.\n- `average_interval` *float* - The length of each time interval in seconds.\n- `average_interval_array` *np.ndarray* - An array of timestamps\n    representing\n    the start times of each time interval.\n- `data_raw` *np.ndarray* - An array of data points corresponding to the\n    timestamps in `time_raw`.\n- `average_data` *np.ndarray* - An empty array of shape\n    (num_channels, num_intervals)that will be filled with the\n    average data for each time interval.\n- `average_data_std` *np.ndarray* - An empty array of shape\n    (num_channels, num_intervals) that will be filled with the standard\n    deviation of the data for each time interval.\n</code></pre>"},{"location":"Source-Code/particula/util/stats/#returns","title":"Returns","text":"<pre><code>- `Tuple[np.ndarray,` *np.ndarray]* - A tuple containing the average data\n    and the standard deviation of the data, both as arrays of shape\n    (num_channels, num_intervals).\n</code></pre>"},{"location":"Source-Code/particula/util/stats/#signature","title":"Signature","text":"<pre><code>def average_to_interval(\n    time_raw: np.ndarray,\n    data_raw: np.ndarray,\n    average_interval: float,\n    average_interval_array: np.ndarray,\n    average_data: np.ndarray,\n    average_data_std: np.ndarray,\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/stats/#distribution_integration","title":"distribution_integration","text":"<p>Show source in stats.py:291</p> <p>Performs either PDF integration or PMS integration based on the input. This function supports broadcasting where x_array has shape (m,) and distribution has shape (n, m).</p>"},{"location":"Source-Code/particula/util/stats/#arguments_1","title":"Arguments","text":"<pre><code>- `distribution` - The distribution array to integrate.\n    It should have a shape of (n, m).\n- `x_array` - The x-values array for PDF\n    integration. It should have a shape of (m,).\n    If None, PMS integration is performed. Defaults to None.\n- `axis` - The axis along which to perform the integration\n    for PDF or the sum for PMS.\n    Defaults to 0.\n</code></pre>"},{"location":"Source-Code/particula/util/stats/#returns_1","title":"Returns","text":"<pre><code>- `np.ndarray` - The result of the integration. If PDF integration is\nperformed, the result will have a shape of (n,) if axis=0 or (m,)\nif axis=1. If PMS integration is performed, the result will be a\nsingle value if axis=None, or an array with reduced dimensionality\notherwise.\n</code></pre>"},{"location":"Source-Code/particula/util/stats/#signature_1","title":"Signature","text":"<pre><code>def distribution_integration(\n    distribution: np.ndarray, x_array: Optional[np.ndarray] = None, axis: int = 0\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/stats/#mask_outliers","title":"mask_outliers","text":"<p>Show source in stats.py:238</p> <p>Create a boolean mask for outliers in a data array. Outliers are defined as values that are either above or below a specified threshold, or that are equal to a specified value. Not all parameters need to be specified. If <code>invert</code> is True, the mask will be inverted. The mask will be True for False for outliers and True for non-outliers.</p>"},{"location":"Source-Code/particula/util/stats/#arguments_2","title":"Arguments","text":"<pre><code>- `data` *np.ndarray* - The data array to be masked.\n- `bottom` *float* - The lower threshold for outliers.\n- `top` *float* - The upper threshold for outliers.\n- `value` *float* - The value to be masked.\n- `invert` *bool* - If True, the mask will be inverted.\n</code></pre>"},{"location":"Source-Code/particula/util/stats/#returns_2","title":"Returns","text":"<pre><code>- `np.ndarray` - A boolean mask for the outliers in the data array. Mask is\n    True for non-outliers and False for outliers, and the same shape as\n    the data array.\n</code></pre>"},{"location":"Source-Code/particula/util/stats/#signature_2","title":"Signature","text":"<pre><code>def mask_outliers(\n    data: np.ndarray,\n    bottom: Optional[float] = None,\n    top: Optional[float] = None,\n    value: Optional[float] = None,\n    invert: Optional[bool] = False,\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/stats/#merge_formatting","title":"merge_formatting","text":"<p>Show source in stats.py:9</p> <p>Formats two data arrays and their headers so that the data new can be subsiqently added to data current.</p>"},{"location":"Source-Code/particula/util/stats/#arguments_3","title":"Arguments","text":"<ul> <li><code>data_current</code> np.ndarray - First data array to merge.</li> <li><code>header_current</code> list - Header for the first data array.</li> <li><code>data_new</code> np.ndarray - Second data array to merge.</li> <li><code>header_new</code> list - Header for the second data array.</li> </ul>"},{"location":"Source-Code/particula/util/stats/#returns_3","title":"Returns","text":"<p>(np.ndarray, list, np.array, list): A tuple formatted data and headers.</p>"},{"location":"Source-Code/particula/util/stats/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the data arrays are not the same shape.</li> <li><code>ValueError</code> - If the headers are not the same length.</li> </ul>"},{"location":"Source-Code/particula/util/stats/#signature_3","title":"Signature","text":"<pre><code>def merge_formatting(\n    data_current: np.ndarray,\n    header_current: list,\n    data_new: np.ndarray,\n    header_new: list,\n) -&gt; Tuple[np.ndarray, list, np.ndarray, list]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/surface_tension/","title":"Surface Tension","text":"<p>Particula Index / Particula / Util / Surface Tension</p> <p>Auto-generated documentation for particula.util.surface_tension module.</p>"},{"location":"Source-Code/particula/util/surface_tension/#dry_mixing","title":"dry_mixing","text":"<p>Show source in surface_tension.py:38</p> <p>Function to calculate the effective surface tension of a dry mixture.</p>"},{"location":"Source-Code/particula/util/surface_tension/#arguments","title":"Arguments","text":"<ul> <li>volume_fractions : array, volume fractions of solutes</li> <li>surface_tensions : array, surface tensions of solutes</li> </ul>"},{"location":"Source-Code/particula/util/surface_tension/#returns","title":"Returns","text":"<ul> <li>sigma : array, surface tension of droplet</li> </ul>"},{"location":"Source-Code/particula/util/surface_tension/#signature","title":"Signature","text":"<pre><code>def dry_mixing(volume_fractions, surface_tensions): ...\n</code></pre>"},{"location":"Source-Code/particula/util/surface_tension/#water","title":"water","text":"<p>Show source in surface_tension.py:9</p> <p>Calculate the surface tension of water using the equation from Kalova and Mares (2018).</p>"},{"location":"Source-Code/particula/util/surface_tension/#arguments_1","title":"Arguments","text":"<ul> <li>Temperature : float, Ambient temperature of air</li> <li>CritTemp : float, optional: Critical temperature of water</li> </ul>"},{"location":"Source-Code/particula/util/surface_tension/#returns_1","title":"Returns","text":"<ul> <li>sigma : float, Surface tension of water at the given temperature</li> </ul>"},{"location":"Source-Code/particula/util/surface_tension/#signature_1","title":"Signature","text":"<pre><code>def water(temperature, critical_temperature=647.15): ...\n</code></pre>"},{"location":"Source-Code/particula/util/surface_tension/#wet_mixing","title":"wet_mixing","text":"<p>Show source in surface_tension.py:59</p> <p>Function to calculate the effective surface tension of a wet mixture.</p>"},{"location":"Source-Code/particula/util/surface_tension/#arguments_2","title":"Arguments","text":"<ul> <li>volume_solute : array, volume of solute mixture</li> <li>volume_water : array, volume of water</li> <li>surface_tension_solute : array, surface tension of solute mixture</li> <li>temperature : float, temperature of droplet</li> <li>method : str, optional: [film, volume] method to calculate effective     surface tension</li> </ul>"},{"location":"Source-Code/particula/util/surface_tension/#returns_2","title":"Returns","text":"<ul> <li>EffSigma : array, effective surface tension of droplet</li> </ul>"},{"location":"Source-Code/particula/util/surface_tension/#signature_2","title":"Signature","text":"<pre><code>def wet_mixing(\n    volume_solute,\n    volume_water,\n    wet_radius,\n    surface_tension_solute,\n    temperature,\n    method=\"film\",\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/time_manage/","title":"Time Manage","text":"<p>Particula Index / Particula / Util / Time Manage</p> <p>Auto-generated documentation for particula.util.time_manage module.</p>"},{"location":"Source-Code/particula/util/time_manage/#datetime64_from_epoch_array","title":"datetime64_from_epoch_array","text":"<p>Show source in time_manage.py:56</p> <p>Converts an array of epoch times to a numpy array of datetime64 objects.</p>"},{"location":"Source-Code/particula/util/time_manage/#arguments","title":"Arguments","text":"<pre><code>- `epoch_array` *np.ndarray* - Array of epoch times (in seconds since\n    the Unix epoch).\n- `delta` *int* - An optional offset (in seconds) to add to the epoch times\n    before converting to datetime64 objects.\n</code></pre>"},{"location":"Source-Code/particula/util/time_manage/#returns","title":"Returns","text":"<pre><code>- `np.ndarray` - Array of datetime64 objects corresponding to the input\n    epoch times.\n</code></pre>"},{"location":"Source-Code/particula/util/time_manage/#signature","title":"Signature","text":"<pre><code>def datetime64_from_epoch_array(\n    epoch_array: np.ndarray, delta: int = 0\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/time_manage/#relative_time","title":"relative_time","text":"<p>Show source in time_manage.py:84</p> <p>Cacluates the relative time from the start of the epoch array in the specified units.</p>"},{"location":"Source-Code/particula/util/time_manage/#arguments_1","title":"Arguments","text":"<ul> <li><code>-epoch_array</code> np.ndarray - Array of epoch times (in seconds since     the Unix epoch).</li> <li><code>-units</code> str - The units of the relative time. Default is hours.</li> </ul>"},{"location":"Source-Code/particula/util/time_manage/#returns_1","title":"Returns","text":"<ul> <li><code>-np.ndarray</code> - Array of relative times in the specified units.</li> </ul>"},{"location":"Source-Code/particula/util/time_manage/#signature_1","title":"Signature","text":"<pre><code>def relative_time(epoch_array: np.ndarray, units: str = \"hours\") -&gt; np.ndarray: ...\n</code></pre>"},{"location":"Source-Code/particula/util/time_manage/#time_str_to_epoch","title":"time_str_to_epoch","text":"<p>Show source in time_manage.py:9</p> <p>Convert to UTC (epoch) timezone from all inputs. Using pytz library, which implements the Olson time zone database. tz identifiers are strings from the database. See https://en.wikipedia.org/wiki/List_of_tz_database_time_zones for a list of time zones.</p>"},{"location":"Source-Code/particula/util/time_manage/#arguments_2","title":"Arguments","text":"<p>time : float (single value no arrays)     Epoch time in seconds. time_format : str     The format of the time string. See     https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes     for a list of format codes. timezone_identifier : str     The time zone identifier for the current time zone.</p>"},{"location":"Source-Code/particula/util/time_manage/#returns_2","title":"Returns","text":"<p>new_time : float     The float time in the new time zone.</p> <ul> <li><code>Example</code> - Date Time Format Codes</li> <li>'2019-01-01 00:00:00' is '%Y-%m-%d %H:%M:%S'</li> <li>'10/01/2019 00:00:00' is '%d/%m/%Y %H:%M:%S'</li> <li>'2019-01-01 00:00:00.000000' is '%Y-%m-%d %H:%M:%S.%f'</li> <li>'5/1/2019 1:00:00 PM' is '%m/%d/%Y %I:%M:%S %p'</li> <li><code>-</code> %Y - Year with century as a decimal number.</li> <li><code>-</code> %m - Month as a zero-padded decimal number.</li> <li><code>-</code> %d - Day of the month as a zero-padded decimal number.</li> <li><code>-</code> %H - Hour (24-hour clock) as a zero-padded decimal number.</li> <li><code>-</code> %M - Minute as a zero-padded decimal number.</li> <li><code>-</code> %S - Second as a zero-padded decimal number.</li> <li><code>-</code> %f - Microsecond as a decimal number, zero-padded on the left.</li> <li><code>-</code> %p - Locales equivalent of either AM or PM.</li> </ul>"},{"location":"Source-Code/particula/util/time_manage/#_1","title":"Time Manage","text":""},{"location":"Source-Code/particula/util/time_manage/#signature_2","title":"Signature","text":"<pre><code>def time_str_to_epoch(\n    time: str, time_format: str, timezone_identifier: str = \"UTC\"\n) -&gt; float: ...\n</code></pre>"},{"location":"Source-Code/particula/util/vapor_flux/","title":"Vapor Flux","text":"<p>Particula Index / Particula / Util / Vapor Flux</p> <p>Auto-generated documentation for particula.util.vapor_flux module.</p>"},{"location":"Source-Code/particula/util/vapor_flux/#phi","title":"phi","text":"<p>Show source in vapor_flux.py:14</p> <p>vapor flux</p>"},{"location":"Source-Code/particula/util/vapor_flux/#signature","title":"Signature","text":"<pre><code>def phi(\n    particle_area=None,\n    molecular_enhancement=None,\n    vapor_attachment=1,\n    vapor_speed=None,\n    driving_force=1,\n    fsc=None,\n    **kwargs\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/wall_loss/","title":"Wall Loss","text":"<p>Particula Index / Particula / Util / Wall Loss</p> <p>Auto-generated documentation for particula.util.wall_loss module.</p>"},{"location":"Source-Code/particula/util/wall_loss/#rectangle_wall_loss","title":"rectangle_wall_loss","text":"<p>Show source in wall_loss.py:39</p> <p>Calculate the wall loss coefficient, \u03b2\u2080, for a rectangular chamber.</p> <p>Given the rate of wall diffusivity parameter (ktp_value), the particle diffusion coefficient (diffusion_coefficient_value), and the terminal settling velocity (settling_velocity_value), this function computes the wall loss coefficient for a rectangular-prism chamber with specified dimensions.</p> <p>The wall loss coefficient is calculated based on the diffusion and gravitational sedimentation in a rectangular chamber. It accounts for the effect of chamber geometry on particle loss by considering the length (L), width (W), and height (H) of the chamber.</p>"},{"location":"Source-Code/particula/util/wall_loss/#arguments","title":"Arguments","text":"<ul> <li><code>ktp_value</code> float - Rate of wall diffusivity parameter in units of     inverse seconds (s^-1).</li> <li><code>diffusion_coefficient_value</code> float - The particle diffusion     coefficient in units of square meters per second (m^2/s).</li> <li><code>settling_velocity_value</code> float - The terminal settling velocity of the     particles, in units of meters per second (m/s).</li> <li><code>dimension</code> tuple - A tuple of three floats representing the length (L)     width (W), and height (H) of the rectangular chamber,     in units of meters (m).</li> </ul>"},{"location":"Source-Code/particula/util/wall_loss/#returns","title":"Returns","text":"<ul> <li><code>float</code> - The calculated wall loss coefficient (B0) for the rectangular chamber.</li> </ul> <p>Reference:     The wall loss coefficient, \u03b2\u2080, is calculated using the following     formula:     $$     \beta_0 = (LWH)^{-1} (4H(L+W) \\sqrt{k_t D}/\\pi +     v_g LW \\coth{[(\\pi v_g)/(4\\sqrt{k_t D}})])     $$</p>"},{"location":"Source-Code/particula/util/wall_loss/#signature","title":"Signature","text":"<pre><code>def rectangle_wall_loss(\n    ktp_value, diffusion_coefficient_value, settling_velocity_value, dimension\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/wall_loss/#spherical_wall_loss_coefficient","title":"spherical_wall_loss_coefficient","text":"<p>Show source in wall_loss.py:12</p> <p>Calculate the wall loss coefficient for a spherical chamber approximation.</p>"},{"location":"Source-Code/particula/util/wall_loss/#arguments_1","title":"Arguments","text":"<ul> <li><code>ktp_value</code> - rate of the wall eddy diffusivity</li> <li><code>diffusion_coefficient_value</code> - Particle diffusion coefficient.</li> <li><code>settling_velocity_value</code> - Settling velocity of the particle.</li> <li><code>chamber_radius</code> - Radius of the chamber.</li> </ul>"},{"location":"Source-Code/particula/util/wall_loss/#returns_1","title":"Returns","text":"<p>The calculated wall loss coefficient for simple case.</p>"},{"location":"Source-Code/particula/util/wall_loss/#signature_1","title":"Signature","text":"<pre><code>def spherical_wall_loss_coefficient(\n    ktp_value, diffusion_coefficient_value, settling_velocity_value, chamber_radius\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/wall_loss/#wlc","title":"wlc","text":"<p>Show source in wall_loss.py:94</p> <p>Calculate the wall loss coefficient.</p>"},{"location":"Source-Code/particula/util/wall_loss/#arguments_2","title":"Arguments","text":"<ul> <li><code>approximation</code> - The approximation method to use, e.g., \"none\", \"spherical\", \"rectangle\"</li> <li><code>ktp_value</code> - rate of the wall eddy diffusivity</li> <li><code>diffusion_coefficient_value</code> - Particle diffusion coefficient.</li> <li><code>settling_velocity_value</code> - Settling velocity of the particle.</li> <li><code>dimension</code> - Radius of the chamber or tuple of rectangular dimensions.</li> </ul>"},{"location":"Source-Code/particula/util/wall_loss/#returns_2","title":"Returns","text":"<p>The calculated wall loss coefficient.</p>"},{"location":"Source-Code/particula/util/wall_loss/#signature_2","title":"Signature","text":"<pre><code>def wlc(\n    approx=\"none\",\n    ktp_value=0.1 * u.s**-1,\n    diffusion_coefficient_value=None,\n    dimension=1 * u.m,\n    settling_velocity_value=None,\n    **kwargs\n): ...\n</code></pre>"},{"location":"Source-Code/particula/util/converting/","title":"Converting","text":"<p>Particula Index / Particula / Util / Converting</p> <p>Auto-generated documentation for particula.util.converting module.</p>"},{"location":"Source-Code/particula/util/converting/#modules","title":"Modules","text":"<ul> <li>Mass Concentration</li> </ul>"},{"location":"Source-Code/particula/util/converting/mass_concentration/","title":"Mass Concentration","text":"<p>Particula Index / Particula / Util / Converting / Mass Concentration</p> <p>Auto-generated documentation for particula.util.converting.mass_concentration module.</p>"},{"location":"Source-Code/particula/util/converting/mass_concentration/#to_mole_fraction","title":"to_mole_fraction","text":"<p>Show source in mass_concentration.py:7</p> <p>Convert mass concentrations to mole fractions for N components.</p>"},{"location":"Source-Code/particula/util/converting/mass_concentration/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> mass_concentrations - A list or ndarray of mass concentrations (SI, kg/m^3).</li> <li><code>-</code> molar_masses - A list or ndarray of molecular weights (SI, kg/mol).</li> </ul>"},{"location":"Source-Code/particula/util/converting/mass_concentration/#returns","title":"Returns","text":"<ul> <li>An ndarray of mole fractions.</li> </ul>"},{"location":"Source-Code/particula/util/converting/mass_concentration/#reference","title":"Reference:","text":"<p>The mole fraction of a component is given by the ratio of its molar concentration to the total molar concentration of all components. - https://en.wikipedia.org/wiki/Mole_fraction</p>"},{"location":"Source-Code/particula/util/converting/mass_concentration/#signature","title":"Signature","text":"<pre><code>def to_mole_fraction(\n    mass_concentrations: NDArray[np.float_], molar_masses: NDArray[np.float_]\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/converting/mass_concentration/#to_volume_fraction","title":"to_volume_fraction","text":"<p>Show source in mass_concentration.py:41</p> <p>Convert mass concentrations to volume fractions for N components.</p>"},{"location":"Source-Code/particula/util/converting/mass_concentration/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> mass_concentrations - A list or ndarray of mass concentrations (SI, kg/m^3).</li> <li><code>-</code> densities - A list or ndarray of densities of each component (SI, kg/m^3).</li> </ul>"},{"location":"Source-Code/particula/util/converting/mass_concentration/#returns_1","title":"Returns","text":"<ul> <li>An ndarray of volume fractions.</li> </ul>"},{"location":"Source-Code/particula/util/converting/mass_concentration/#reference_1","title":"Reference:","text":"<p>The volume fraction of a component is calculated by dividing the volume of that component (derived from mass concentration and density) by the total volume of all components. - https://en.wikipedia.org/wiki/Volume_fraction</p>"},{"location":"Source-Code/particula/util/converting/mass_concentration/#signature_1","title":"Signature","text":"<pre><code>def to_volume_fraction(\n    mass_concentrations: NDArray[np.float_], densities: NDArray[np.float_]\n) -&gt; NDArray[np.float_]: ...\n</code></pre>"},{"location":"Source-Code/particula/util/lf2013_coagulation/","title":"Lf2013 Coagulation","text":"<p>Particula Index / Particula / Util / Lf2013 Coagulation</p> <p>Auto-generated documentation for particula.util.lf2013_coagulation module.</p>"},{"location":"Source-Code/particula/util/lf2013_coagulation/#modules","title":"Modules","text":"<ul> <li>Src Lf2013 Coagulation</li> </ul>"},{"location":"Source-Code/particula/util/lf2013_coagulation/src_lf2013_coagulation/","title":"Src Lf2013 Coagulation","text":"<p>Particula Index / Particula / Util / Lf2013 Coagulation / Src Lf2013 Coagulation</p> <p>Auto-generated documentation for particula.util.lf2013_coagulation.src_lf2013_coagulation module.</p>"},{"location":"Source-Code/particula/util/lf2013_coagulation/src_lf2013_coagulation/#lf2013_coag_full","title":"lf2013_coag_full","text":"<p>Show source in src_lf2013_coagulation.py:13</p> <p>calculate ion--particle coagulation according to lf2013</p>"},{"location":"Source-Code/particula/util/lf2013_coagulation/src_lf2013_coagulation/#signature","title":"Signature","text":"<pre><code>def lf2013_coag_full(\n    ion_type=\"air\",\n    particle_type=\"conductive\",\n    temperature_val=298.15,\n    pressure_val=101325,\n    charge_vals=None,\n    radius_vals=None,\n): ...\n</code></pre>"},{"location":"contribute/CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"contribute/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"contribute/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at . All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"contribute/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contribute/CONTRIBUTING/","title":"Contributor Guidelines","text":"<p>First of all, thank you for considering contributing to this project! While we have specific guidelines below, we also encourage you to contribute to the best of your ability and not let these guidelines hinder your productivity and creativity. We are open to any contribution, and we are always looking for new ways to improve the project. We are also open to any feedback, however small or large, and in any area (from documentation to calculation to presentation).</p> <p>The cycle of contribution goes something like this:</p> <ol> <li> <p>See if there is an issue open that you can help with. If there is not one, please open one.</p> </li> <li> <p>Create a personal fork of this repository; and in it, create a branch (from <code>uncscode:main</code>) with the <code>issue000</code> in the name of the branch (e.g. <code>username/issue000</code> or <code>issue000</code>), where <code>000</code> is the number of the issue from step 1.</p> </li> <li> <p>Set up an appropriate environment:</p> <ul> <li>an easy option is just to use the <code>.devcontainer</code> in root</li> <li>another option is to either <code>pip install</code> or <code>conda install</code> the packages required for development in <code>requirements.txt</code> in root.</li> </ul> </li> <li> <p>Write your code in the branch. This usually includes the following.</p> <p>a. Code to be implemented.</p> <p>b. Documentation associated with added code in a.</p> <p>c. Tests associated with added code in a.</p> <p>d. Ideally, you'd also add a Jupyter notebook to showcase your work (if applicable).</p> </li> <li> <p>Optionally, you can run standard linting and testing calls on your code locally to make sure it works as expected. This can be done in several ways, for example the <code>pylint</code>, <code>flake8</code>, and <code>pytest</code> calls below. These calls will be run once you submit your pull request.</p> </li> <li> <p>Submit a pull request to the <code>main</code> branch of this repository. Upon submission, standard automated tests will be run on your code.</p> </li> <li> <p>If you don't hear back from maintainers, feel free to mention one of us directly in the comments of the PR. Expect to have speedy feedback and help from us to finalize the PR.</p> </li> </ol> <pre><code>pylint $(find particula/ -name \"*.py\" | xargs)\n</code></pre> <pre><code>flake8 particula/ --count\n</code></pre> <pre><code>pytest particula/\n</code></pre> <p>More information about contributing to this project can be found below. We are excited and looking forward to your contribution!</p>"},{"location":"contribute/CONTRIBUTING/#github","title":"GitHub","text":"<p>We use GitHub to develop <code>particula</code> completely in the open. Our repository is available here: https://uncscode.github.io/particula/. There are several ways to use GitHub: through the command line via <code>git</code> and/or <code>gh</code>, through the web interface and/or the GitHub web editor, or through an IDE like PyCharm or a code editor like Visual Studio Code. In general, we recommend that you fork our repository, that you work with VS Code, and that submit a pull request based on an issue. If any of these sound unfamiliar or if you need help, please see more information below and feel free to contact us directly to discuss options. We look forward to getting you started and up to speed on this project with us!</p> <p>Links: https://docs.github.com/en/get-started</p>"},{"location":"contribute/CONTRIBUTING/#vs-code","title":"VS Code","text":"<p>Visual Studio Code is a free and open-source code editor for writing code and it has a rich ecosystem of extensions that allow you to write code in a variety of languages with a lot of helpful features and tools.</p> <p>Links: https://code.visualstudio.com/</p>"},{"location":"contribute/CONTRIBUTING/#devcontainer","title":"<code>.devcontainer</code>","text":"<p>In the root of our repository, we have a <code>.devcontainer</code> folder that contains the environment variables required for development. This is a convenient way to set up the environment for development. It requires Docker to be installed and running. And the first time it runs it may take a few minutes to install the Docker image (a minimal operating system with Python 3.9).</p> <p>Links: https://code.visualstudio.com/docs/remote/containers</p>"},{"location":"contribute/CONTRIBUTING/#python-code-style","title":"Python code style","text":"<p>We follow the Google's Python style guide. We encourage you to follow it too, but we also encourage you to contribute to the best of your ability and not let these guidelines hinder your productivity and creativity.</p> <p>Links: https://google.github.io/styleguide/pyguide.html</p>"},{"location":"contribute/CONTRIBUTING/#running-particula-locally","title":"Running <code>particula</code> locally","text":"<p>Once you are in the root directory, you will be able to import <code>particula</code> as a package/model and thus all documentation on website applies. You must be in the root directory.</p>"},{"location":"contribute/CONTRIBUTING/#writing-tests","title":"Writing tests","text":"<p>It is essential that every piece of code has an associated test. This is a good way to ensure that the code is working as intended. It also ensures that the code is not broken and that the code is not too complex. However small or big, a test is always required.</p>"},{"location":"contribute/CONTRIBUTING/#running-testinglinting-locally","title":"Running testing/linting locally","text":"<p>We use <code>pytest</code>, <code>pylint</code>, and <code>flake8</code> to run tests and linting. The command below can be run in the root directory like you'd run the package above.</p> <pre><code>pylint $(find particula/ -name \"*.py\" | xargs)\n</code></pre> <pre><code>flake8 particula/ --count\n</code></pre> <pre><code>pytest particula/\n</code></pre>"},{"location":"contribute/CONTRIBUTING/#building-particula-locally","title":"Building <code>particula</code> locally","text":"<p>To build <code>particula</code> locally, you must be in the root directory. You have two options, depending on your usage case.</p> <ol> <li>You can use <code>python -m build</code> to build the package wheels locally (note: you will need to install <code>build</code> too, via <code>pip install build</code>).</li> <li>You can build the conda recipe available at https://github.com/conda-forge/particula-feedstock either via <code>python build-locally.py</code> in the root of <code>particula-feedstock</code> or via <code>conda build recipe</code> (equivalently, but faster, <code>mamba build recipe</code>). For the latter, you will need to have <code>conda-build</code> installed (for <code>conda build</code> to work) or <code>boa</code> (for <code>mamba build</code> to work). In either case, you can install package with conda via, <code>conda install conda-build</code> or <code>mamba install boa</code>.</li> </ol> <p>Links: https://packaging.python.org/en/latest/tutorials/packaging-projects/ and https://docs.conda.io/projects/conda-build/en/latest/user-guide/index.html</p>"},{"location":"contribute/CONTRIBUTING/#documentation-writing","title":"Documentation writing","text":"<p>We prefer that the tutorials are written in the form of Jupyter notebooks after the package is released and published. A convenient option is using Google's Colaboratory to write the notebooks.</p> <p>Links: https://colab.research.google.com/</p>"},{"location":"contribute/CONTRIBUTING/#more-information","title":"More information","text":"<p>We will update this regularly with more information, but in the meanwhile, please feel free to contact us directly on GitHub.</p>"},{"location":"documentation/utilities/utilities_overview/","title":"Utilities Functions","text":"<p>These are common utility functions that are used in the codebase.</p>"},{"location":"examples/wall_loss_section/","title":"Chamber Wall Loss Analysis","text":"<p>In this example we'll go through the steps of combining the data analysis, and modeling capabilities of particula to analyze the wall loss in a chamber.</p>"},{"location":"examples/equilibria/equilibria_intro/","title":"Equilibria of Aerosols","text":""},{"location":"examples/equilibria/equilibria_intro/#what-is-equilibria","title":"What is Equilibria?","text":"<p>Equilibria, a fundamental concept in physical chemistry, refers to the state where the concentrations of reactants and products in a chemical reaction remain constant over time. In the context of aerosol science, equilibria are essential in understanding how aerosol particles interact with their environment, particularly with respect to liquid and vapor phases. This balance is crucial in predicting how aerosols behave under different atmospheric conditions.</p>"},{"location":"examples/equilibria/equilibria_intro/#why-is-equilibria-important","title":"Why is Equilibria Important?","text":"<p>Studying equilibria in aerosol systems is vital for several reasons:</p> <ol> <li> <p>Environmental Impact: Aerosols play a significant role in air quality and climate change. Understanding their equilibrium behavior helps in assessing their environmental impact, such as their role in cloud formation and solar radiation scattering.</p> </li> <li> <p>Health Implications: Aerosols affect human health, especially in terms of respiratory issues. Knowledge of equilibrium states helps in evaluating exposure risks and designing mitigation strategies.</p> </li> <li> <p>Atmospheric Chemistry: Equilibria studies contribute to our understanding of atmospheric chemistry, particularly in the formation and transformation of aerosols.</p> </li> </ol>"},{"location":"examples/equilibria/equilibria_intro/#how-does-equilibria-relate-to-these-notebooks","title":"How Does Equilibria Relate to These Notebooks?","text":"<p>The notebooks presented here are dedicated to exploring various aspects of equilibria in aerosol science:</p> <ol> <li> <p>Activity Coefficients and Phase Behavior: By calculating activity coefficients, we can predict how different components of aerosols partition between liquid and vapor phases. This is crucial in understanding the composition and concentration of aerosols under varying atmospheric conditions.</p> </li> <li> <p>Liquid-Vapor Equilibrium: The notebook delves into the equilibrium compositions of liquid-vapor mixtures, highlighting the role of relative humidity (RH) in shaping aerosol behavior.</p> </li> <li> <p>Practical Applications: Through examples and simulations, these notebooks provide practical insights into real-world scenarios, enhancing our understanding of aerosols in environmental and health contexts.</p> </li> </ol> <p>Overall, the notebooks serve as an interactive platform to explore and understand the complex yet fascinating world of equilibria in aerosol science. Whether you're a student, researcher, or enthusiast, these materials offer valuable insights into the dynamic equilibrium processes that govern aerosol behavior in our atmosphere.</p>"},{"location":"examples/lagrangian/lagrangian_intro/","title":"Lagrangian Particle Model","text":"<p>This example will cover the basics of the Lagrangian particle model. Starting with a simple initial condition, and then adding more complexity to the model.</p>"},{"location":"examples/light_scattering/aerosol_optics_intro/","title":"Aerosol optics intro","text":""},{"location":"examples/light_scattering/aerosol_optics_intro/#introduction-to-aerosol-optics","title":"Introduction to Aerosol Optics","text":"<p>Aerosol optics examines the interaction between light and aerosol particles suspended in the atmosphere. These interactions, encompassing absorption, scattering, and the emission of light, are pivotal in deciphering the physical properties of aerosols and their environmental ramifications.</p>"},{"location":"examples/light_scattering/aerosol_optics_intro/#mie-scattering-theory","title":"Mie Scattering Theory","text":"<p>Central to aerosol optics is Mie scattering theory, formulated by Gustav Mie in 1908. This foundational theory enables the precise calculation of light scattering and absorption by spherical particles, taking into account their size, material composition, and the incident light's wavelength. In this context, we leverage the capabilities of pyMieScatt, a comprehensive Python library designed to facilitate Mie scattering computations.</p>"},{"location":"examples/light_scattering/aerosol_optics_intro/#fundamental-concepts","title":"Fundamental Concepts","text":"<ul> <li>Scattering Efficiency: Quantifies the efficacy of particles in deflecting light in various directions.</li> <li>Absorption Efficiency: Assesses the extent to which particles absorb incident light.</li> <li>Single Scattering Albedo (SSA): This ratio of scattering to total light extinction (scattering plus absorption) provides insight into whether particles are more likely to scatter light rather than absorb it.</li> </ul>"},{"location":"examples/light_scattering/aerosol_optics_intro/#understanding-particle-distributions","title":"Understanding Particle Distributions","text":"<p>Aerosol particles exhibit a vast diversity in terms of size, shape, and chemical composition, making the study of their distributions crucial for accurate optical modeling.</p>"},{"location":"examples/light_scattering/aerosol_optics_intro/#types-of-distributions","title":"Types of Distributions","text":"<ul> <li>Monodisperse: A scenario where all particles are of identical size.</li> <li>Polydisperse: Represents a realistic distribution where particles vary in size, often characterized by statistical distribution models, such as the log-normal distribution.</li> </ul>"},{"location":"examples/light_scattering/aerosol_optics_intro/#addressing-truncation-errors-in-measurements","title":"Addressing Truncation Errors in Measurements","text":"<p>Measurements of aerosol optical properties can be compromised by truncation errors, stemming from the inability of instruments to capture the complete angular range of scattered light.</p>"},{"location":"examples/light_scattering/aerosol_optics_intro/#consequences-and-mitigation-strategies","title":"Consequences and Mitigation Strategies","text":"<ul> <li>Scattering Coefficient Underestimation: The restricted detection of scattered light may lead to inaccuracies in determining aerosol optical depth (AOD) and other key optical properties.</li> <li>Correction Techniques: A variety of correction methods, including analytical adjustments and empirical calibration, are employed to counteract truncation errors and refine the accuracy of aerosol optical measurements.</li> </ul>"},{"location":"examples/light_scattering/aerosol_optics_intro/#overview","title":"Overview","text":"<p>This series offers a detailed exploration of aerosol optical phenomena through the lens of Mie scattering theory, analysis of particle size distributions, and methodologies for correcting truncation errors in aerosol instrumentation. By enhancing our understanding of these areas, we aim to further our knowledge of aerosol behavior and its environmental impact.</p> <p>Following notebooks delve deeper into these topics:</p> <ul> <li>Mie Scattering Basics</li> <li>Humidified Particle Scattering</li> <li>Kappa-HGF Estimation from Light Extinction</li> <li>Correcting for Scattering Truncation</li> </ul>"},{"location":"examples/streamlake/particula_data/","title":"Data in Particula","text":"<p>Within Particula, instrument data loading and processing is handled by the <code>particula.data</code> module. This module contains a number of classes and functions that can be used to load and process data from a variety of sources. The <code>particula.data</code> module is designed to be used in conjunction with the <code>particula.model</code> module, which can improve the interpretation of the data.</p>"},{"location":"strategic_plan/Aerosol_patterns/","title":"Program Outline Revision Draft","text":""},{"location":"strategic_plan/Aerosol_patterns/#aerosol-data-objects","title":"Aerosol Data objects","text":"<p>Gas Module</p> <p>This module represents the gaseous environment in which aerosols are suspended. It should encapsulate properties such as vapor pressure, humidity (or water activity), temperature, total pressure, and the masses of each vapor present.</p> <ul> <li>Design Suggestion: Use the Builder Pattern to incrementally construct a complex <code>Gas</code> object . This pattern can handle various combinations of properties efficiently, allowing for clear and flexible gas object creation.</li> </ul> <p>Particle Module</p> <p>Represents individual particles within an aerosol, containing attributes like the mass of species per particle, particle radius, density, and count per particle size.</p> <ul> <li>Design Suggestion: A Composite Pattern might be useful here to treat individual particles and compositions of particles uniformly. This could simplify operations that apply to both single particles and collections of particles, especially when calculating properties that depend on the entire particle ensemble.</li> </ul> <p>Aerosol Module</p> <p>Combines the <code>Gas</code> and <code>Particle</code> modules to represent an aerosol system. It should include a mechanism for evolving the system over time (time step).</p> <ul> <li>Design Suggestion: The Facade Pattern could offer a simplified interface to complex subsystems (Gas and Particle), making the Aerosol module easier to use without sacrificing the flexibility of direct interaction with the subsystems.</li> </ul>"},{"location":"strategic_plan/Aerosol_patterns/#example","title":"Example","text":"<p>To structure the three data classes (Gas, Particle, Aerosol) in code using the design pattern suggestions provided, you would typically follow an object-oriented programming approach. Here's a high-level structure with examples in Python to illustrate how these patterns can be implemented:</p>"},{"location":"strategic_plan/Aerosol_patterns/#gas-module-with-builder-pattern","title":"Gas Module with Builder Pattern","text":"<p>The Builder Pattern is great for constructing complex objects step by step. It allows you to produce different types and representations of an object using the same construction process.</p> <pre><code>class GasBuilder:\n    def __init__(self):\n        self.reset()\n\n    def reset(self):\n        self._product = Gas()\n\n    def set_vapor_pressure(self, pressure):\n        self._product.vapor_pressure = pressure\n        return self\n\n    def set_humidity(self, humidity):\n        self._product.humidity = humidity\n        return self\n\n    def set_temperature(self, temperature):\n        self._product.temperature = temperature\n        return self\n\n    def set_total_pressure(self, total_pressure):\n        self._product.total_pressure = total_pressure\n        return self\n\n    def set_masses(self, masses):\n        self._product.masses = masses\n        return self\n\n    def build(self):\n        product = self._product\n        self.reset()\n        return product\n\nclass Gas:\n    def __init__(self):\n        self.vapor_pressure = None\n        self.humidity = None\n        self.temperature = None\n        self.total_pressure = None\n        self.masses = None\n</code></pre>"},{"location":"strategic_plan/Aerosol_patterns/#revision-of-gas-with-multiple-species","title":"Revision of Gas with multiple species","text":"<p>Given the requirement that the <code>Gas</code> class can contain multiple species, each with its own properties (such as mass), you're correct in considering a structure that allows for this complexity. While the Composite Pattern is traditionally used for part-whole hierarchies, for managing multiple species within a <code>Gas</code> object, a more fitting approach could be using a container within the <code>Gas</code> class to manage these species. However, this container would manage different species and their attributes rather than creating a strict Composite structure. </p> <p>Here's how you can structure the <code>Gas</code> class to accommodate multiple species, focusing on a flexible and extensible design:</p> <pre><code>class GasSpecies:\n    def __init__(self, name, mass, vapor_pressure=None):\n        self.name = name\n        self.mass = mass  # Mass of the species in the gas mixture\n        self.vapor_pressure = vapor_pressure  # Optional, specific to species\n\nclass Gas:\n    def __init__(self, temperature=298.15, total_pressure=101325):\n        self.temperature = temperature\n        self.total_pressure = total_pressure\n        self.species = {}  # Dictionary to hold GasSpecies objects\n\n    def add_species(self, name, mass, vapor_pressure=None):\n        species = GasSpecies(name, mass, vapor_pressure)\n        self.species[name] = species\n\n    def remove_species(self, name):\n        if name in self.species:\n            del self.species[name]\n\n# Example Usage:\ngas_mixture = Gas(temperature=300, total_pressure=101325)\ngas_mixture.add_species('O2', mass=32, vapor_pressure=21300)\ngas_mixture.add_species('N2', mass=28)\n\n# Accessing a species:\nprint(gas_mixture.species['O2'].mass)  # 32\n</code></pre> <p>In this structure, <code>GasSpecies</code> represents an individual gas species, encapsulating properties relevant to a single species, such as its name, mass, and optional properties like vapor pressure. The <code>Gas</code> class then contains a dictionary of these <code>GasSpecies</code> objects, allowing for the addition, modification, and removal of species within the gas mixture.</p> <p>This design offers flexibility and scalability for handling a mixture of gases with varying properties. It also keeps the interface for interacting with individual species straightforward, enabling easy adjustments to the composition of the gas mixture as needed. </p> <p>This approach does not strictly follow the Composite Pattern, as it doesn't aim to treat individual and composite objects uniformly. Instead, it provides a clear way to manage a collection of distinct objects (<code>GasSpecies</code>) within another object (<code>Gas</code>), which is more aligned with your requirements.</p>"},{"location":"strategic_plan/Aerosol_patterns/#particle-module-with-composite-pattern","title":"Particle Module with Composite Pattern","text":"<p>The Composite Pattern allows you to compose objects into tree structures to represent part-whole hierarchies. It lets clients treat individual objects and compositions uniformly.</p> <pre><code>class Particle:\n    def __init__(self, mass, radius, density, count):\n        self.mass = mass\n        self.radius = radius\n        self.density = density\n        self.count = count\n\nclass ParticleComposite:\n    def __init__(self):\n        self._children = []\n\n    def add(self, particle):\n        self._children.append(particle)\n\n    def remove(self, particle):\n        self._children.remove(particle)\n\n    def get_mass(self):\n        return sum(child.mass for child in self._children)\n</code></pre>"},{"location":"strategic_plan/Aerosol_patterns/#aerosol-module-with-facade-pattern","title":"Aerosol Module with Facade Pattern","text":"<p>The Facade Pattern provides a simplified interface to a complex subsystem. Here, the Aerosol class acts as a facade to the Gas and Particle modules, making it easier to interact with these subsystems.</p> <pre><code>class Aerosol:\n    def __init__(self, gas_builder, particles):\n        self.gas = gas_builder.build()\n        self.particles = particles\n\n\n# Example usage\ngas_builder = GasBuilder().set_temperature(300).set_humidity(0.5).set_total_pressure(101325)\nparticles = ParticleComposite()\nparticles.add(Particle(mass=1.2, radius=0.5, density=1.0, count=100))\n\naerosol = Aerosol(gas_builder, particles)\n</code></pre> <p>In this setup: - GasBuilder allows for the flexible construction of a <code>Gas</code> object with various properties. - ParticleComposite manages a collection of <code>Particle</code> objects, enabling operations on groups of particles as if they were a single object. - Aerosol acts as a facade for the complex interactions between <code>Gas</code> and <code>Particle</code> objects, simplifying the usage for clients.</p>"},{"location":"strategic_plan/Aerosol_patterns/#processing-objects","title":"Processing Objects","text":"<p>Defines common interfaces for operations (evaluate, rate, update) that process the aerosol system, taking an aerosol as input and returning an updated aerosol.</p> <ul> <li>Design Suggestion: The Strategy Pattern is ideal here, allowing the algorithm to be selected at runtime. It supports the interchangeable use of different processing methods (e.g., for coagulation or chemical reactions) while maintaining a consistent interface.</li> </ul>"},{"location":"strategic_plan/Aerosol_patterns/#processes-coagulation-vapor-equilibrium-chemical-reaction-nucleation","title":"Processes (Coagulation, Vapor Equilibrium, Chemical Reaction, Nucleation)","text":"<ul> <li>Abstract Factory (Process Factory): This serves as the abstract base for creating families of related or dependent process objects without specifying their concrete classes. It defines the interface for creating different types of process factories (CoagulationFactory, VaporEquilibriumFactory, ChemicalReactionFactory, etc.).</li> </ul>"},{"location":"strategic_plan/Aerosol_patterns/#implementation","title":"Implementation","text":"<p>Process Factory Interface</p> <p>This is the abstract class that declares a set of methods for creating different process objects. Each process (Coagulation, Vapor Equilibrium, etc.) will have its own concrete factory that implements this interface.</p> <p>Concrete Factories</p> <ul> <li> <p>CoagulationFactory: Creates and returns instances of Coagulation processes, with methods tailored to different coagulation strategies (number-based, moving section-based, super droplet-based).</p> </li> <li> <p>VaporEquilibriumFactory: Specializes in creating Vapor Equilibrium processes, providing different methods for handling vapor equilibrium (number-based condensation, moving section-based condensation, etc.).</p> </li> <li> <p>ChemicalReactionFactory: Generates objects for Chemical Reaction processes, offering various methods for different chemical reactions (gas phase, surface, bulk, particle phase, heterogeneous).</p> </li> <li> <p>NucleationFactory: Dedicated to creating Nucleation process objects, with options for homogeneous, heterogeneous, ion-induced, and binary nucleation.</p> </li> <li> <p>WallLossFactory: Focuses on creating Wall Loss processes, suitable for calculating particle loss to walls or boundaries.</p> </li> </ul>"},{"location":"strategic_plan/Aerosol_patterns/#benefits-of-this-approach","title":"Benefits of This Approach","text":"<ul> <li> <p>Flexibility in Process Selection: This structure allows for the dynamic instantiation of processes based on simulation needs or environmental conditions, offering great flexibility and adaptability.</p> </li> <li> <p>Isolation of Construction Logic: By encapsulating the creation logic within each factory, the complexity of object creation is isolated from the rest of the application.</p> </li> <li> <p>Enhanced Modularity: The Abstract Factory pattern promotes a more modular system design, where changes to the process creation mechanism or the introduction of new processes require minimal changes to the codebase.</p> </li> <li> <p>Consistency: Using a standardized interface for creating processes ensures consistency across the application, making it easier to manage and extend.</p> </li> </ul>"},{"location":"strategic_plan/Aerosol_patterns/#implementation-consideration","title":"Implementation Consideration","text":"<p>While the Abstract Factory and Factory Pattern combination provides a robust structure for your aerosol modeling application, it's important to ensure that the design remains flexible and doesn't introduce unnecessary complexity. Keep the interface of your abstract factory and concrete factories clear and intuitive, and only define separate factories for processes that genuinely require different instantiation logic or have distinctly different configurations.</p> <p>from langchain_core.runnables import RunnableLambda</p> <p>def mass_condensation(input = Aerosol, other_settings) -&gt; Aerosol:     # Perform mass condensation calculations     return Aerosol</p> <p>def mass_coagulation(input = Aerosol, other_setting2) -&gt; Aerosol:     # Perform mass coagulation calculations     return Aerosol</p> <p>runnable_1 = mass_condensation(other_settings) runnable_2 = mass_coagulation(other_settings2) sequence = runnable_1 | runnable_2</p>"},{"location":"strategic_plan/Aerosol_patterns/#or-equivalently","title":"Or equivalently:","text":""},{"location":"strategic_plan/Aerosol_patterns/#sequence-runnablesequencefirstrunnable_1-lastrunnable_2","title":"sequence = RunnableSequence(first=runnable_1, last=runnable_2)","text":"<p>sequence.invoke(input=Aerosol)</p>"},{"location":"strategic_plan/strategic_planning_FY24/","title":"FY24 Plan","text":""},{"location":"strategic_plan/strategic_planning_FY24/#review-of-particulas-utilization","title":"Review of Particula's Utilization","text":"<p>Particula has been instrumental in conducting coagulation simulations and educating on atmospheric science concepts over the last year. Feedback indicates a need for more intuitive class structures and simplified code extraction for standalone use.</p> <p>In parallel, Datacula's project has encountered issues with the rigidity of data structures, particularly when adjusting data analysis processes. The need to re-import and reprocess large datasets when changes are made is a significant bottleneck.</p>"},{"location":"strategic_plan/strategic_planning_FY24/#insights-and-reflections","title":"Insights and Reflections","text":"<ul> <li>Particula's Rigidity: The tight coupling within the particula's class structure, connecting environment, vapors, and particles, limits extensibility and complicates comprehension.</li> <li>Datacula's Inflexibility: Similar to Particula, Datacula suffers from tight coupling of data to its analysis processes.</li> <li>Complexity in Modification: Adjusting the coagulation calculations is difficult due to its dependency on other class structures.</li> </ul>"},{"location":"strategic_plan/strategic_planning_FY24/#objectives-for-fy24","title":"Objectives for FY24","text":""},{"location":"strategic_plan/strategic_planning_FY24/#refactoring-particula","title":"Refactoring Particula","text":"<p>The goal is to restructure Particula to facilitate ease of modification and to integrate Datacula for shared functionalities. The proposed structure includes:</p>"},{"location":"strategic_plan/strategic_planning_FY24/#discrete-concepts-functions","title":"Discrete Concepts (Functions)","text":"<ul> <li>Role: To provide standalone functionality like volume alteration or distribution integration usable in external projects.</li> <li>Criteria:</li> <li>Reuse: Extracted when a block is utilized thrice or more.</li> <li>Independence: Users can integrate concepts without additional code dependencies.</li> <li>Documentation: Full documentation with references and commentary in line if the steps are complex.</li> <li>Standardization: All inputs are in SI units, with internal conversions as needed.</li> <li>Testing: Unit tests to ensure functionality.</li> </ul>"},{"location":"strategic_plan/strategic_planning_FY24/#interface-concepts-procedures","title":"Interface Concepts (Procedures)","text":"<ul> <li>Role: To represent procedural workflows, for example, calculating coagulation rates or kappa.</li> <li>Integration: Utilizes multiple discrete functions or other interfaces minimally.</li> <li>Accessibility: Requires installation for full functionality (or coping 3-5 files), suitable for learning from.</li> <li>Documentation: Code doc strings. Accompanied by an illustrative Jupyter notebook, including usage cases, significance, and interrelation with the codebase. What it is, Why it is important, and how it relates to other parts of the code. At least one example of how to use it.</li> <li>Testing: Tests, but just to make sure it loads and all the sub-functions are called.</li> </ul>"},{"location":"strategic_plan/strategic_planning_FY24/#systems-level-concepts-classes","title":"Systems-Level Concepts (Classes)","text":"<ul> <li>Role: To abstract routine tasks, such as ODE coagulation simulation using particle classes.</li> <li>Utility: Serves users requiring higher abstraction without delving into interface mechanics. These people already know what they are calling and how the procedures work.</li> <li>Documentation: Detailed Jupyter notebooks explaining the class's purpose, its importance, and connection to other code components. What it is, Why it is important, and how it relates to other parts of the code. At least three examples of how to use it.</li> <li>Testing: Validated through Jupyter notebook execution.</li> </ul> <p>By adhering to this plan, we aim to boost Particula's adaptability, making it more user-friendly and less time-consuming for large-scale data analysis. The refactoring will be instrumental in fulfilling the dual needs of process simplification and educational clarity.</p>"},{"location":"strategic_plan/strategic_planning_FY24/#conclusion","title":"Conclusion","text":"<p>The proposed refactoring strategy for FY24 is crafted to address the current limitations of Particula and Datacula. It prioritizes modularity, intuitive understanding, and efficient data handling to aid researchers and educators alike.</p>"},{"location":"strategic_plan/strategic_planning_FY24/#fy24-deliverables","title":"FY24 Deliverables","text":""},{"location":"strategic_plan/strategic_planning_FY24/#particula-v010-release","title":"Particula v0.1.0 Release","text":"<p>Scheduled for late winter/early spring, the inaugural release of Particula will have two manuscript publications. This release will encompass:</p> <p>Comprehensive Documentation: An in-depth guide detailing the codebase structure and operational instructions.</p> <p>Interactive Jupyter Notebook: Featuring practical examples to facilitate user engagement with the software. Key Features in Particula v0.1.0</p> <p>Paper 1: A Particula model of the Microphysics and Chemistry of Aerosols - Equilibrium Analysis: Contrasting Thermodynamic and Dynamic Equilibria. - Chemical Processes:   - Implementing Volatility Basis Set (VBS) for chemical reactions, in collaboration with CMU/Neil? - Addressing Non-ideal mixing using BAT/AIOMFAC models, in partnership with McGill-Zuend? - Atmospheric Phenomena Simulation:   - Strategies for simulating smoke, smog, or cloud formation.   - Techniques: Sectional Method and Super Droplet (Direct Simulation). - Processes: Emphasizing Coagulation, Condensation, Evaporation, and Nucleation.   - Impact Analysis: Investigating how initial emissions influence cloud formation and updraft velocity.</p> <p>Paper 2: Data Integration and Experimental Validation - Data pipeline in Particula: Aligning modeling with experimental data form a better understanding of the phenomena. - Remote Sensing Data Incorporation: Exploring integration with DOE-Radar Observations for cloud droplet analysis or other remote sensing data like AERONET. - Case Study: Examining the Saharan Dust transport to the DOE Houston site in 2022?</p>"},{"location":"strategic_plan/strategic_planning_FY24/#collaborative-publications-secondary-role-in-helping-setup-the-codebase-for-collaborators","title":"Collaborative Publications (Secondary role in helping setup the codebase for collaborators)","text":"<ul> <li>LANL Collaboration: CLoud Chamber Characterization and Coagulation Experiments</li> <li>Size dependent wall loss correction</li> <li>Dry (no-humidity) experiments for coagulation at high concentrations (1000 ug/m3)<ul> <li>NaCl (coagulation/wall loss code validation)</li> <li>Sucrose, PEG (coagulation/wall loss code validation)</li> <li>Smoldering Smoke</li> <li>Flaming Smoke (soot): seeing if there is a morphology effect on coagulation</li> <li>Dust + Smoke: Ash fallout analog</li> <li>Dust + Sucrose</li> </ul> </li> <li>MTU Collaboration: Dust Coagulation and Transport</li> <li>Using a Lagrangian model to simulate charge separation (static) and settling of dust.</li> <li>Showing settling lifetimes and how they are effected by charge separation.<ul> <li>Role of humidity?</li> </ul> </li> <li>Theoretical bases for future chamber experiments on dust.</li> <li>MTU Collaboration: Soot in Clouds</li> <li>Using a Lagrangian model to simulate cloud formation, smoke and soot particles.</li> <li>Specifically, exploring the parameter space of initial conditions (emissions) and how much smoke is nucleated vs coagulated to cloud droplets.<ul> <li>Under different turbulence conditions/fields (taken as an a priori input, not simulated).</li> <li>How many droplet activation cycles do particles go through when in a cloud?</li> <li>What comes down in the rain? and what stays after the cloud evaporates?</li> </ul> </li> <li>CMU Collaboration (CLOUD/Neil)</li> <li>They probably have a lot of data, so we could get them started on the code base to look at something interesting.</li> </ul>"},{"location":"strategic_plan/strategic_planning_FY24/#major-milestones-for-fy24","title":"Major Milestones for FY24","text":"<ul> <li> Refactor Sectional Method</li> <li> Wall loss correction, experimental data integration</li> <li> Add Non-ideal Mixing (BAT/AIOMFAC integration, maybe web api)</li> <li> Add Thermodynamic Equilibrium</li> <li> Add Direct Lagrangian Simulation</li> <li> Rough estimates of memory on an RTX A6000 16 GB using pytorch can handle about 5000 particles tracking (position and velocity only) with coagulation checks, time steps of 0.000008 sec, 1000 sec simulation time</li> <li> Add Chemistry (this could come later, but simple VBS bin shift might be achievable)</li> <li> Add Volatility Basis Set (VBS) for chemical reactions</li> <li> Publish Particula v0.1.0</li> <li> Paper 1: A Particula model of the Microphysics and Chemistry of Aerosols</li> <li> Paper 2: Data Integration and Experimental Validation</li> </ul>"}]}